schema {
  query: Query
  mutation: Mutations
}

enum AccountRdiMergeStatus {
  PENDING
  MERGED
}

input AccountabilityCommunicationMessageAgeInput {
  min: Int
  max: Int
}

input AccountabilityFullListArguments {
  excludedAdminAreas: [String]
}

input AccountabilityRandomSamplingArguments {
  excludedAdminAreas: [String]
  confidenceInterval: Float!
  marginOfError: Float!
  age: AccountabilityCommunicationMessageAgeInput
  sex: String
}

input AccountabilitySampleSizeInput {
  paymentPlan: ID
  program: ID
  samplingType: String!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
}

type AccountabilitySampleSizeNode {
  numberOfRecipients: Int
  sampleSize: Int
}

type AccountsNode implements Node {
  id: ID!
  rdiMergeStatus: AccountRdiMergeStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode!
  number: String
  data: JSONString!
  isUnique: Boolean!
  active: Boolean!
  name: String
  individualTabData: JSONString
}

enum Action {
  TP_LOCK
  TP_UNLOCK
  TP_REBUILD
  DRAFT
  LOCK
  LOCK_FSP
  UNLOCK
  UNLOCK_FSP
  SEND_FOR_APPROVAL
  APPROVE
  AUTHORIZE
  REVIEW
  REJECT
  FINISH
  SEND_TO_PAYMENT_GATEWAY
  SEND_XLSX_PASSWORD
}

input ActionPaymentPlanInput {
  paymentPlanId: ID!
  action: Action!
  comment: String
}

type ActionPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type ActivatePaymentVerificationPlan {
  validationErrors: Arg
  paymentPlan: GenericPaymentPlanNode
}

input AddIndividualDataObjectType {
  fullName: String!
  givenName: String
  middleName: String
  familyName: String
  sex: String!
  birthDate: Date!
  estimatedBirthDate: Boolean!
  maritalStatus: String
  phoneNo: String
  phoneNoAlternative: String
  email: String
  relationship: String!
  disability: String
  workStatus: String
  enrolledInNutritionProgramme: Boolean
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String
  hearingDisability: String
  physicalDisability: String
  memoryDisability: String
  selfcareDisability: String
  commsDisability: String
  whoAnswersPhone: String
  whoAnswersAltPhone: String
  role: String!
  documents: [IndividualDocumentObjectType]
  identities: [IndividualIdentityObjectType]
  paymentChannels: [BankTransferObjectType]
  businessArea: String
  preferredLanguage: String
  flexFields: Arg
  paymentDeliveryPhoneNo: String
  blockchainName: String
  walletAddress: String
  walletName: String
}

input AddIndividualIssueTypeExtras {
  household: ID!
  individualData: AddIndividualDataObjectType!
}

type AgeFilterObject {
  min: Int
  max: Int
}

input AgeInput {
  min: Int
  max: Int
}

type ApprovalNode {
  createdAt: DateTime!
  comment: String
  createdBy: UserNode
  info: String
}

type ApprovalProcessNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  sentForApprovalBy: UserNode
  sentForApprovalDate: DateTime
  sentForAuthorizationBy: UserNode
  sentForAuthorizationDate: DateTime
  sentForFinanceReleaseBy: UserNode
  sentForFinanceReleaseDate: DateTime
  paymentPlan: PaymentPlanNode!
  approvalNumberRequired: Int!
  authorizationNumberRequired: Int!
  financeReleaseNumberRequired: Int!
  rejectedOn: String
  actions: FilteredActionsListNode
}

type ApprovalProcessNodeConnection {
  pageInfo: PageInfo!
  edges: [ApprovalProcessNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ApprovalProcessNodeEdge {
  node: ApprovalProcessNode
  cursor: String!
}

type AreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  originalId: UUID
  name: String!
  parent: AreaNode
  pCode: String
  areaType: AreaTypeNode!
  longitude: Float
  latitude: Float
  validFrom: DateTime
  validUntil: DateTime
  extras: JSONString!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  areaSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
}

type AreaNodeConnection {
  pageInfo: PageInfo!
  edges: [AreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AreaNodeEdge {
  node: AreaNode
  cursor: String!
}

type AreaTreeNode {
  id: ID
  name: String
  pCode: String
  areas: [AreaTreeNode]
  level: Int
}

type AreaTypeNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  originalId: UUID
  name: String!
  areaLevel: Int!
  parent: AreaTypeNode
  validFrom: DateTime
  validUntil: DateTime
  extras: JSONString!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  areatypeSet(offset: Int, before: String, after: String, first: Int, last: Int): AreaTypeNodeConnection!
  areaSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
}

type AreaTypeNodeConnection {
  pageInfo: PageInfo!
  edges: [AreaTypeNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AreaTypeNodeEdge {
  node: AreaTypeNode
  cursor: String!
}

scalar Arg

type AssignFundsCommitmentsMutation {
  paymentPlan: PaymentPlanNode
}

input BankTransferObjectType {
  type: String!
  bankName: String!
  bankAccountNumber: String!
  bankBranchName: String
  accountHolderName: String!
}

type BeneficiaryGroupNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  groupLabel: String!
  groupLabelPlural: String!
  memberLabel: String!
  memberLabelPlural: String!
  masterDetail: Boolean!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

scalar BigInt

type BulkGrievanceAddNoteMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BulkUpdateGrievanceTicketsAssigneesMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BulkUpdateGrievanceTicketsPriorityMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BulkUpdateGrievanceTicketsUrgencyMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  slug: String!
  name: String!
  longName: String!
  parent: UserBusinessAreaNode
  partners: [PartnerNode!]!
  isSplit: Boolean!
  regionCode: String!
  regionName: String!
  hasDataSharingAgreement: Boolean!
  isAccountabilityApplicable: Boolean
  active: Boolean!
  enableEmailNotification: Boolean!
  koboUsername: String
  koboToken: String
  koboUrl: String
  rapidProHost: String
  rapidProPaymentVerificationToken: String
  rapidProMessagesToken: String
  rapidProSurveyToken: String
  postponeDeduplication: Boolean!
  deduplicationDuplicateScore: Float!
  deduplicationPossibleDuplicateScore: Float!
  deduplicationBatchDuplicatesPercentage: Int!
  deduplicationBatchDuplicatesAllowed: Int!
  deduplicationGoldenRecordDuplicatesPercentage: Int!
  deduplicationGoldenRecordDuplicatesAllowed: Int!
  screenBeneficiary: Boolean!
  deduplicationIgnoreWithdraw: Boolean!
  biometricDeduplicationThreshold: Float!
  customFields: JSONString!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  dataCollectingTypes(offset: Int, before: String, after: String, first: Int, last: Int): DataCollectingTypeNodeConnection!
  partnerSet: [PartnerNode!]!
  userRoles: [UserRoleNode!]!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualSet(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  registrationdataimportSet(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  ruleSet(offset: Int, before: String, after: String, first: Int, last: Int): SteficonRuleNodeConnection!
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  financialserviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  tickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logentrySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messageSet(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveySet(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  fundscommitmentitemSet(offset: Int, before: String, after: String, first: Int, last: Int): FundsCommitmentItemNodeConnection!
}

type BusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [BusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type BusinessAreaNodeEdge {
  node: BusinessAreaNode
  cursor: String!
}

input CategoryExtrasInput {
  sensitiveGrievanceTicketExtras: SensitiveGrievanceTicketExtras
  grievanceComplaintTicketExtras: GrievanceComplaintTicketExtras
  positiveFeedbackTicketExtras: PositiveFeedbackTicketExtras
  negativeFeedbackTicketExtras: NegativeFeedbackTicketExtras
  referralTicketExtras: ReferralTicketExtras
}

type ChartDatasetNode {
  labels: [String]
  datasets: [_DatasetsNode]
}

type ChartDetailedDatasetsNode {
  labels: [String]
  datasets: [_DetailedDatasetsNode]
}

type ChartGrievanceTicketsNode {
  labels: [String]
  datasets: [_DatasetsNode]
  totalNumberOfGrievances: Int
  totalNumberOfFeedback: Int
  totalNumberOfOpenSensitive: Int
}

type ChartPaymentVerification {
  labels: [String]
  datasets: [_DetailedDatasetsNode]
  households: Int
  averageSampleSize: Float
}

type CheckAgainstSanctionListMutation {
  ok: Boolean
  errors: [XlsxRowErrorNode]
}

type ChoiceObject {
  name: String
  value: String
}

type ChoiceObjectInt {
  name: String
  value: Int
}

type CommunicationMessageNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  title: String!
  body: String!
  createdBy: UserNode
  numberOfRecipients: Int!
  businessArea: UserBusinessAreaNode!
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  paymentPlan: PaymentPlanNode
  registrationDataImport: RegistrationDataImportNode
  samplingType: MessageSamplingType!
  fullListArguments: JSONString
  randomSamplingArguments: JSONString
  sampleSize: Int!
  program: ProgramNode
  isOriginal: Boolean!
  copiedFrom: CommunicationMessageNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  adminUrl: String
}

type CommunicationMessageNodeConnection {
  pageInfo: PageInfo!
  edges: [CommunicationMessageNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CommunicationMessageNodeEdge {
  node: CommunicationMessageNode
  cursor: String!
}

type CommunicationMessageRecipientMapNode implements Node {
  id: ID!
  headOfHousehold: IndividualNode
  size: Int
}

type CommunicationMessageRecipientMapNodeConnection {
  pageInfo: PageInfo!
  edges: [CommunicationMessageRecipientMapNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CommunicationMessageRecipientMapNodeEdge {
  node: CommunicationMessageRecipientMapNode
  cursor: String!
}

type ContentTypeObjectType {
  id: ID!
  appLabel: String!
  model: String!
  logEntries(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  name: String
}

type CopyProgram {
  validationErrors: Arg
  program: ProgramNode
}

input CopyProgramInput {
  id: String!
  name: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  dataCollectingTypeCode: String
  partners: [ProgramPartnerThroughInput]
  partnerAccess: String
  programmeCode: String
  pduFields: [PDUFieldInput]
}

type CopyTargetingCriteriaMutation {
  paymentPlan: PaymentPlanNode
}

type CoreFieldChoiceObject {
  labels: [LabelNode]
  labelEn: String
  value: String
  admin: String
  listName: String
}

type CountAndPercentageNode {
  count: Int
  percentage: Float
}

input CreateAccountabilityCommunicationMessageInput {
  households: [ID]
  paymentPlan: ID
  registrationDataImport: ID
  samplingType: SamplingChoices!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
  title: String!
  body: String!
}

type CreateCommunicationMessageMutation {
  message: CommunicationMessageNode
}

input CreateFeedbackInput {
  issueType: String!
  householdLookup: ID
  individualLookup: ID
  description: String!
  comments: String
  admin2: ID
  area: String
  language: String
  consent: Boolean
  program: ID
}

input CreateFeedbackMessageInput {
  description: String!
  feedback: ID!
}

type CreateFeedbackMessageMutation {
  feedbackMessage: FeedbackMessageNode
}

type CreateFeedbackMutation {
  feedback: FeedbackNode
}

type CreateFollowUpPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

input CreateGrievanceTicketExtrasInput {
  category: CategoryExtrasInput
  issueType: IssueTypeExtrasInput
}

input CreateGrievanceTicketInput {
  description: String!
  assignedTo: ID
  category: Int!
  issueType: Int
  admin: ID
  area: String
  language: String!
  consent: Boolean!
  businessArea: ID!
  linkedTickets: [ID]
  extras: CreateGrievanceTicketExtrasInput
  priority: Int
  urgency: Int
  partner: Int
  program: ID
  comments: String
  linkedFeedbackId: ID
  documentation: [GrievanceDocumentInput]
}

type CreateGrievanceTicketMutation {
  grievanceTickets: [GrievanceTicketNode]
}

input CreatePaymentPlanInput {
  programCycleId: ID!
  name: String!
  targetingCriteria: TargetingCriteriaObjectType!
  excludedIds: String!
  exclusionReason: String
  fspId: ID
  deliveryMechanismCode: String
}

type CreatePaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

input CreatePaymentVerificationInput {
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
  cashOrPaymentPlanId: ID!
}

type CreateProgram {
  validationErrors: Arg
  program: ProgramNode
}

input CreateProgramInput {
  name: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  dataCollectingTypeCode: String
  beneficiaryGroup: String
  partners: [ProgramPartnerThroughInput]
  partnerAccess: String
  programmeCode: String
  pduFields: [PDUFieldInput]
}

type CreateReport {
  report: ReportNode
}

input CreateReportInput {
  reportType: Int!
  businessAreaSlug: String!
  dateFrom: Date!
  dateTo: Date!
  program: ID
  adminArea1: ID
  adminArea2: [ID]
}

input CreateSurveyInput {
  title: String!
  body: String
  category: String!
  paymentPlan: ID
  program: ID
  samplingType: String!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
  flow: String!
}

type CreateSurveyMutation {
  survey: SurveyNode
}

input CreateTicketNoteInput {
  description: String!
  ticket: ID!
}

type CreateTicketNoteMutation {
  grievanceTicketNote: TicketNoteNode
}

type CreateVerificationPlanMutation {
  paymentPlan: GenericPaymentPlanNode
}

type DataCollectingTypeChoiceObject {
  name: String
  value: String
  description: String
  type: String
}

type DataCollectingTypeNode implements Node {
  id: ID!
  created: DateTime!
  modified: DateTime!
  code: String!
  label: String!
  type: DataCollectingTypeType
  description: String!
  active: Boolean!
  deprecated: Boolean!
  individualFiltersAvailable: Boolean!
  householdFiltersAvailable: Boolean!
  recalculateComposition: Boolean!
  weight: Int!
  datacollectingtypeSet(offset: Int, before: String, after: String, first: Int, last: Int): DataCollectingTypeNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

type DataCollectingTypeNodeConnection {
  pageInfo: PageInfo!
  edges: [DataCollectingTypeNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DataCollectingTypeNodeEdge {
  node: DataCollectingTypeNode
  cursor: String!
}

enum DataCollectingTypeType {
  STANDARD
  SOCIAL
}

scalar Date

scalar DateTime

scalar Decimal

type DeduplicationEngineSimilarityPairIndividualNode {
  id: String
  photo: String
  fullName: String
  unicefId: String
  similarityScore: Float
  age: Int
  location: String
}

type DeduplicationEngineSimilarityPairNode {
  individual1: DeduplicationEngineSimilarityPairIndividualNode
  individual2: DeduplicationEngineSimilarityPairIndividualNode
  similarityScore: String
  statusCode: String
}

type DeduplicationResultNode {
  unicefId: String
  hitId: ID
  fullName: String
  score: Float
  proximityToScore: Float
  location: String
  age: Int
  duplicate: Boolean
  distinct: Boolean
}

type DeleteHouseholdApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type DeletePaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type DeletePaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

type DeleteProgram {
  ok: Boolean
}

type DeleteRegistrationDataImport {
  ok: Boolean
}

type DeliveredQuantityNode {
  totalDeliveredQuantity: Decimal
  currency: String
}

type DeliveryMechanismChoice {
  name: String
  code: String
}

type DeliveryMechanismNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentGatewayId: String
  code: String
  name: String
  isActive: Boolean!
  transferType: DeliveryMechanismTransferType!
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  financialserviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
}

type DeliveryMechanismNodeConnection {
  pageInfo: PageInfo!
  edges: [DeliveryMechanismNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DeliveryMechanismNodeEdge {
  node: DeliveryMechanismNode
  cursor: String!
}

type DeliveryMechanismPerPaymentPlanNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  internalData: JSONString!
  businessArea: UserBusinessAreaNode!
  programCycle: ProgramCycleNode!
  deliveryMechanism: DeliveryMechanismNode
  financialServiceProvider: FinancialServiceProviderNode
  steficonRule: RuleCommitNode
  steficonRuleTargeting: RuleCommitNode
  createdBy: UserNode!
  targetingCriteria: TargetingCriteriaNode!
  sourcePaymentPlan: PaymentPlanNode
  name: String
  startDate: DateTime
  endDate: DateTime
  currency: PaymentPlanCurrency
  dispersionStartDate: Date
  dispersionEndDate: Date
  excludedIds: String
  exclusionReason: String
  vulnerabilityScoreMin: Float
  vulnerabilityScoreMax: Float
  status: PaymentPlanStatus!
  backgroundActionStatus: PaymentPlanBackgroundActionStatus
  buildStatus: PaymentPlanBuildStatus
  builtAt: DateTime
  exchangeRate: Float
  femaleChildrenCount: Int!
  maleChildrenCount: Int!
  femaleAdultsCount: Int!
  maleAdultsCount: Int!
  totalHouseholdsCount: Int!
  totalIndividualsCount: Int!
  importedFileDate: DateTime
  totalEntitledQuantity: Float
  totalEntitledQuantityUsd: Float
  totalEntitledQuantityRevised: Float
  totalEntitledQuantityRevisedUsd: Float
  totalDeliveredQuantity: Float
  totalDeliveredQuantityUsd: Float
  totalUndeliveredQuantity: Float
  totalUndeliveredQuantityUsd: Float
  steficonTargetingAppliedDate: DateTime
  steficonAppliedDate: DateTime
  isFollowUp: Boolean!
  excludeHouseholdError: String
  statusDate: DateTime!
  isCashAssist: Boolean!
  approvalProcess(offset: Int, before: String, after: String, first: Int, last: Int): ApprovalProcessNodeConnection!
  followUps(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  paymentItems(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanSupportingDocumentNodeConnection!
  paymentVerificationPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationPlanNodeConnection!
  paymentVerificationSummary: PaymentVerificationSummaryNode
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  fundsCommitments(offset: Int, before: String, after: String, first: Int, last: Int): FundsCommitmentItemNodeConnection!
  code: String
  fsp: FinancialServiceProviderNode
}

enum DeliveryMechanismTransferType {
  CASH
  VOUCHER
  DIGITAL
}

type DiscardPaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

type DjangoDebug {
  sql: [DjangoDebugSQL]
}

type DjangoDebugSQL {
  vendor: String!
  alias: String!
  sql: String
  duration: Float!
  rawSql: String!
  params: String!
  startTime: Float!
  stopTime: Float!
  isSlow: Boolean!
  isSelect: Boolean!
  transId: String
  transStatus: String
  isoLevel: String
  encoding: String
}

type DocumentNode implements Node {
  id: ID!
  rdiMergeStatus: DocumentRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  individual: IndividualNode!
  program: ProgramNode
  documentNumber: String!
  type: ImportedDocumentTypeNode!
  country: String
  status: DocumentStatus!
  photo: String
  cleared: Boolean!
  clearedDate: DateTime!
  clearedBy: UserNode
  issuanceDate: DateTime
  expiryDate: DateTime
  isMigrationHandled: Boolean!
  copiedFrom: DocumentNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  countryIso3: String
}

type DocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [DocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DocumentNodeEdge {
  node: DocumentNode
  cursor: String!
}

enum DocumentRdiMergeStatus {
  PENDING
  MERGED
}

enum DocumentStatus {
  PENDING
  VALID
  NEED_INVESTIGATION
  INVALID
}

input EditBankTransferObjectType {
  id: ID!
  type: String!
  bankName: String!
  bankAccountNumber: String!
  bankBranchName: String
  accountHolderName: String!
}

input EditIndividualDocumentObjectType {
  id: ID!
  country: String!
  key: String!
  number: String!
  photo: Arg
  photoraw: Arg
}

input EditIndividualIdentityObjectType {
  id: ID!
  country: String!
  partner: String!
  number: String!
}

input EditPaymentVerificationInput {
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
  paymentVerificationPlanId: ID!
}

type EditPaymentVerificationMutation {
  paymentPlan: GenericPaymentPlanNode
}

type EraseRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

type ExcludeHouseholdsMutation {
  paymentPlan: PaymentPlanNode
}

type ExportPDFPaymentPlanSummaryMutation {
  paymentPlan: PaymentPlanNode
}

type ExportSurveySampleMutationMutation {
  survey: SurveyNode
}

type ExportXLSXPaymentPlanPaymentListMutation {
  paymentPlan: PaymentPlanNode
}

type ExportXLSXPaymentPlanPaymentListPerFSPMutation {
  paymentPlan: PaymentPlanNode
}

type ExportXlsxPaymentVerificationPlanFile {
  paymentPlan: GenericPaymentPlanNode
}

enum FeedbackIssueType {
  POSITIVE_FEEDBACK
  NEGATIVE_FEEDBACK
}

type FeedbackMessageNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  createdBy: UserNode
}

type FeedbackMessageNodeConnection {
  pageInfo: PageInfo!
  edges: [FeedbackMessageNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FeedbackMessageNodeEdge {
  node: FeedbackMessageNode
  cursor: String!
}

type FeedbackNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  issueType: FeedbackIssueType!
  householdLookup: HouseholdNode
  individualLookup: IndividualNode
  businessArea: UserBusinessAreaNode!
  program: ProgramNode
  area: String!
  admin2: AreaNode
  description: String!
  language: String!
  comments: String
  createdBy: UserNode
  linkedGrievance: GrievanceTicketNode
  consent: Boolean!
  isOriginal: Boolean!
  copiedFrom: FeedbackNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  feedbackMessages(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackMessageNodeConnection!
  adminUrl: String
}

type FeedbackNodeConnection {
  pageInfo: PageInfo!
  edges: [FeedbackNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FeedbackNodeEdge {
  node: FeedbackNode
  cursor: String!
}

type FieldAttributeNode {
  id: String
  type: String
  name: String
  labels: [LabelNode]
  labelEn: String
  hint: String
  required: Boolean
  choices: [CoreFieldChoiceObject]
  associatedWith: String
  isFlexField: Boolean
  pduData: PeriodicFieldDataNode
}

type FilteredActionsListNode {
  approval: [ApprovalNode]
  authorization: [ApprovalNode]
  financeRelease: [ApprovalNode]
  reject: [ApprovalNode]
}

enum FinancialServiceProviderCommunicationChannel {
  API
  SFTP
  XLSX
}

type FinancialServiceProviderNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  internalData: JSONString!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  createdBy: UserNode
  name: String!
  visionVendorNumber: String!
  deliveryMechanisms(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismNodeConnection!
  distributionLimit: Float
  communicationChannel: FinancialServiceProviderCommunicationChannel!
  dataTransferConfiguration: JSONString
  xlsxTemplates(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderXlsxTemplateNodeConnection!
  paymentGatewayId: String
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  fullName: String
  isPaymentGateway: Boolean
}

type FinancialServiceProviderNodeConnection {
  pageInfo: PageInfo!
  edges: [FinancialServiceProviderNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FinancialServiceProviderNodeEdge {
  node: FinancialServiceProviderNode
  cursor: String!
}

type FinancialServiceProviderXlsxTemplateNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: UserNode
  name: String!
  columns: [String]
  coreFields: [String!]!
  flexFields: [String!]!
  documentTypes: [String!]!
  financialServiceProviders(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
}

type FinancialServiceProviderXlsxTemplateNodeConnection {
  pageInfo: PageInfo!
  edges: [FinancialServiceProviderXlsxTemplateNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FinancialServiceProviderXlsxTemplateNodeEdge {
  node: FinancialServiceProviderXlsxTemplateNode
  cursor: String!
}

type FinishPaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

enum FlexFieldClassificationChoices {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

scalar FlexFieldsScalar

type FspChoice {
  id: String
  name: String
}

type FspChoices {
  deliveryMechanism: DeliveryMechanismChoice
  fsps: [FspChoice]
}

input FullListArguments {
  excludedAdminAreas: [String]
}

type FundsCommitmentItemNode implements Node {
  paymentPlan: PaymentPlanNode
  fundsCommitmentItem: String!
  recSerialNumber: Int!
  vendorId: String
  businessArea: String
  postingDate: Date
  visionApproval: String
  documentReference: String
  fcStatus: String
  wbsElement: String
  grantNumber: String
  documentType: String
  documentText: String
  currencyCode: String
  glAccount: String
  commitmentAmountLocal: Float
  commitmentAmountUsd: Float
  totalOpenAmountLocal: Float
  totalOpenAmountUsd: Float
  sponsor: String
  sponsorName: String
  fund: String
  fundsCenter: String
  percentage: Float
  createDate: DateTime
  createdBy: String
  updateDate: DateTime
  updatedBy: String
  office: UserBusinessAreaNode
  id: ID!
}

type FundsCommitmentItemNodeConnection {
  pageInfo: PageInfo!
  edges: [FundsCommitmentItemNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FundsCommitmentItemNodeEdge {
  node: FundsCommitmentItemNode
  cursor: String!
}

type FundsCommitmentNode {
  fundsCommitmentNumber: String
  fundsCommitmentItems: [FundsCommitmentItemNode]
  insufficientAmount: Boolean
}

type GenericPaymentNode {
  id: String
  objType: String
  unicefId: String
  currency: String
  deliveredQuantity: Float
  deliveredQuantityUsd: Float
  household: HouseholdNode
}

type GenericPaymentPlanNode {
  id: String
  objType: String
  paymentVerificationSummary: PaymentVerificationSummaryNode
  availablePaymentRecordsCount: Int
  verificationPlans(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  statusDate: DateTime
  status: String
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
  deliveryType: String
  totalNumberOfHouseholds: Int
  currency: String
  totalDeliveredQuantity: Float
  totalEntitledQuantity: Float
  totalUndeliveredQuantity: Float
  canCreatePaymentVerificationPlan: Boolean
}

input GetAccountabilityCommunicationMessageSampleSizeInput {
  households: [ID]
  paymentPlan: ID
  registrationDataImport: ID
  samplingType: SamplingChoices!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
}

input GetCashplanVerificationSampleSizeInput {
  cashOrPaymentPlanId: ID
  paymentVerificationPlanId: ID
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

type GetCashplanVerificationSampleSizeObject {
  paymentRecordCount: Int
  sampleSize: Int
}

type GetCommunicationMessageSampleSizeNode {
  numberOfRecipients: Int
  sampleSize: Int
}

input GrievanceComplaintTicketExtras {
  household: ID
  individual: ID
  paymentRecord: [ID]
}

input GrievanceDocumentInput {
  name: String!
  file: Upload!
}

type GrievanceDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  grievanceTicket: GrievanceTicketNode
  createdBy: UserNode
  contentType: String!
  fileSize: Int
  filePath: String
  fileName: String
}

type GrievanceDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [GrievanceDocumentNodeEdge]!
}

type GrievanceDocumentNodeEdge {
  node: GrievanceDocumentNode
  cursor: String!
}

input GrievanceDocumentUpdateInput {
  id: ID!
  name: String
  file: Upload
}

type GrievanceStatusChangeMutation {
  grievanceTicket: GrievanceTicketNode
}

type GrievanceTicketNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  businessArea: UserBusinessAreaNode!
  programs: [ProgramNode]
  registrationDataImport: RegistrationDataImportNode
  partner: PartnerType
  linkedTickets: [GrievanceTicketNode]
  householdUnicefId: String
  priority: Int
  urgency: Int
  category: Int!
  issueType: Int
  description: String!
  status: Int!
  area: String!
  admin2: AreaNode
  language: String!
  consent: Boolean!
  ignored: Boolean!
  extras: JSONString!
  comments: String
  isOriginal: Boolean!
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  copiedFrom: GrievanceTicketNode
  userModified: DateTime
  lastNotificationSent: DateTime
  createdBy: UserNode
  assignedTo: UserNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  ticketNotes(offset: Int, before: String, after: String, first: Int, last: Int): TicketNoteNodeConnection!
  complaintTicketDetails: TicketComplaintDetailsNode
  sensitiveTicketDetails: TicketSensitiveDetailsNode
  householdDataUpdateTicketDetails: TicketHouseholdDataUpdateDetailsNode
  individualDataUpdateTicketDetails: TicketIndividualDataUpdateDetailsNode
  addIndividualTicketDetails: TicketAddIndividualDetailsNode
  deleteIndividualTicketDetails: TicketDeleteIndividualDetailsNode
  deleteHouseholdTicketDetails: TicketDeleteHouseholdDetailsNode
  systemFlaggingTicketDetails: TicketSystemFlaggingDetailsNode
  needsAdjudicationTicketDetails: TicketNeedsAdjudicationDetailsNode
  paymentVerificationTicketDetails: TicketPaymentVerificationDetailsNode
  positiveFeedbackTicketDetails: TicketPositiveFeedbackDetailsNode
  negativeFeedbackTicketDetails: TicketNegativeFeedbackDetailsNode
  referralTicketDetails: TicketReferralDetailsNode
  supportDocuments(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceDocumentNodeConnection!
  feedback: FeedbackNode
  adminUrl: String
  household: HouseholdNode
  individual: IndividualNode
  paymentRecord: PaymentNode
  admin: String
  existingTickets: [GrievanceTicketNode]
  relatedTickets: [GrievanceTicketNode]
  totalDays: String
  documentation: [GrievanceDocumentNode]
  targetId: String
}

type GrievanceTicketNodeConnection {
  pageInfo: PageInfo!
  edges: [GrievanceTicketNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type GrievanceTicketNodeEdge {
  node: GrievanceTicketNode
  cursor: String!
}

type GroupAttributeNode {
  id: UUID!
  name: String!
  label: JSONString!
  flexAttributes(flexField: Boolean): [FieldAttributeNode]
  labelEn: String
}

enum HouseholdCollectType {
  STANDARD
  SINGLE
}

type HouseholdDataChangeApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input HouseholdDataUpdateIssueTypeExtras {
  household: ID!
  householdData: HouseholdUpdateDataObjectType!
}

input HouseholdDeleteIssueTypeExtras {
  household: ID!
}

type HouseholdNode implements Node {
  id: ID!
  headOfHousehold: IndividualNode
  size: Int
  rdiMergeStatus: HouseholdRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  unicefId: String
  internalData: JSONString!
  businessArea: UserBusinessAreaNode!
  program: ProgramNode!
  registrationDataImport: RegistrationDataImportNode
  representatives(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  copiedFrom: HouseholdNode
  countryOrigin: String
  country: String
  adminArea: AreaNode
  admin1: AreaNode
  admin2: AreaNode
  admin3: AreaNode
  admin4: AreaNode
  consentSign: String!
  consent: Boolean
  consentSharing: [String]
  residenceStatus: String
  address: String!
  zipCode: String
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  childrenCount: Int
  maleChildrenCount: Int
  femaleChildrenCount: Int
  childrenDisabledCount: Int
  maleChildrenDisabledCount: Int
  femaleChildrenDisabledCount: Int
  otherSexGroupCount: Int
  unknownSexGroupCount: Int
  returnee: Boolean
  fchildHoh: Boolean
  childHoh: Boolean
  village: String!
  currency: String
  unhcrId: String!
  detailId: String
  start: DateTime
  registrationMethod: HouseholdRegistrationMethod!
  familyId: String
  originUnicefId: String
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  collectType: HouseholdCollectType!
  programRegistrationId: String
  totalCashReceivedUsd: Decimal
  totalCashReceived: Decimal
  flexFields: FlexFieldsScalar
  firstRegistrationDate: DateTime!
  lastRegistrationDate: DateTime!
  withdrawn: Boolean!
  withdrawnDate: DateTime
  longitude: Float
  latitude: Float
  deviceid: String!
  nameEnumerator: String!
  orgEnumerator: HouseholdOrgEnumerator!
  orgNameEnumerator: String!
  koboSubmissionUuid: UUID
  koboSubmissionTime: DateTime
  enumeratorRecId: Int
  flexRegistrationsRecordId: Int
  extraRdis(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  identificationKey: String
  collisionFlag: Boolean!
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualsAndRoles: [IndividualRoleInHouseholdNode!]!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int, household_Id: UUID, businessArea: String, fullName: String, fullName_Startswith: String, fullName_Endswith: String, sex: [String], household_AdminArea: ID, withdrawn: Boolean, program: ID, age: String, programs: [ID], search: String, documentType: String, documentNumber: String, lastRegistrationDate: String, admin1: [ID], admin2: [ID], status: [String], excludedId: String, flags: [String], isActiveProgram: Boolean, rdiId: String, duplicatesOnly: Boolean, rdiMergeStatus: String, orderBy: String): IndividualNodeConnection
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  householdDataUpdateTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketHouseholdDataUpdateDetailsNodeConnection!
  addIndividualTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketAddIndividualDetailsNodeConnection!
  deleteHouseholdTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketDeleteHouseholdDetailsNodeConnection!
  positiveFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPositiveFeedbackDetailsNodeConnection!
  negativeFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketNegativeFeedbackDetailsNodeConnection!
  referralTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketReferralDetailsNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  adminUrl: String
  sanctionListPossibleMatch: Boolean
  sanctionListConfirmedMatch: Boolean
  hasDuplicates: Boolean
  hasDuplicatesForRdi: Boolean
  adminAreaTitle: String
  status: String
  deliveredQuantities: [DeliveredQuantityNode]
  activeIndividualsCount: Int
  importId: String
  geopoint: String
}

type HouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [HouseholdNodeEdge]!
  totalCount: Int
  individualsCount: Int
  edgeCount: Int
}

type HouseholdNodeEdge {
  node: HouseholdNode
  cursor: String!
}

enum HouseholdOrgEnumerator {
  A_
  PARTNER
  UNICEF
}

enum HouseholdRdiMergeStatus {
  PENDING
  MERGED
}

enum HouseholdRegistrationMethod {
  A_
  COMMUNITY
  HH_REGISTRATION
}

input HouseholdUpdateDataObjectType {
  adminAreaTitle: String
  status: String
  consent: Boolean
  consentSharing: [String]
  residenceStatus: String
  countryOrigin: String
  country: String
  size: Int
  address: String
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  returnee: Boolean
  fchildHoh: Boolean
  childHoh: Boolean
  start: DateTime
  end: DateTime
  nameEnumerator: String
  orgEnumerator: String
  orgNameEnumerator: String
  village: String
  registrationMethod: String
  currency: String
  unhcrId: String
  flexFields: Arg
}

enum ImportDataDataType {
  XLSX
  JSON
  FLEX
}

type ImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ImportDataStatus!
  businessAreaSlug: String!
  dataType: ImportDataDataType!
  file: String
  numberOfHouseholds: Int
  numberOfIndividuals: Int
  error: String!
  validationErrors: String!
  deliveryMechanismsValidationErrors: String!
  createdById: UUID
  registrationDataImportHope: RegistrationDataImportNode
  koboimportdata: KoboImportDataNode
  registrationDataImport: RegistrationDataImportDatahubNode
  xlsxValidationErrors: [XlsxRowErrorNode]
}

enum ImportDataStatus {
  PENDING
  RUNNING
  FINISHED
  ERROR
  VALIDATION_ERROR
}

type ImportXLSXPaymentPlanPaymentListMutation {
  paymentPlan: PaymentPlanNode
  errors: [XlsxErrorNode]
}

type ImportXLSXPaymentPlanPaymentListPerFSPMutation {
  paymentPlan: PaymentPlanNode
  errors: [XlsxErrorNode]
}

type ImportXlsxPaymentVerificationPlanFile {
  paymentPlan: GenericPaymentPlanNode
  errors: [XlsxErrorNode]
}

type ImportedDocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  key: String!
  isIdentityDocument: Boolean!
  uniqueForIndividual: Boolean!
  validForDeduplication: Boolean!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
}

enum IndividualBiometricDeduplicationBatchStatus {
  DUPLICATE_IN_BATCH
  NOT_PROCESSED
  SIMILAR_IN_BATCH
  UNIQUE_IN_BATCH
}

enum IndividualBiometricDeduplicationGoldenRecordStatus {
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
  POSTPONE
  UNIQUE
}

type IndividualDataChangeApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input IndividualDataUpdateIssueTypeExtras {
  individual: ID!
  individualData: IndividualUpdateDataObjectType!
}

enum IndividualDeduplicationBatchStatus {
  DUPLICATE_IN_BATCH
  NOT_PROCESSED
  SIMILAR_IN_BATCH
  UNIQUE_IN_BATCH
}

enum IndividualDeduplicationGoldenRecordStatus {
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
  POSTPONE
  UNIQUE
}

input IndividualDeleteIssueTypeExtras {
  individual: ID!
}

enum IndividualDisability {
  DISABLED
  NOT_DISABLED
}

input IndividualDocumentObjectType {
  country: String!
  key: String!
  number: String!
  photo: Arg
  photoraw: Arg
}

type IndividualIdentityNode implements Node {
  id: ID!
  created: DateTime!
  modified: DateTime!
  rdiMergeStatus: IndividualIdentityRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  individual: IndividualNode!
  partner: String
  country: String
  number: String!
  isMigrationHandled: Boolean!
  copiedFrom: IndividualIdentityNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  countryIso3: String
}

type IndividualIdentityNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualIdentityNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualIdentityNodeEdge {
  node: IndividualIdentityNode
  cursor: String!
}

input IndividualIdentityObjectType {
  country: String!
  partner: String!
  number: String!
}

enum IndividualIdentityRdiMergeStatus {
  PENDING
  MERGED
}

enum IndividualMaritalStatus {
  A_
  DIVORCED
  MARRIED
  SEPARATED
  SINGLE
  WIDOWED
}

type IndividualNode implements Node {
  id: ID!
  rdiMergeStatus: IndividualRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  unicefId: String
  internalData: JSONString!
  businessArea: UserBusinessAreaNode!
  program: ProgramNode!
  registrationDataImport: RegistrationDataImportNode!
  household: HouseholdNode
  copiedFrom: IndividualNode
  individualId: String!
  photo: String
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  sex: IndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: IndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  email: String
  paymentDeliveryPhoneNo: String
  relationship: IndividualRelationship
  workStatus: String!
  pregnant: Boolean
  fchildHoh: Boolean!
  childHoh: Boolean!
  disability: IndividualDisability!
  observedDisability: [String]
  disabilityCertificatePicture: String
  seeingDisability: String!
  hearingDisability: String!
  physicalDisability: String!
  memoryDisability: String!
  selfcareDisability: String!
  commsDisability: String!
  whoAnswersPhone: String!
  whoAnswersAltPhone: String!
  preferredLanguage: String
  relationshipConfirmed: Boolean!
  walletName: String!
  blockchainName: String!
  walletAddress: String!
  duplicate: Boolean!
  duplicateDate: DateTime
  withdrawn: Boolean!
  withdrawnDate: DateTime
  flexFields: FlexFieldsScalar
  phoneNoValid: Boolean
  phoneNoAlternativeValid: Boolean
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  enrolledInNutritionProgramme: Boolean
  deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus!
  deduplicationBatchStatus: IndividualDeduplicationBatchStatus!
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  deduplicationBatchResults: [DeduplicationResultNode]
  biometricDeduplicationGoldenRecordStatus: IndividualBiometricDeduplicationGoldenRecordStatus!
  biometricDeduplicationBatchStatus: IndividualBiometricDeduplicationBatchStatus!
  biometricDeduplicationGoldenRecordResults: [DeduplicationEngineSimilarityPairIndividualNode]
  biometricDeduplicationBatchResults: [DeduplicationEngineSimilarityPairIndividualNode]
  importedIndividualId: UUID
  sanctionListPossibleMatch: Boolean!
  sanctionListConfirmedMatch: Boolean!
  detailId: String
  programRegistrationId: String
  ageAtRegistration: Int
  originUnicefId: String
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  representedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  headingHousehold: HouseholdNode
  documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection
  identities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection
  householdsAndRoles: [IndividualRoleInHouseholdNode!]!
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  collectorPayments(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  accounts: [AccountsNode]
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  individualDataUpdateTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketIndividualDataUpdateDetailsNodeConnection!
  deleteIndividualTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketDeleteIndividualDetailsNodeConnection!
  ticketsystemflaggingdetailsSet(offset: Int, before: String, after: String, first: Int, last: Int): TicketSystemFlaggingDetailsNodeConnection!
  ticketGoldenRecords(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  ticketDuplicates(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  selectedDistinct(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  ticketSelected(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  positiveFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPositiveFeedbackDetailsNodeConnection!
  negativeFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketNegativeFeedbackDetailsNodeConnection!
  referralTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketReferralDetailsNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  adminUrl: String
  status: String
  role: String
  age: Int
  sanctionListLastCheck: DateTime
  importId: String
}

type IndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualNodeEdge {
  node: IndividualNode
  cursor: String!
}

enum IndividualRdiMergeStatus {
  PENDING
  MERGED
}

enum IndividualRelationship {
  UNKNOWN
  AUNT_UNCLE
  BROTHER_SISTER
  COUSIN
  DAUGHTERINLAW_SONINLAW
  GRANDDAUGHER_GRANDSON
  GRANDMOTHER_GRANDFATHER
  HEAD
  MOTHER_FATHER
  MOTHERINLAW_FATHERINLAW
  NEPHEW_NIECE
  NON_BENEFICIARY
  OTHER
  SISTERINLAW_BROTHERINLAW
  SON_DAUGHTER
  WIFE_HUSBAND
  FOSTER_CHILD
  FREE_UNION
}

type IndividualRoleInHouseholdNode {
  id: UUID!
  rdiMergeStatus: IndividualRoleInHouseholdRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  individual: IndividualNode!
  household: HouseholdNode!
  role: IndividualRoleInHouseholdRole
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  copiedFrom: IndividualRoleInHouseholdNode
  copiedTo: [IndividualRoleInHouseholdNode!]!
}

enum IndividualRoleInHouseholdRdiMergeStatus {
  PENDING
  MERGED
}

enum IndividualRoleInHouseholdRole {
  NO_ROLE
  ALTERNATE
  PRIMARY
}

enum IndividualSex {
  MALE
  FEMALE
  OTHER
  NOT_COLLECTED
  NOT_ANSWERED
}

input IndividualUpdateDataObjectType {
  status: String
  fullName: String
  givenName: String
  middleName: String
  familyName: String
  sex: String
  birthDate: Date
  estimatedBirthDate: Boolean
  maritalStatus: String
  phoneNo: String
  phoneNoAlternative: String
  email: String
  relationship: String
  disability: String
  workStatus: String
  enrolledInNutritionProgramme: Boolean
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String
  hearingDisability: String
  physicalDisability: String
  memoryDisability: String
  selfcareDisability: String
  commsDisability: String
  whoAnswersPhone: String
  whoAnswersAltPhone: String
  role: String
  documents: [IndividualDocumentObjectType]
  documentsToRemove: [ID]
  documentsToEdit: [EditIndividualDocumentObjectType]
  identities: [IndividualIdentityObjectType]
  identitiesToRemove: [ID]
  identitiesToEdit: [EditIndividualIdentityObjectType]
  paymentChannels: [BankTransferObjectType]
  paymentChannelsToEdit: [EditBankTransferObjectType]
  paymentChannelsToRemove: [ID]
  preferredLanguage: String
  flexFields: Arg
  paymentDeliveryPhoneNo: String
  blockchainName: String
  walletAddress: String
  walletName: String
  consent: Boolean
  residenceStatus: String
  countryOrigin: String
  country: String
  address: String
  village: String
  currency: String
  unhcrId: String
  nameEnumerator: String
  orgEnumerator: String
  orgNameEnumerator: String
  registrationMethod: String
  adminAreaTitle: String
}

type InvalidPaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

input IssueTypeExtrasInput {
  householdDataUpdateIssueTypeExtras: HouseholdDataUpdateIssueTypeExtras
  individualDataUpdateIssueTypeExtras: IndividualDataUpdateIssueTypeExtras
  individualDeleteIssueTypeExtras: IndividualDeleteIssueTypeExtras
  householdDeleteIssueTypeExtras: HouseholdDeleteIssueTypeExtras
  addIndividualIssueTypeExtras: AddIndividualIssueTypeExtras
}

type IssueTypesObject {
  category: String
  label: String
  subCategories: [ChoiceObject]
}

scalar JSONString

type KoboAssetObject {
  id: String
  name: String
  sector: String
  country: String
  assetType: String
  dateModified: DateTime
  deploymentActive: Boolean
  hasDeployment: Boolean
  xlsLink: String
}

type KoboAssetObjectConnection {
  pageInfo: PageInfo!
  edges: [KoboAssetObjectEdge]!
  totalCount: Int
}

type KoboAssetObjectEdge {
  node: KoboAssetObject
  cursor: String!
}

type KoboErrorNode {
  header: String
  message: String
}

type KoboImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ImportDataStatus!
  businessAreaSlug: String!
  dataType: ImportDataDataType!
  file: String
  numberOfHouseholds: Int
  numberOfIndividuals: Int
  error: String!
  validationErrors: String!
  deliveryMechanismsValidationErrors: String!
  createdById: UUID
  importdataPtr: ImportDataNode!
  koboAssetId: String!
  onlyActiveSubmissions: Boolean!
  pullPictures: Boolean!
  koboValidationErrors: [KoboErrorNode]
}

type LabelNode {
  language: String
  label: String
}

type LanguageObject {
  english: String
  code: String
}

type LanguageObjectConnection {
  pageInfo: PageInfo!
  edges: [LanguageObjectEdge]!
  totalCount: Int
}

type LanguageObjectEdge {
  node: LanguageObject
  cursor: String!
}

enum LogEntryAction {
  CREATE
  UPDATE
  DELETE
  SOFT_DELETE
}

type LogEntryNode implements Node {
  id: ID!
  contentType: ContentTypeObjectType
  objectId: UUID
  action: LogEntryAction!
  objectRepr: String!
  changes: Arg
  user: UserNode
  businessArea: UserBusinessAreaNode
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  timestamp: DateTime
  isUserGenerated: Boolean
}

type LogEntryNodeConnection {
  pageInfo: PageInfo!
  edges: [LogEntryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type LogEntryNodeEdge {
  node: LogEntryNode
  cursor: String!
}

type MarkPaymentAsFailedMutation {
  payment: PaymentNode
}

type MergeRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

enum MessageSamplingType {
  FULL_LIST
  RANDOM
}

type Mutations {
  createAccountabilityCommunicationMessage(input: CreateAccountabilityCommunicationMessageInput!): CreateCommunicationMessageMutation
  createFeedback(input: CreateFeedbackInput!): CreateFeedbackMutation
  updateFeedback(input: UpdateFeedbackInput!): UpdateFeedbackMutation
  createFeedbackMessage(input: CreateFeedbackMessageInput!): CreateFeedbackMessageMutation
  createSurvey(input: CreateSurveyInput!): CreateSurveyMutation
  exportSurveySample(surveyId: ID!): ExportSurveySampleMutationMutation
  createReport(reportData: CreateReportInput!): CreateReport
  restartCreateReport(reportData: RestartCreateReportInput!): RestartCreateReport
  createGrievanceTicket(input: CreateGrievanceTicketInput!): CreateGrievanceTicketMutation
  updateGrievanceTicket(input: UpdateGrievanceTicketInput!, version: BigInt): UpdateGrievanceTicketMutation
  grievanceStatusChange(grievanceTicketId: ID, status: Int, version: BigInt): GrievanceStatusChangeMutation
  createTicketNote(noteInput: CreateTicketNoteInput!, version: BigInt): CreateTicketNoteMutation
  approveIndividualDataChange(approvedDocumentsToCreate: [Int], approvedDocumentsToEdit: [Int], approvedDocumentsToRemove: [Int], approvedIdentitiesToCreate: [Int], approvedIdentitiesToEdit: [Int], approvedIdentitiesToRemove: [Int], approvedPaymentChannelsToCreate: [Int], approvedPaymentChannelsToEdit: [Int], approvedPaymentChannelsToRemove: [Int], flexFieldsApproveData: JSONString, grievanceTicketId: ID!, individualApproveData: JSONString, version: BigInt): IndividualDataChangeApproveMutation
  approveHouseholdDataChange(flexFieldsApproveData: JSONString, grievanceTicketId: ID!, householdApproveData: JSONString, version: BigInt): HouseholdDataChangeApproveMutation
  approveAddIndividual(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveDeleteIndividual(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveDeleteHousehold(approveStatus: Boolean!, grievanceTicketId: ID!, reasonHhId: String, version: BigInt): DeleteHouseholdApproveMutation
  approveSystemFlagging(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveNeedsAdjudication(clearIndividualIds: [ID], distinctIndividualIds: [ID], duplicateIndividualIds: [ID], grievanceTicketId: ID!, selectedIndividualId: ID, version: BigInt): NeedsAdjudicationApproveMutation
  approvePaymentDetails(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): PaymentDetailsApproveMutation
  reassignRole(grievanceTicketId: ID!, householdId: ID!, householdVersion: BigInt, individualId: ID!, individualVersion: BigInt, newIndividualId: ID, role: String!, version: BigInt): ReassignRoleMutation
  bulkUpdateGrievanceAssignee(assignedTo: String!, businessAreaSlug: String!, grievanceTicketIds: [ID]!): BulkUpdateGrievanceTicketsAssigneesMutation
  bulkUpdateGrievancePriority(businessAreaSlug: String!, grievanceTicketIds: [ID]!, priority: Int!): BulkUpdateGrievanceTicketsPriorityMutation
  bulkUpdateGrievanceUrgency(businessAreaSlug: String!, grievanceTicketIds: [ID]!, urgency: Int!): BulkUpdateGrievanceTicketsUrgencyMutation
  bulkGrievanceAddNote(businessAreaSlug: String!, grievanceTicketIds: [ID]!, note: String!): BulkGrievanceAddNoteMutation
  createPaymentVerificationPlan(input: CreatePaymentVerificationInput!, version: BigInt): CreateVerificationPlanMutation
  editPaymentVerificationPlan(input: EditPaymentVerificationInput!, version: BigInt): EditPaymentVerificationMutation
  exportXlsxPaymentVerificationPlanFile(paymentVerificationPlanId: ID!): ExportXlsxPaymentVerificationPlanFile
  importXlsxPaymentVerificationPlanFile(file: Upload!, paymentVerificationPlanId: ID!): ImportXlsxPaymentVerificationPlanFile
  activatePaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): ActivatePaymentVerificationPlan
  finishPaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): FinishPaymentVerificationPlan
  discardPaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): DiscardPaymentVerificationPlan
  invalidPaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): InvalidPaymentVerificationPlan
  deletePaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): DeletePaymentVerificationPlan
  markPaymentAsFailed(paymentId: ID!): MarkPaymentAsFailedMutation
  revertMarkPaymentAsFailed(deliveredQuantity: Decimal!, deliveryDate: Date!, paymentId: ID!): RevertMarkPaymentAsFailedMutation
  updatePaymentVerificationStatusAndReceivedAmount(paymentVerificationId: ID!, receivedAmount: Decimal!, status: PaymentVerificationStatusForUpdate, version: BigInt): UpdatePaymentVerificationStatusAndReceivedAmount
  updatePaymentVerificationReceivedAndReceivedAmount(paymentVerificationId: ID!, received: Boolean!, receivedAmount: Decimal!, version: BigInt): UpdatePaymentVerificationReceivedAndReceivedAmount
  actionPaymentPlanMutation(input: ActionPaymentPlanInput!, version: BigInt): ActionPaymentPlanMutation
  createPaymentPlan(input: CreatePaymentPlanInput!): CreatePaymentPlanMutation
  openPaymentPlan(input: OpenPaymentPlanInput!, version: BigInt): OpenPaymentPlanMutation
  createFollowUpPaymentPlan(dispersionEndDate: Date!, dispersionStartDate: Date!, paymentPlanId: ID!): CreateFollowUpPaymentPlanMutation
  updatePaymentPlan(input: UpdatePaymentPlanInput!, version: BigInt): UpdatePaymentPlanMutation
  deletePaymentPlan(paymentPlanId: ID!): DeletePaymentPlanMutation
  splitPaymentPlan(paymentPlanId: ID!, paymentsNo: Int, splitType: String!): SplitPaymentPlanMutation
  excludeHouseholds(excludedHouseholdsIds: [String]!, exclusionReason: String, paymentPlanId: ID!): ExcludeHouseholdsMutation
  setSteficonRuleOnPaymentPlanPaymentList(paymentPlanId: ID!, steficonRuleId: ID!, version: BigInt): SetSteficonRuleOnPaymentPlanPaymentListMutation
  copyTargetingCriteria(name: String!, paymentPlanId: ID!, programCycleId: ID!): CopyTargetingCriteriaMutation
  assignFundsCommitments(fundCommitmentItemsIds: [String], paymentPlanId: ID!): AssignFundsCommitmentsMutation
  exportXlsxPaymentPlanPaymentList(fspXlsxTemplateId: ID, paymentPlanId: ID!): ExportXLSXPaymentPlanPaymentListMutation
  exportXlsxPaymentPlanPaymentListPerFsp(fspXlsxTemplateId: ID, paymentPlanId: ID!): ExportXLSXPaymentPlanPaymentListPerFSPMutation
  importXlsxPaymentPlanPaymentList(file: Upload!, paymentPlanId: ID!): ImportXLSXPaymentPlanPaymentListMutation
  importXlsxPaymentPlanPaymentListPerFsp(file: Upload!, paymentPlanId: ID!): ImportXLSXPaymentPlanPaymentListPerFSPMutation
  exportPdfPaymentPlanSummary(paymentPlanId: ID!): ExportPDFPaymentPlanSummaryMutation
  createProgram(programData: CreateProgramInput!): CreateProgram
  updateProgram(programData: UpdateProgramInput, version: BigInt): UpdateProgram
  updateProgramPartners(programData: UpdateProgramPartnersInput, version: BigInt): UpdateProgramPartners
  deleteProgram(programId: String!): DeleteProgram
  copyProgram(programData: CopyProgramInput!): CopyProgram
  uploadImportDataXlsxFileAsync(businessAreaSlug: String!, file: Upload!): UploadImportDataXLSXFileAsync
  deleteRegistrationDataImport(registrationDataImportId: String!): DeleteRegistrationDataImport
  registrationXlsxImport(registrationDataImportData: RegistrationXlsxImportMutationInput!): RegistrationXlsxImportMutation
  registrationProgramPopulationImport(registrationDataImportData: RegistrationProgramPopulationImportMutationInput!): RegistrationProgramPopulationImportMutation
  registrationKoboImport(registrationDataImportData: RegistrationKoboImportMutationInput!): RegistrationKoboImportMutation
  saveKoboImportDataAsync(businessAreaSlug: String!, onlyActiveSubmissions: Boolean!, pullPictures: Boolean!, uid: Upload!): SaveKoboProjectImportDataAsync
  mergeRegistrationDataImport(id: ID!, version: BigInt): MergeRegistrationDataImportMutation
  refuseRegistrationDataImport(id: ID!, refuseReason: String, version: BigInt): RefuseRegistrationDataImportMutation
  rerunDedupe(registrationDataImportId: ID!, version: BigInt): RegistrationDeduplicationMutation
  eraseRegistrationDataImport(id: ID!, version: BigInt): EraseRegistrationDataImportMutation
  checkAgainstSanctionList(file: Upload!): CheckAgainstSanctionListMutation
}

type NeedsAdjudicationApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input NegativeFeedbackTicketExtras {
  household: ID
  individual: ID
}

interface Node {
  id: ID!
}

input OpenPaymentPlanInput {
  paymentPlanId: ID!
  dispersionStartDate: Date!
  dispersionEndDate: Date!
  currency: String!
}

type OpenPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

input PDUFieldInput {
  id: String
  label: String
  pduData: PeriodicFieldDataInput
}

type PDUSubtypeChoiceObject {
  value: String
  displayName: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PartnerNode {
  id: ID!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  name: String
  parent: PartnerNode
  isUn: Boolean!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  partnerSet: [PartnerNode!]!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserNodeConnection!
  individualIdentities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  areas: [AreaNode]
  areaAccess: String
}

type PartnerRoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  partner: PartnerNode!
  roles: [RoleNode!]!
}

type PartnerType {
  id: ID!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  name: String!
  parent: PartnerNode
  isUn: Boolean!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  partnerSet: [PartnerNode!]!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserNodeConnection!
  individualIdentities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

type PaymentConflictDataNode {
  paymentPlanId: String
  paymentPlanUnicefId: String
  paymentPlanStartDate: String
  paymentPlanEndDate: String
  paymentPlanStatus: String
  paymentId: String
  paymentUnicefId: String
}

type PaymentDetailsApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type PaymentHouseholdSnapshotNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  snapshotData: JSONString!
  householdId: UUID!
  payment: PaymentNode!
}

type PaymentNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  signatureHash: String!
  internalData: JSONString!
  parent: PaymentPlanNode!
  businessArea: UserBusinessAreaNode!
  program: ProgramNode
  household: HouseholdNode!
  headOfHousehold: IndividualNode
  deliveryType: DeliveryMechanismNode
  financialServiceProvider: FinancialServiceProviderNode
  collector: IndividualNode!
  sourcePayment: PaymentNode
  isFollowUp: Boolean!
  status: PaymentStatus!
  statusDate: DateTime!
  currency: String
  entitlementQuantity: Float
  entitlementQuantityUsd: Float
  entitlementDate: DateTime
  deliveredQuantity: Float
  deliveredQuantityUsd: Float
  deliveryDate: DateTime
  transactionReferenceId: String
  transactionStatusBlockchainLink: String
  conflicted: Boolean!
  excluded: Boolean!
  hasValidWallet: Boolean!
  reasonForUnsuccessfulPayment: String
  orderNumber: Int
  tokenNumber: Int
  additionalCollectorName: String
  additionalDocumentType: String
  additionalDocumentNumber: String
  fspAuthCode: String
  vulnerabilityScore: Float
  isCashAssist: Boolean!
  followUps(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  householdSnapshot: PaymentHouseholdSnapshotNode
  paymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  ticketComplaintDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  ticketSensitiveDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  adminUrl: String
  paymentPlanHardConflicted: Boolean
  paymentPlanHardConflictedData: [PaymentConflictDataNode]
  paymentPlanSoftConflicted: Boolean
  paymentPlanSoftConflictedData: [PaymentConflictDataNode]
  fullName: String
  verification: PaymentVerificationNode
  distributionModality: String
  serviceProvider: FinancialServiceProviderNode
  totalPersonsCovered: Int
  snapshotCollectorFullName: String
  snapshotCollectorAccountData: JSONString
}

type PaymentNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentNodeEdge {
  node: PaymentNode
  cursor: String!
}

enum PaymentPlanBackgroundActionStatus {
  RULE_ENGINE_RUN
  RULE_ENGINE_ERROR
  XLSX_EXPORTING
  XLSX_EXPORT_ERROR
  XLSX_IMPORT_ERROR
  XLSX_IMPORTING_ENTITLEMENTS
  XLSX_IMPORTING_RECONCILIATION
  EXCLUDE_BENEFICIARIES
  EXCLUDE_BENEFICIARIES_ERROR
  SEND_TO_PAYMENT_GATEWAY
  SEND_TO_PAYMENT_GATEWAY_ERROR
}

enum PaymentPlanBuildStatus {
  PENDING
  BUILDING
  FAILED
  OK
}

enum PaymentPlanCurrency {
  A_
  AED
  AFN
  ALL
  AMD
  ANG
  AOA
  ARS
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BHD
  BIF
  BMD
  BND
  BOB
  BOV
  BRL
  BSD
  BTN
  BWP
  BYN
  BZD
  CAD
  CDF
  CHF
  CLP
  CNY
  COP
  CRC
  CUC
  CUP
  CVE
  CZK
  DJF
  DKK
  DOP
  DZD
  EGP
  ERN
  ETB
  EUR
  FJD
  FKP
  GBP
  GEL
  GHS
  GIP
  GMD
  GNF
  GTQ
  GYD
  HKD
  HNL
  HRK
  HTG
  HUF
  IDR
  ILS
  INR
  IQD
  IRR
  ISK
  JMD
  JOD
  JPY
  KES
  KGS
  KHR
  KMF
  KPW
  KRW
  KWD
  KYD
  KZT
  LAK
  LBP
  LKR
  LRD
  LSL
  LYD
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRU
  MUR
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NIO
  NOK
  NPR
  NZD
  OMR
  PAB
  PEN
  PGK
  PHP
  PKR
  PLN
  PYG
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SDG
  SEK
  SGD
  SHP
  SLE
  SOS
  SRD
  SSP
  STN
  SVC
  SYP
  SZL
  THB
  TJS
  TMT
  TND
  TOP
  TRY
  TTD
  TWD
  TZS
  UAH
  UGX
  USD
  UYU
  UYW
  UZS
  VES
  VND
  VUV
  WST
  XAF
  XAG
  XAU
  XCD
  XOF
  XPF
  YER
  ZAR
  ZMW
  ZWL
  USDC
}

type PaymentPlanNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  internalData: JSONString!
  businessArea: UserBusinessAreaNode!
  programCycle: ProgramCycleNode!
  deliveryMechanism: DeliveryMechanismNode
  financialServiceProvider: FinancialServiceProviderNode
  steficonRule: RuleCommitNode
  steficonRuleTargeting: RuleCommitNode
  createdBy: UserNode!
  targetingCriteria: TargetingCriteriaNode!
  sourcePaymentPlan: PaymentPlanNode
  name: String
  startDate: Date
  endDate: Date
  currency: String
  dispersionStartDate: Date
  dispersionEndDate: Date
  excludedIds: String
  exclusionReason: String
  vulnerabilityScoreMin: Float
  vulnerabilityScoreMax: Float
  status: PaymentPlanStatus!
  backgroundActionStatus: PaymentPlanBackgroundActionStatus
  buildStatus: PaymentPlanBuildStatus
  builtAt: DateTime
  exchangeRate: Float
  femaleChildrenCount: Int!
  maleChildrenCount: Int!
  femaleAdultsCount: Int!
  maleAdultsCount: Int!
  totalHouseholdsCount: Int!
  totalIndividualsCount: Int!
  importedFileDate: DateTime
  totalEntitledQuantity: Float
  totalEntitledQuantityUsd: Float
  totalEntitledQuantityRevised: Float
  totalEntitledQuantityRevisedUsd: Float
  totalDeliveredQuantity: Float
  totalDeliveredQuantityUsd: Float
  totalUndeliveredQuantity: Float
  totalUndeliveredQuantityUsd: Float
  steficonTargetingAppliedDate: DateTime
  steficonAppliedDate: DateTime
  isFollowUp: Boolean!
  excludeHouseholdError: String
  statusDate: DateTime!
  isCashAssist: Boolean!
  approvalProcess(offset: Int, before: String, after: String, first: Int, last: Int): ApprovalProcessNodeConnection!
  followUps(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  paymentItems(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanSupportingDocumentNodeConnection!
  paymentVerificationPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationPlanNodeConnection!
  paymentVerificationSummary: PaymentVerificationSummaryNode
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  fundsCommitments: FundsCommitmentNode
  adminUrl: String
  currencyName: String
  hasPaymentListExportFile: Boolean
  hasFspDeliveryMechanismXlsxTemplate: Boolean
  importedFileName: String
  paymentsConflictsCount: Int
  volumeByDeliveryMechanism: [VolumeByDeliveryMechanismNode]
  splitChoices: [ChoiceObject]
  verificationPlans(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
  canCreatePaymentVerificationPlan: Boolean
  availablePaymentRecordsCount: Int
  reconciliationSummary: ReconciliationSummaryNode
  excludedHouseholds: [HouseholdNode]
  excludedIndividuals: [IndividualNode]
  canCreateFollowUp: Boolean
  totalWithdrawnHouseholdsCount: Int
  unsuccessfulPaymentsCount: Int
  canSendToPaymentGateway: Boolean
  canSplit: Boolean
  supportingDocuments: [PaymentPlanSupportingDocumentNode]
  program: ProgramNode
  totalHouseholdsCountWithValidPhoneNo: Int
  canCreateXlsxWithFspAuthCode: Boolean
  fspCommunicationChannel: String
  canExportXlsx: Boolean
  canDownloadXlsx: Boolean
  canSendXlsxPassword: Boolean
  failedWalletValidationCollectorsIds: [String]
  availableFundsCommitments: [FundsCommitmentNode]
}

type PaymentPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentPlanNodeEdge {
  node: PaymentPlanNode
  cursor: String!
}

enum PaymentPlanStatus {
  TP_OPEN
  TP_LOCKED
  PROCESSING
  STEFICON_WAIT
  STEFICON_RUN
  STEFICON_COMPLETED
  STEFICON_ERROR
  DRAFT
  PREPARING
  OPEN
  LOCKED
  LOCKED_FSP
  IN_APPROVAL
  IN_AUTHORIZATION
  IN_REVIEW
  ACCEPTED
  FINISHED
}

type PaymentPlanSupportingDocumentNode implements Node {
  id: ID!
  title: String!
  paymentPlan: PaymentPlanNode!
  file: String!
  uploadedAt: DateTime!
  createdBy: UserNode
}

type PaymentPlanSupportingDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentPlanSupportingDocumentNodeEdge]!
}

type PaymentPlanSupportingDocumentNodeEdge {
  node: PaymentPlanSupportingDocumentNode
  cursor: String!
}

enum PaymentStatus {
  DISTRIBUTION_SUCCESSFUL
  NOT_DISTRIBUTED
  TRANSACTION_SUCCESSFUL
  TRANSACTION_ERRONEOUS
  FORCE_FAILED
  PARTIALLY_DISTRIBUTED
  PENDING
  SENT_TO_PAYMENT_GATEWAY
  SENT_TO_FSP
  MANUALLY_CANCELLED
}

type PaymentVerificationLogEntryNode implements Node {
  id: ID!
  contentType: ContentTypeObjectType
  objectId: UUID
  action: LogEntryAction!
  objectRepr: String!
  changes: Arg
  user: UserNode
  businessArea: UserBusinessAreaNode
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  timestamp: DateTime
  isUserGenerated: Boolean
  contentObject: PaymentVerificationPlanNode
}

type PaymentVerificationLogEntryNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationLogEntryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationLogEntryNodeEdge {
  node: PaymentVerificationLogEntryNode
  cursor: String!
}

type PaymentVerificationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  payment: GenericPaymentNode
  paymentVerificationPlan: PaymentVerificationPlanNode!
  status: PaymentVerificationStatus!
  statusDate: DateTime
  receivedAmount: Float
  sentToRapidPro: Boolean!
  ticketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPaymentVerificationDetailsNodeConnection!
  ticketDetail(offset: Int, before: String, after: String, first: Int, last: Int): TicketPaymentVerificationDetailsNodeConnection!
  adminUrl: String
  isManuallyEditable: Boolean
}

type PaymentVerificationNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationNodeEdge {
  node: PaymentVerificationNode
  cursor: String!
}

type PaymentVerificationPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  paymentPlan: PaymentPlanNode
  status: PaymentVerificationPlanStatus!
  verificationChannel: PaymentVerificationPlanVerificationChannel!
  sampling: PaymentVerificationPlanSampling!
  sexFilter: String
  activationDate: DateTime
  completionDate: DateTime
  sampleSize: Int
  respondedCount: Int
  receivedCount: Int
  notReceivedCount: Int
  receivedWithProblemsCount: Int
  confidenceInterval: Float
  marginOfError: Float
  rapidProFlowId: String!
  rapidProFlowStartUuids: [String!]!
  xlsxFileExporting: Boolean!
  xlsxFileImported: Boolean!
  error: String
  ageFilter: AgeFilterObject
  excludedAdminAreasFilter: [String]
  paymentRecordVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  adminUrl: String
  xlsxFileWasDownloaded: Boolean
  hasXlsxFile: Boolean
}

type PaymentVerificationPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationPlanNodeEdge {
  node: PaymentVerificationPlanNode
  cursor: String!
}

enum PaymentVerificationPlanSampling {
  FULL_LIST
  RANDOM
}

enum PaymentVerificationPlanStatus {
  ACTIVE
  FINISHED
  PENDING
  INVALID
  RAPID_PRO_ERROR
}

enum PaymentVerificationPlanVerificationChannel {
  MANUAL
  RAPIDPRO
  XLSX
}

enum PaymentVerificationStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

enum PaymentVerificationStatusForUpdate {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type PaymentVerificationSummaryNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: PaymentVerificationSummaryStatus!
  activationDate: DateTime
  completionDate: DateTime
  paymentPlan: PaymentPlanNode
}

enum PaymentVerificationSummaryStatus {
  ACTIVE
  FINISHED
  PENDING
}

input PeriodicFieldDataInput {
  subtype: String
  numberOfRounds: Int
  roundsNames: [String]
}

type PeriodicFieldDataNode {
  id: ID!
  subtype: PeriodicFieldDataSubtype!
  roundsNames: [String!]!
  numberOfRounds: Int!
}

enum PeriodicFieldDataSubtype {
  DATE
  DECIMAL
  STRING
  BOOL
}

type PeriodicFieldNode implements Node {
  name: String!
  pduData: PeriodicFieldDataNode
  label: JSONString!
  id: ID!
}

input PositiveFeedbackTicketExtras {
  household: ID
  individual: ID
}

enum ProgramCollisionDetector {
  HCT_MIS_API_APPS_PROGRAM_COLLISION_DETECTORS_IDENTIFICATIONKEYCOLLISIONDETECTOR
}

type ProgramCycleNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  title: String
  program: ProgramNode!
  status: ProgramCycleStatus!
  startDate: Date!
  endDate: Date
  createdBy: UserNode
  paymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  totalDeliveredQuantityUsd: Float
  totalEntitledQuantityUsd: Float
  totalUndeliveredQuantityUsd: Float
}

type ProgramCycleNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramCycleNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramCycleNodeEdge {
  node: ProgramCycleNode
  cursor: String!
}

enum ProgramCycleStatus {
  DRAFT
  ACTIVE
  FINISHED
}

enum ProgramFrequencyOfPayments {
  ONE_OFF
  REGULAR
}

type ProgramNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  version: BigInt!
  dataCollectingType: DataCollectingTypeNode
  beneficiaryGroup: BeneficiaryGroupNode
  businessArea: UserBusinessAreaNode!
  partners: [PartnerNode]
  adminAreas(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  name: String!
  programmeCode: String
  status: ProgramStatus!
  description: String!
  startDate: Date!
  endDate: Date
  sector: ProgramSector!
  budget: Decimal
  frequencyOfPayments: ProgramFrequencyOfPayments!
  scope: ProgramScope
  partnerAccess: ProgramPartnerAccess!
  cashPlus: Boolean!
  populationGoal: Int!
  administrativeAreasOfImplementation: String!
  biometricDeduplicationEnabled: Boolean!
  collisionDetectionEnabled: Boolean!
  collisionDetector: ProgramCollisionDetector
  isVisible: Boolean!
  householdCount: Int!
  individualCount: Int!
  deduplicationSetId: UUID
  pduFields: [PeriodicFieldNode]
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  registrationImports(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  grievanceTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  cycles(offset: Int, before: String, after: String, first: Int, last: Int, search: String, status: [String], startDate: Date, endDate: Date, totalDeliveredQuantityUsdFrom: Float, totalDeliveredQuantityUsdTo: Float, orderBy: String): ProgramCycleNodeConnection
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  activityLogs(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  adminUrl: String
  totalEntitledQuantity: Decimal
  totalDeliveredQuantity: Decimal
  totalUndeliveredQuantity: Decimal
  totalNumberOfHouseholds: Int
  totalNumberOfHouseholdsWithTpInProgram: Int
  isSocialWorkerProgram: Boolean
  targetPopulationsCount: Int
  canFinish: Boolean
}

type ProgramNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramNodeEdge {
  node: ProgramNode
  cursor: String!
}

enum ProgramPartnerAccess {
  ALL_PARTNERS_ACCESS
  NONE_PARTNERS_ACCESS
  SELECTED_PARTNERS_ACCESS
}

input ProgramPartnerThroughInput {
  partner: String
  areas: [String]
  areaAccess: String
}

enum ProgramScope {
  FOR_PARTNERS
  UNICEF
}

enum ProgramSector {
  CHILD_PROTECTION
  EDUCATION
  HEALTH
  MULTI_PURPOSE
  NUTRITION
  SOCIAL_POLICY
  WASH
}

enum ProgramStatus {
  ACTIVE
  DRAFT
  FINISHED
}

type Query {
  accountabilityCommunicationMessage(id: ID!): CommunicationMessageNode
  allAccountabilityCommunicationMessages(offset: Int, before: String, after: String, first: Int, last: Int, numberOfRecipients: Int, numberOfRecipients_Gte: Int, numberOfRecipients_Lte: Int, paymentPlan: ID, createdBy: ID, program: String, createdAtRange: String, title: String, body: String, samplingType: String, orderBy: String): CommunicationMessageNodeConnection
  allAccountabilityCommunicationMessageRecipients(offset: Int, before: String, after: String, first: Int, last: Int, messageId: String!, recipientId: String, fullName: String, phoneNo: String, sex: String, orderBy: String): CommunicationMessageRecipientMapNodeConnection
  accountabilityCommunicationMessageSampleSize(input: GetAccountabilityCommunicationMessageSampleSizeInput): GetCommunicationMessageSampleSizeNode
  feedback(id: ID!): FeedbackNode
  allFeedbacks(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, issueType: String, createdAtRange: String, createdBy: String, feedbackId: String, isActiveProgram: String, program: String, orderBy: String): FeedbackNodeConnection
  feedbackIssueTypeChoices: [ChoiceObject]
  survey(id: ID!): SurveyNode
  allSurveys(offset: Int, before: String, after: String, first: Int, last: Int, program: ID, paymentPlan: ID, businessArea: String, createdAtRange: String, search: String, createdBy: String, orderBy: String): SurveyNodeConnection
  recipients(offset: Int, before: String, after: String, first: Int, last: Int, survey: String!, orderBy: String): RecipientNodeConnection
  accountabilitySampleSize(input: AccountabilitySampleSizeInput): AccountabilitySampleSizeNode
  surveyCategoryChoices: [ChoiceObject]
  surveyAvailableFlows: [RapidProFlowNode]
  adminArea(id: ID!): AreaNode
  allAdminAreas(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Istartswith: String, businessArea: String, level: Int, parentId: String): AreaNodeConnection
  allAreasTree(businessArea: String!): [AreaTreeNode]
  allLogEntries(offset: Int, before: String, after: String, first: Int, last: Int, objectId: UUID, user: ID, businessArea: String!, search: String, module: String, userId: String, programId: String): LogEntryNodeConnection
  logEntryActionChoices: [ChoiceObject]
  report(id: ID!): ReportNode
  allReports(offset: Int, before: String, after: String, first: Int, last: Int, createdBy: ID, reportType: [String], status: [String], businessArea: String!, createdFrom: DateTime, createdTo: DateTime, orderBy: String): ReportNodeConnection
  reportTypesChoices: [ChoiceObject]
  reportStatusChoices: [ChoiceObject]
  dashboardReportTypesChoices(businessAreaSlug: String!): [ChoiceObject]
  dashboardYearsChoices(businessAreaSlug: String!): [String]
  sanctionListIndividual(id: ID!): SanctionListIndividualNode
  allSanctionListIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, fullName: String, fullName_Startswith: String, referenceNumber: String, orderBy: String): SanctionListIndividualNodeConnection
  ticketsByType(businessAreaSlug: String!): TicketByType
  ticketsByCategory(businessAreaSlug: String!): ChartDatasetNode
  ticketsByStatus(businessAreaSlug: String!): ChartDatasetNode
  ticketsByLocationAndCategory(businessAreaSlug: String!): ChartDetailedDatasetsNode
  grievanceTicket(id: ID!): GrievanceTicketNode
  allGrievanceTicket(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, id_Startswith: UUID, category: String, area: String, area_Startswith: String, assignedTo: ID, registrationDataImport: ID, admin2: ID, createdBy: ID, businessArea: String!, search: String, documentType: String, documentNumber: String, status: [String], fsp: String, cashPlan: String, createdAtRange: String, permissions: [String], issueType: String, scoreMin: String, scoreMax: String, household: String, preferredLanguage: String, priority: String, urgency: String, grievanceType: String, grievanceStatus: String, totalDays: Int, program: String, isActiveProgram: Boolean, isCrossArea: Boolean, admin1: ID, orderBy: String): GrievanceTicketNodeConnection
  crossAreaFilterAvailable: Boolean
  existingGrievanceTickets(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, businessArea: String!, category: String, issueType: String, household: ID, individual: ID, paymentRecord: [ID], permissions: [String], orderBy: String): GrievanceTicketNodeConnection
  allTicketNotes(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, ticket: UUID!): TicketNoteNodeConnection
  chartGrievances(businessAreaSlug: String!, year: Int!, administrativeArea: String): ChartGrievanceTicketsNode
  allAddIndividualsFieldsAttributes: [FieldAttributeNode]
  allEditHouseholdFieldsAttributes: [FieldAttributeNode]
  allEditPeopleFieldsAttributes: [FieldAttributeNode]
  grievanceTicketStatusChoices: [ChoiceObject]
  grievanceTicketCategoryChoices: [ChoiceObject]
  grievanceTicketManualCategoryChoices: [ChoiceObject]
  grievanceTicketSystemCategoryChoices: [ChoiceObject]
  grievanceTicketIssueTypeChoices: [IssueTypesObject]
  grievanceTicketPriorityChoices: [ChoiceObjectInt]
  grievanceTicketUrgencyChoices: [ChoiceObjectInt]
  allSteficonRules(offset: Int, before: String, after: String, first: Int, last: Int, enabled: Boolean, deprecated: Boolean, type: String!): SteficonRuleNodeConnection
  payment(id: ID!): PaymentNode
  allPayments(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, paymentPlanId: String, programId: String, householdId: String, orderBy: String): PaymentNodeConnection
  financialServiceProviderXlsxTemplate(id: ID!): FinancialServiceProviderXlsxTemplateNode
  allFinancialServiceProviderXlsxTemplates(offset: Int, before: String, after: String, first: Int, last: Int, financialServiceProviders: [ID], name: String, createdBy: ID, businessArea: String!, orderBy: String): FinancialServiceProviderXlsxTemplateNodeConnection
  financialServiceProvider(id: ID!): FinancialServiceProviderNode
  allFinancialServiceProviders(offset: Int, before: String, after: String, first: Int, last: Int, createdBy: ID, name: String, visionVendorNumber: String, deliveryMechanisms: [String], distributionLimit: Float, communicationChannel: String, xlsxTemplates: [ID], orderBy: String): FinancialServiceProviderNodeConnection
  paymentRecordVerification(id: ID!): PaymentVerificationNode
  allPaymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int, paymentVerificationPlan: ID, status: String, paymentPlanId: String, search: String, businessArea: String!, verificationChannel: String, orderBy: String): PaymentVerificationNodeConnection
  paymentVerificationPlan(id: ID!): PaymentVerificationPlanNode
  allPaymentVerificationPlan(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  chartPaymentVerification(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartPaymentVerification
  chartPaymentVerificationForPeople(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartPaymentVerification
  chartVolumeByDeliveryMechanism(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartPayment(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  sectionTotalTransferred(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  tableTotalCashTransferredByAdministrativeArea(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String, order: String, orderBy: String): TableTotalCashTransferred
  tableTotalCashTransferredByAdministrativeAreaForPeople(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String, order: String, orderBy: String): TableTotalCashTransferredForPeople
  chartTotalTransferredCashByCountry(year: Int!): ChartDetailedDatasetsNode
  paymentRecordStatusChoices: [ChoiceObject]
  paymentRecordEntitlementCardStatusChoices: [ChoiceObject]
  paymentRecordDeliveryTypeChoices: [ChoiceObject]
  cashPlanVerificationStatusChoices: [ChoiceObject]
  cashPlanVerificationSamplingChoices: [ChoiceObject]
  cashPlanVerificationVerificationChannelChoices: [ChoiceObject]
  paymentVerificationStatusChoices: [ChoiceObject]
  allRapidProFlows(businessAreaSlug: String!): [RapidProFlow]
  sampleSize(input: GetCashplanVerificationSampleSizeInput): GetCashplanVerificationSampleSizeObject
  allPaymentVerificationLogEntries(offset: Int, before: String, after: String, first: Int, last: Int, objectId: UUID, user: ID, businessArea: String!, search: String, module: String, userId: String, programId: String): PaymentVerificationLogEntryNodeConnection
  paymentPlan(id: ID!): PaymentPlanNode
  allPaymentPlans(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], statusNot: String, verificationStatus: [String], totalEntitledQuantityFrom: Float, totalEntitledQuantityTo: Float, dispersionStartDate: Date, dispersionEndDate: Date, startDate: Date, endDate: Date, isFollowUp: Boolean, isPaymentPlan: Boolean, isTargetPopulation: Boolean, sourcePaymentPlanId: String, program: String, programCycle: String, name: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, createdAtRange: String, serviceProvider: String, deliveryTypes: [String], orderBy: String): PaymentPlanNodeConnection
  paymentPlanStatusChoices: [ChoiceObject]
  currencyChoices: [ChoiceObject]
  paymentPlanBackgroundActionStatusChoices: [ChoiceObject]
  availableFspsForDeliveryMechanisms: [FspChoices]
  businessArea(businessAreaSlug: String!): BusinessAreaNode
  allBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, slug: String): BusinessAreaNodeConnection
  allFieldsAttributes(flexField: Boolean, businessAreaSlug: String, programId: String): [FieldAttributeNode]
  allCollectorFieldsAttributes(flexField: Boolean): [FieldAttributeNode]
  allPduFields(businessAreaSlug: String!, programId: String!): [FieldAttributeNode]
  allGroupsWithFields: [GroupAttributeNode]
  koboProject(uid: String!, businessAreaSlug: String!): KoboAssetObject
  allKoboProjects(businessAreaSlug: String!, onlyDeployed: Boolean, before: String, after: String, first: Int, last: Int): KoboAssetObjectConnection
  cashAssistUrlPrefix: String
  allLanguages(code: String, before: String, after: String, first: Int, last: Int): LanguageObjectConnection
  dataCollectingType(id: ID!): DataCollectingTypeNode
  dataCollectionTypeChoices: [DataCollectingTypeChoiceObject]
  pduSubtypeChoices: [PDUSubtypeChoiceObject]
  program(id: ID!): ProgramNode
  allPrograms(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], sector: [String], numberOfHouseholds: String, budget: String, startDate: Date, endDate: Date, name: String, beneficiaryGroupMatch: Boolean, numberOfHouseholdsWithTpInProgram: String, dataCollectingType: String, compatibleDct: Boolean, orderBy: String): ProgramNodeConnection
  chartProgrammesBySector(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  chartTotalTransferredByMonth(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  programStatusChoices: [ChoiceObject]
  programCycleStatusChoices: [ChoiceObject]
  programFrequencyOfPaymentsChoices: [ChoiceObject]
  programSectorChoices: [ChoiceObject]
  programScopeChoices: [ChoiceObject]
  cashPlanStatusChoices: [ChoiceObject]
  dataCollectingTypeChoices: [ChoiceObject]
  allActivePrograms(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], sector: [String], numberOfHouseholds: String, budget: String, startDate: Date, endDate: Date, name: String, beneficiaryGroupMatch: Boolean, numberOfHouseholdsWithTpInProgram: String, dataCollectingType: String, compatibleDct: Boolean, orderBy: String): ProgramNodeConnection
  programCycle(id: ID!): ProgramCycleNode
  canRunDeduplication: Boolean
  isDeduplicationDisabled: Boolean
  household(id: ID!): HouseholdNode
  allHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, address: String, address_Startswith: String, headOfHousehold_FullName: String, headOfHousehold_FullName_Startswith: String, size_Range: [Int], size_Lte: Int, size_Gte: Int, adminArea: ID, admin1: ID, admin2: ID, residenceStatus: String, withdrawn: Boolean, program: ID, firstRegistrationDate: DateTime, rdiId: String, size: String, search: String, documentType: String, documentNumber: String, headOfHousehold_PhoneNoValid: Boolean, lastRegistrationDate: String, countryOrigin: String, isActiveProgram: Boolean, rdiMergeStatus: String, orderBy: String): HouseholdNodeConnection
  individual(id: ID!): IndividualNode
  allIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household_Id: UUID, businessArea: String, fullName: String, fullName_Startswith: String, fullName_Endswith: String, sex: [String], household_AdminArea: ID, withdrawn: Boolean, program: ID, age: String, programs: [ID], search: String, documentType: String, documentNumber: String, lastRegistrationDate: String, admin1: [ID], admin2: [ID], status: [String], excludedId: String, flags: [String], isActiveProgram: Boolean, rdiId: String, duplicatesOnly: Boolean, rdiMergeStatus: String, orderBy: String): IndividualNodeConnection
  allMergedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, rdiId: String, orderBy: String): HouseholdNodeConnection
  allMergedIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household: ID, rdiId: String, duplicatesOnly: Boolean, businessArea: String, orderBy: String): IndividualNodeConnection
  sectionHouseholdsReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionIndividualsReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionPeopleReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionChildReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  chartIndividualsReachedByAgeAndGender(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartPeopleReachedByAgeAndGender(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartIndividualsWithDisabilityReachedByAge(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  chartPeopleWithDisabilityReachedByAge(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  residenceStatusChoices: [ChoiceObject]
  sexChoices: [ChoiceObject]
  maritalStatusChoices: [ChoiceObject]
  workStatusChoices: [ChoiceObject]
  relationshipChoices: [ChoiceObject]
  roleChoices: [ChoiceObject]
  documentTypeChoices: [ChoiceObject]
  identityTypeChoices: [ChoiceObject]
  countriesChoices: [ChoiceObject]
  observedDisabilityChoices: [ChoiceObject]
  severityOfDisabilityChoices: [ChoiceObject]
  flagChoices: [ChoiceObject]
  allHouseholdsFlexFieldsAttributes: [FieldAttributeNode]
  allIndividualsFlexFieldsAttributes: [FieldAttributeNode]
  me: UserNode
  allUsers(offset: Int, before: String, after: String, first: Int, last: Int, status: [String], partner: [String], businessArea: String!, program: String, search: String, roles: [String], isTicketCreator: Boolean, isSurveyCreator: Boolean, isMessageCreator: Boolean, isFeedbackCreator: Boolean, orderBy: String): UserNodeConnection
  userRolesChoices: [RoleChoiceObject]
  userStatusChoices: [ChoiceObject]
  userPartnerChoices: [ChoiceObject]
  partnerForGrievanceChoices(householdId: ID, individualId: ID): [ChoiceObject]
  hasAvailableUsersToExport(businessAreaSlug: String!): Boolean
  registrationDataImportDatahub(id: ID!): RegistrationDataImportDatahubNode
  importData(id: ID!): ImportDataNode
  koboImportData(id: ID!): KoboImportDataNode
  deduplicationBatchStatusChoices: [ChoiceObject]
  deduplicationGoldenRecordStatusChoices: [ChoiceObject]
  registrationDataImport(id: ID!): RegistrationDataImportNode
  allRegistrationDataImports(offset: Int, before: String, after: String, first: Int, last: Int, importedBy_Id: UUID, importDate: Date, status: String, name: String, name_Startswith: String, businessArea: String, importDateRange: String, size: String, program: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, orderBy: String): RegistrationDataImportNodeConnection
  registrationDataStatusChoices: [ChoiceObject]
  _debug: DjangoDebug
}

input RandomSamplingArguments {
  confidenceInterval: Float!
  marginOfError: Float!
  excludedAdminAreas: [String]
  age: AgeInput
  sex: String
}

input RapidProArguments {
  flowId: String!
}

type RapidProFlow {
  id: String
  name: String
  type: String
  archived: Boolean
  labels: [String]
  expires: Int
  runs: [RapidProFlowRun]
  results: [RapidProFlowResult]
  createdOn: DateTime
  modifiedOn: DateTime
}

type RapidProFlowNode {
  id: String
  name: String
}

type RapidProFlowResult {
  key: String
  name: String
  categories: [String]
  nodeUuids: [String]
}

type RapidProFlowRun {
  active: Int
  completed: Int
  interrupted: Int
  expired: Int
}

type ReassignRoleMutation {
  household: HouseholdNode
  individual: IndividualNode
}

type RecipientNode implements Node {
  id: ID!
  headOfHousehold: IndividualNode
  size: Int
}

type RecipientNodeConnection {
  pageInfo: PageInfo!
  edges: [RecipientNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RecipientNodeEdge {
  node: RecipientNode
  cursor: String!
}

type ReconciliationSummaryNode {
  deliveredFully: Int
  deliveredPartially: Int
  notDelivered: Int
  unsuccessful: Int
  pending: Int
  forceFailed: Int
  numberOfPayments: Int
  reconciled: Int
}

input ReferralTicketExtras {
  household: ID
  individual: ID
}

type RefuseRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

enum RegistrationDataImportDataSource {
  XLS
  KOBO
  FLEX_REGISTRATION
  API
  EDOPOMOGA
  PROGRAM_POPULATION
  ENROLL_FROM_PROGRAM
}

enum RegistrationDataImportDatahubImportDone {
  LOADING
  NOT_STARTED
  STARTED
  DONE
}

type RegistrationDataImportDatahubNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  importDate: DateTime!
  hctId: UUID
  importData: ImportDataNode
  importDone: RegistrationDataImportDatahubImportDone!
  businessAreaSlug: String!
}

enum RegistrationDataImportDeduplicationEngineStatus {
  PENDING
  UPLOADED
  IN_PROGRESS
  PROCESSING
  FINISHED
  ERROR
  UPLOAD_ERROR
}

type RegistrationDataImportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  name: String!
  status: RegistrationDataImportStatus!
  deduplicationEngineStatus: RegistrationDataImportDeduplicationEngineStatus
  businessArea: UserBusinessAreaNode
  program: ProgramNode
  importDate: DateTime!
  importedBy: UserNode
  dataSource: RegistrationDataImportDataSource!
  importData: ImportDataNode
  importFromIds: String
  pullPictures: Boolean!
  screenBeneficiary: Boolean!
  excluded: Boolean!
  erased: Boolean!
  refuseReason: String
  errorMessage: String!
  sentryId: String
  numberOfIndividuals: Int!
  numberOfHouseholds: Int!
  batchDuplicates: Int!
  batchPossibleDuplicates: Int!
  batchUnique: Int!
  goldenRecordDuplicates: Int!
  goldenRecordPossibleDuplicates: Int!
  goldenRecordUnique: Int!
  dedupEngineBatchDuplicates: Int!
  dedupEngineGoldenRecordDuplicates: Int!
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  extraHhRdis(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  adminUrl: String
  batchDuplicatesCountAndPercentage: [CountAndPercentageNode]
  batchUniqueCountAndPercentage: [CountAndPercentageNode]
  goldenRecordDuplicatesCountAndPercentage: [CountAndPercentageNode]
  goldenRecordPossibleDuplicatesCountAndPercentage: [CountAndPercentageNode]
  goldenRecordUniqueCountAndPercentage: [CountAndPercentageNode]
  totalHouseholdsCountWithValidPhoneNo: Int
  biometricDeduplicated: String
  canMerge: Boolean
  biometricDeduplicationEnabled: Boolean
}

type RegistrationDataImportNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportNodeEdge {
  node: RegistrationDataImportNode
  cursor: String!
}

enum RegistrationDataImportStatus {
  LOADING
  DEDUPLICATION
  DEDUPLICATION_FAILED
  IMPORT_SCHEDULED
  IMPORTING
  IMPORT_ERROR
  IN_REVIEW
  MERGE_SCHEDULED
  MERGED
  MERGING
  MERGE_ERROR
  REFUSED
}

type RegistrationDeduplicationMutation {
  ok: Boolean
}

type RegistrationKoboImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationKoboImportMutationInput {
  importDataId: String
  name: String
  pullPictures: Boolean
  businessAreaSlug: String
  screenBeneficiary: Boolean
}

type RegistrationProgramPopulationImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationProgramPopulationImportMutationInput {
  importFromProgramId: String
  importFromIds: String
  name: String
  businessAreaSlug: String
  screenBeneficiary: Boolean
}

type RegistrationXlsxImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationXlsxImportMutationInput {
  importDataId: ID
  name: String
  businessAreaSlug: String
  screenBeneficiary: Boolean
}

type ReportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  file: String
  createdBy: UserNode!
  status: Int!
  reportType: Int!
  dateFrom: Date!
  dateTo: Date!
  numberOfRecords: Int
  program: ProgramNode
  adminArea(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  fileUrl: String
  adminArea1(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection
  adminArea2(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection
}

type ReportNodeConnection {
  pageInfo: PageInfo!
  edges: [ReportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ReportNodeEdge {
  node: ReportNode
  cursor: String!
}

type RestartCreateReport {
  report: ReportNode
}

input RestartCreateReportInput {
  reportId: ID!
  businessAreaSlug: String!
}

type RevertMarkPaymentAsFailedMutation {
  payment: PaymentNode
}

type RoleChoiceObject {
  name: String
  value: String
  subsystem: String
}

type RoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  subsystem: RoleSubsystem!
  permissions: [String!]
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  userRoles: [UserRoleNode!]!
}

enum RoleSubsystem {
  HOPE
  KOBO
  CA
  API
}

enum RuleCommitLanguage {
  PYTHON
}

type RuleCommitNode implements Node {
  id: ID!
  timestamp: DateTime!
  rule: SteficonRuleNode
  updatedBy: UserNode
  definition: String!
  isRelease: Boolean!
  enabled: Boolean!
  deprecated: Boolean!
  language: RuleCommitLanguage!
  affectedFields: [String!]!
  before: JSONString!
  after: JSONString!
  paymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  paymentPlansTarget(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
}

type RuleCommitNodeConnection {
  pageInfo: PageInfo!
  edges: [RuleCommitNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RuleCommitNodeEdge {
  node: RuleCommitNode
  cursor: String!
}

enum RuleLanguage {
  PYTHON
}

enum RuleSecurity {
  A_0
  A_2
  A_4
}

enum RuleType {
  PAYMENT_PLAN
  TARGETING
}

enum SamplingChoices {
  FULL_LIST
  RANDOM
}

type SanctionListIndividualAliasNameNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type SanctionListIndividualAliasNameNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualAliasNameNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualAliasNameNodeEdge {
  node: SanctionListIndividualAliasNameNode
  cursor: String!
}

type SanctionListIndividualCountriesNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: String
}

type SanctionListIndividualCountriesNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualCountriesNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualCountriesNodeEdge {
  node: SanctionListIndividualCountriesNode
  cursor: String!
}

type SanctionListIndividualDateOfBirthNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  date: Date!
}

type SanctionListIndividualDateOfBirthNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualDateOfBirthNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualDateOfBirthNodeEdge {
  node: SanctionListIndividualDateOfBirthNode
  cursor: String!
}

type SanctionListIndividualDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  typeOfDocument: String!
  documentNumber: String!
  dateOfIssue: String
  issuingCountry: String
  note: String!
}

type SanctionListIndividualDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualDocumentNodeEdge {
  node: SanctionListIndividualDocumentNode
  cursor: String!
}

type SanctionListIndividualNationalitiesNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  nationality: String
}

type SanctionListIndividualNationalitiesNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualNationalitiesNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualNationalitiesNodeEdge {
  node: SanctionListIndividualNationalitiesNode
  cursor: String!
}

type SanctionListIndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  secondName: String!
  thirdName: String!
  fourthName: String!
  fullName: String!
  nameOriginalScript: String!
  listType: String!
  unListType: String!
  referenceNumber: String!
  listedOn: DateTime!
  comments: String!
  designation: String!
  street: String!
  city: String!
  stateProvince: String!
  addressNote: String!
  dataId: Int!
  versionNum: Int!
  countryOfBirth: String
  active: Boolean!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualDocumentNodeConnection!
  nationalities(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualNationalitiesNodeConnection!
  countries(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualCountriesNodeConnection!
  aliasNames(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualAliasNameNodeConnection!
  datesOfBirth(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualDateOfBirthNodeConnection!
}

type SanctionListIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualNodeEdge {
  node: SanctionListIndividualNode
  cursor: String!
}

type SaveKoboProjectImportDataAsync {
  importData: KoboImportDataNode
}

type SectionTotalNode {
  total: Float
}

input SensitiveGrievanceTicketExtras {
  household: ID
  individual: ID
  paymentRecord: [ID]
}

type SetSteficonRuleOnPaymentPlanPaymentListMutation {
  paymentPlan: PaymentPlanNode
}

type SimpleApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type SplitPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type SteficonRuleNode implements Node {
  id: ID!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  name: String!
  definition: String!
  description: String
  enabled: Boolean!
  deprecated: Boolean!
  language: RuleLanguage!
  security: RuleSecurity!
  createdBy: UserNode
  updatedBy: UserNode
  createdAt: DateTime!
  updatedAt: DateTime!
  type: RuleType!
  flags: JSONString!
  history(offset: Int, before: String, after: String, first: Int, last: Int): RuleCommitNodeConnection!
}

type SteficonRuleNodeConnection {
  pageInfo: PageInfo!
  edges: [SteficonRuleNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SteficonRuleNodeEdge {
  node: SteficonRuleNode
  cursor: String!
}

enum SurveyCategory {
  RAPID_PRO
  SMS
  MANUAL
}

type SurveyNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  title: String!
  body: String!
  category: SurveyCategory!
  numberOfRecipients: Int!
  createdBy: UserNode
  recipients(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  paymentPlan: PaymentPlanNode
  program: ProgramNode
  businessArea: UserBusinessAreaNode!
  flowId: String
  samplingType: SurveySamplingType!
  sampleSize: Int!
  sampleFile: String
  sampleFileGeneratedAt: DateTime
  fullListArguments: JSONString!
  randomSamplingArguments: JSONString!
  successfulRapidProCalls: [JSONString!]!
  adminUrl: String
  sampleFilePath: String
  hasValidSampleFile: Boolean
  rapidProUrl: String
}

type SurveyNodeConnection {
  pageInfo: PageInfo!
  edges: [SurveyNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SurveyNodeEdge {
  node: SurveyNode
  cursor: String!
}

enum SurveySamplingType {
  FULL_LIST
  RANDOM
}

type TableTotalCashTransferred {
  data: [_TableTotalCashTransferredDataNode]
}

type TableTotalCashTransferredForPeople {
  data: [_TableTotalCashTransferredDataForPeopleNode]
}

enum TargetingCollectorBlockRuleFilterFlexFieldClassification {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

type TargetingCollectorBlockRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  collectorBlockFilters: TargetingCollectorRuleFilterBlockNode!
  fieldName: String!
  comparisonMethod: String
  flexFieldClassification: TargetingCollectorBlockRuleFilterFlexFieldClassification!
  arguments: [Arg]
  labelEn: String
}

type TargetingCollectorRuleFilterBlockNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  collectorBlockFilters: [TargetingCollectorBlockRuleFilterNode]
}

input TargetingCollectorRuleFilterBlockObjectType {
  collectorBlockFilters: [TargetingCriteriaRuleFilterObjectType]
}

type TargetingCriteriaNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  flagExcludeIfActiveAdjudicationTicket: Boolean!
  flagExcludeIfOnSanctionList: Boolean!
  paymentPlan: PaymentPlanNode
  rules: [TargetingCriteriaRuleNode]
  householdIds: String
  individualIds: String
}

input TargetingCriteriaObjectType {
  rules: [TargetingCriteriaRuleObjectType]
  flagExcludeIfActiveAdjudicationTicket: Boolean
  flagExcludeIfOnSanctionList: Boolean
}

enum TargetingCriteriaRuleFilterComparisonMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
  IS_NULL
}

enum TargetingCriteriaRuleFilterFlexFieldClassification {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

type TargetingCriteriaRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  flexFieldClassification: TargetingCriteriaRuleFilterFlexFieldClassification!
  fieldName: String!
  arguments: [Arg]
  roundNumber: Int
  fieldAttribute: FieldAttributeNode
}

input TargetingCriteriaRuleFilterObjectType {
  comparisonMethod: String!
  flexFieldClassification: FlexFieldClassificationChoices!
  fieldName: String!
  arguments: [Arg]!
  roundNumber: Int
}

type TargetingCriteriaRuleNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteria: TargetingCriteriaNode!
  householdIds: String!
  individualIds: String!
  individualsFiltersBlocks: [TargetingIndividualRuleFilterBlockNode]
  collectorsFiltersBlocks: [TargetingCollectorRuleFilterBlockNode!]!
  householdsFiltersBlocks: [TargetingCriteriaRuleFilterNode]
}

input TargetingCriteriaRuleObjectType {
  householdsFiltersBlocks: [TargetingCriteriaRuleFilterObjectType]
  householdIds: String
  individualsFiltersBlocks: [TargetingIndividualRuleFilterBlockObjectType]
  individualIds: String
  collectorsFiltersBlocks: [TargetingCollectorRuleFilterBlockObjectType]
}

enum TargetingIndividualBlockRuleFilterComparisonMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
  IS_NULL
}

enum TargetingIndividualBlockRuleFilterFlexFieldClassification {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

type TargetingIndividualBlockRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod!
  individualsFiltersBlock: TargetingIndividualRuleFilterBlockNode!
  flexFieldClassification: TargetingIndividualBlockRuleFilterFlexFieldClassification!
  fieldName: String!
  arguments: [Arg]
  roundNumber: Int
  fieldAttribute: FieldAttributeNode
}

type TargetingIndividualRuleFilterBlockNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  targetOnlyHoh: Boolean!
  individualBlockFilters: [TargetingIndividualBlockRuleFilterNode]
}

input TargetingIndividualRuleFilterBlockObjectType {
  individualBlockFilters: [TargetingCriteriaRuleFilterObjectType]
}

type TicketAddIndividualDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  approveStatus: Boolean!
  individualData: Arg
}

type TicketAddIndividualDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketAddIndividualDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketAddIndividualDetailsNodeEdge {
  node: TicketAddIndividualDetailsNode
  cursor: String!
}

type TicketByType {
  userGeneratedCount: Int
  systemGeneratedCount: Int
  closedUserGeneratedCount: Int
  closedSystemGeneratedCount: Int
  userGeneratedAvgResolution: Float
  systemGeneratedAvgResolution: Float
}

type TicketComplaintDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
  payment: PaymentNode
  paymentRecord: PaymentNode
}

type TicketComplaintDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketComplaintDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketComplaintDetailsNodeEdge {
  node: TicketComplaintDetailsNode
  cursor: String!
}

type TicketDeleteHouseholdDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  reasonHousehold: HouseholdNode
  approveStatus: Boolean!
  roleReassignData: JSONString!
  householdData: Arg
}

type TicketDeleteHouseholdDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketDeleteHouseholdDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketDeleteHouseholdDetailsNodeEdge {
  node: TicketDeleteHouseholdDetailsNode
  cursor: String!
}

type TicketDeleteIndividualDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode
  approveStatus: Boolean!
  roleReassignData: JSONString!
  individualData: Arg
}

type TicketDeleteIndividualDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketDeleteIndividualDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketDeleteIndividualDetailsNodeEdge {
  node: TicketDeleteIndividualDetailsNode
  cursor: String!
}

type TicketHouseholdDataUpdateDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode!
  householdData: Arg
}

type TicketHouseholdDataUpdateDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketHouseholdDataUpdateDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketHouseholdDataUpdateDetailsNodeEdge {
  node: TicketHouseholdDataUpdateDetailsNode
  cursor: String!
}

type TicketIndividualDataUpdateDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode!
  individualData: Arg
  roleReassignData: JSONString!
}

type TicketIndividualDataUpdateDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketIndividualDataUpdateDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketIndividualDataUpdateDetailsNodeEdge {
  node: TicketIndividualDataUpdateDetailsNode
  cursor: String!
}

type TicketNeedsAdjudicationDetailsExtraDataNode {
  goldenRecords: [DeduplicationResultNode]
  possibleDuplicate: [DeduplicationResultNode]
  dedupEngineSimilarityPair: DeduplicationEngineSimilarityPairNode
}

type TicketNeedsAdjudicationDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  goldenRecordsIndividual: IndividualNode!
  possibleDuplicates: [IndividualNode]
  selectedDistinct: [IndividualNode]
  selectedIndividuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  scoreMin: Float!
  scoreMax: Float!
  isMultipleDuplicatesVersion: Boolean!
  isCrossArea: Boolean!
  roleReassignData: JSONString!
  extraData: TicketNeedsAdjudicationDetailsExtraDataNode
  selectedIndividual: IndividualNode
  possibleDuplicate: IndividualNode
  hasDuplicatedDocument: Boolean
  selectedDuplicates: [IndividualNode]
}

type TicketNeedsAdjudicationDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNeedsAdjudicationDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNeedsAdjudicationDetailsNodeEdge {
  node: TicketNeedsAdjudicationDetailsNode
  cursor: String!
}

type TicketNegativeFeedbackDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketNegativeFeedbackDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNegativeFeedbackDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNegativeFeedbackDetailsNodeEdge {
  node: TicketNegativeFeedbackDetailsNode
  cursor: String!
}

type TicketNoteNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  createdBy: UserNode
}

type TicketNoteNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNoteNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNoteNodeEdge {
  node: TicketNoteNode
  cursor: String!
}

input TicketPaymentVerificationDetailsExtras {
  newReceivedAmount: Float
  newStatus: String
}

enum TicketPaymentVerificationDetailsNewStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type TicketPaymentVerificationDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus!
  paymentVerification: PaymentVerificationNode
  newStatus: TicketPaymentVerificationDetailsNewStatus
  oldReceivedAmount: Float
  newReceivedAmount: Float
  approveStatus: Boolean!
  hasMultiplePaymentVerifications: Boolean
}

type TicketPaymentVerificationDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketPaymentVerificationDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketPaymentVerificationDetailsNodeEdge {
  node: TicketPaymentVerificationDetailsNode
  cursor: String!
}

enum TicketPaymentVerificationDetailsPaymentVerificationStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type TicketPositiveFeedbackDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketPositiveFeedbackDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketPositiveFeedbackDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketPositiveFeedbackDetailsNodeEdge {
  node: TicketPositiveFeedbackDetailsNode
  cursor: String!
}

type TicketReferralDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketReferralDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketReferralDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketReferralDetailsNodeEdge {
  node: TicketReferralDetailsNode
  cursor: String!
}

type TicketSensitiveDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
  payment: PaymentNode
  paymentRecord: PaymentNode
}

type TicketSensitiveDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketSensitiveDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketSensitiveDetailsNodeEdge {
  node: TicketSensitiveDetailsNode
  cursor: String!
}

type TicketSystemFlaggingDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  goldenRecordsIndividual: IndividualNode!
  sanctionListIndividual: SanctionListIndividualNode!
  approveStatus: Boolean!
  roleReassignData: JSONString!
}

type TicketSystemFlaggingDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketSystemFlaggingDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketSystemFlaggingDetailsNodeEdge {
  node: TicketSystemFlaggingDetailsNode
  cursor: String!
}

scalar UUID

input UpdateAddIndividualIssueTypeExtras {
  individualData: AddIndividualDataObjectType!
}

input UpdateFeedbackInput {
  feedbackId: ID!
  issueType: String
  householdLookup: ID
  individualLookup: ID
  description: String
  comments: String
  admin2: ID
  area: String
  language: String
  consent: Boolean
  program: ID
}

type UpdateFeedbackMutation {
  feedback: FeedbackNode
}

input UpdateGrievanceTicketExtrasInput {
  householdDataUpdateIssueTypeExtras: UpdateHouseholdDataUpdateIssueTypeExtras
  individualDataUpdateIssueTypeExtras: UpdateIndividualDataUpdateIssueTypeExtras
  addIndividualIssueTypeExtras: UpdateAddIndividualIssueTypeExtras
  category: CategoryExtrasInput
  ticketPaymentVerificationDetailsExtras: TicketPaymentVerificationDetailsExtras
}

input UpdateGrievanceTicketInput {
  ticketId: ID!
  description: String
  assignedTo: ID
  admin: ID
  area: String
  language: String
  linkedTickets: [ID]
  household: ID
  individual: ID
  paymentRecord: ID
  extras: UpdateGrievanceTicketExtrasInput
  priority: Int
  urgency: Int
  partner: Int
  program: ID
  comments: String
  documentation: [GrievanceDocumentInput]
  documentationToUpdate: [GrievanceDocumentUpdateInput]
  documentationToDelete: [ID]
}

type UpdateGrievanceTicketMutation {
  grievanceTicket: GrievanceTicketNode
}

input UpdateHouseholdDataUpdateIssueTypeExtras {
  householdData: HouseholdUpdateDataObjectType!
}

input UpdateIndividualDataUpdateIssueTypeExtras {
  individualData: IndividualUpdateDataObjectType!
}

input UpdatePaymentPlanInput {
  paymentPlanId: ID!
  dispersionStartDate: Date
  dispersionEndDate: Date
  currency: String
  name: String
  targetingCriteria: TargetingCriteriaObjectType
  programCycleId: ID
  vulnerabilityScoreMin: Decimal
  vulnerabilityScoreMax: Decimal
  excludedIds: String
  exclusionReason: String
  fspId: ID
  deliveryMechanismCode: String
}

type UpdatePaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type UpdatePaymentVerificationReceivedAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdatePaymentVerificationStatusAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdateProgram {
  validationErrors: Arg
  program: ProgramNode
}

input UpdateProgramInput {
  id: String!
  name: String
  status: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  dataCollectingTypeCode: String
  beneficiaryGroup: String
  programmeCode: String
  pduFields: [PDUFieldInput]
}

type UpdateProgramPartners {
  validationErrors: Arg
  program: ProgramNode
}

input UpdateProgramPartnersInput {
  id: String!
  partners: [ProgramPartnerThroughInput]
  partnerAccess: String
}

scalar Upload

type UploadImportDataXLSXFileAsync {
  importData: ImportDataNode
  errors: [XlsxRowErrorNode]
}

type UserBusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  slug: String!
  name: String!
  longName: String!
  parent: UserBusinessAreaNode
  partners: [PartnerNode!]!
  isSplit: Boolean!
  regionCode: String!
  regionName: String!
  hasDataSharingAgreement: Boolean!
  isAccountabilityApplicable: Boolean
  active: Boolean!
  enableEmailNotification: Boolean!
  koboUsername: String
  koboToken: String
  koboUrl: String
  rapidProHost: String
  rapidProPaymentVerificationToken: String
  rapidProMessagesToken: String
  rapidProSurveyToken: String
  postponeDeduplication: Boolean!
  deduplicationDuplicateScore: Float!
  deduplicationPossibleDuplicateScore: Float!
  deduplicationBatchDuplicatesPercentage: Int!
  deduplicationBatchDuplicatesAllowed: Int!
  deduplicationGoldenRecordDuplicatesPercentage: Int!
  deduplicationGoldenRecordDuplicatesAllowed: Int!
  screenBeneficiary: Boolean!
  deduplicationIgnoreWithdraw: Boolean!
  biometricDeduplicationThreshold: Float!
  customFields: JSONString!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  dataCollectingTypes(offset: Int, before: String, after: String, first: Int, last: Int): DataCollectingTypeNodeConnection!
  partnerSet: [PartnerNode!]!
  userRoles: [UserRoleNode!]!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualSet(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  registrationdataimportSet(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  ruleSet(offset: Int, before: String, after: String, first: Int, last: Int): SteficonRuleNodeConnection!
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  financialserviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  tickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logentrySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messageSet(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveySet(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  fundscommitmentitemSet(offset: Int, before: String, after: String, first: Int, last: Int): FundsCommitmentItemNodeConnection!
  permissions: [String]
}

type UserBusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [UserBusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserBusinessAreaNodeEdge {
  node: UserBusinessAreaNode
  cursor: String!
}

type UserNode implements Node {
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  id: ID!
  status: UserStatus!
  partner: PartnerNode!
  email: String!
  customFields: JSONString!
  jobTitle: String!
  adUuid: String
  lastModifyDate: DateTime
  userRoles: [UserRoleNode!]!
  documentSet(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  approvalSet: [ApprovalNode!]!
  registrationDataImports(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  createdPaymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  createdFinancialServiceProviderXlsxTemplates(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderXlsxTemplateNodeConnection!
  createdFinancialServiceProviders(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  createdTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  assignedTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  ticketNotes(offset: Int, before: String, after: String, first: Int, last: Int): TicketNoteNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logs(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  feedbackMessages(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection
  partnerRoles: [PartnerRoleNode]
}

type UserNodeConnection {
  pageInfo: PageInfo!
  edges: [UserNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserNodeEdge {
  node: UserNode
  cursor: String!
}

type UserRoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  role: RoleNode!
  businessArea: UserBusinessAreaNode!
  expiryDate: Date
}

enum UserStatus {
  ACTIVE
  INACTIVE
  INVITED
}

type VolumeByDeliveryMechanismNode {
  deliveryMechanism: DeliveryMechanismPerPaymentPlanNode
  volume: Float
  volumeUsd: Float
}

type XlsxErrorNode {
  sheet: String
  coordinates: String
  message: String
}

type XlsxRowErrorNode {
  rowNumber: Int
  header: String
  message: String
}

type _DatasetsNode {
  data: [Float]
}

type _DetailedDatasetsNode {
  label: String
  data: [Float]
}

type _TableTotalCashTransferredDataForPeopleNode {
  id: String
  admin2: String
  totalCashTransferred: Float
  totalPeople: Int
}

type _TableTotalCashTransferredDataNode {
  id: String
  admin2: String
  totalCashTransferred: Float
  totalHouseholds: Int
}
