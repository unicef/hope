schema {
  query: Query
  mutation: Mutations
}

input AccountabilityCommunicationMessageAgeInput {
  min: Int
  max: Int
}

input AccountabilityFullListArguments {
  excludedAdminAreas: [String]
}

input AccountabilityRandomSamplingArguments {
  excludedAdminAreas: [String]
  confidenceInterval: Float!
  marginOfError: Float!
  age: AccountabilityCommunicationMessageAgeInput
  sex: String
}

input AccountabilitySampleSizeInput {
  targetPopulation: ID
  program: ID
  samplingType: String!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
}

type AccountabilitySampleSizeNode {
  numberOfRecipients: Int
  sampleSize: Int
}

enum Action {
  LOCK
  LOCK_FSP
  UNLOCK
  UNLOCK_FSP
  SEND_FOR_APPROVAL
  APPROVE
  AUTHORIZE
  REVIEW
  REJECT
  FINISH
  SEND_TO_PAYMENT_GATEWAY
}

input ActionPaymentPlanInput {
  paymentPlanId: ID!
  action: Action!
  comment: String
}

type ActionPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type ActivatePaymentVerificationPlan {
  validationErrors: Arg
  paymentPlan: GenericPaymentPlanNode
}

input AddIndividualDataObjectType {
  fullName: String!
  givenName: String
  middleName: String
  familyName: String
  sex: String!
  birthDate: Date!
  estimatedBirthDate: Boolean!
  maritalStatus: String
  phoneNo: String
  phoneNoAlternative: String
  email: String
  relationship: String!
  disability: String
  workStatus: String
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String
  hearingDisability: String
  physicalDisability: String
  memoryDisability: String
  selfcareDisability: String
  commsDisability: String
  whoAnswersPhone: String
  whoAnswersAltPhone: String
  role: String!
  documents: [IndividualDocumentObjectType]
  identities: [IndividualIdentityObjectType]
  paymentChannels: [BankTransferObjectType]
  businessArea: String
  preferredLanguage: String
  flexFields: Arg
  paymentDeliveryPhoneNo: String
  blockchainName: String
  walletAddress: String
  walletName: String
}

input AddIndividualIssueTypeExtras {
  household: ID!
  individualData: AddIndividualDataObjectType!
}

type AgeFilterObject {
  min: Int
  max: Int
}

input AgeInput {
  min: Int
  max: Int
}

type ApprovalNode {
  createdAt: DateTime!
  comment: String
  createdBy: UserNode
  info: String
}

type ApprovalProcessNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  sentForApprovalBy: UserNode
  sentForApprovalDate: DateTime
  sentForAuthorizationBy: UserNode
  sentForAuthorizationDate: DateTime
  sentForFinanceReleaseBy: UserNode
  sentForFinanceReleaseDate: DateTime
  paymentPlan: PaymentPlanNode!
  approvalNumberRequired: Int!
  authorizationNumberRequired: Int!
  financeReleaseNumberRequired: Int!
  rejectedOn: String
  actions: FilteredActionsListNode
}

type ApprovalProcessNodeConnection {
  pageInfo: PageInfo!
  edges: [ApprovalProcessNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ApprovalProcessNodeEdge {
  node: ApprovalProcessNode
  cursor: String!
}

type AreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  originalId: UUID
  name: String!
  parent: AreaNode
  pCode: String
  areaType: AreaTypeNode!
  validFrom: DateTime
  validUntil: DateTime
  extras: JSONString!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  areaSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
}

type AreaNodeConnection {
  pageInfo: PageInfo!
  edges: [AreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AreaNodeEdge {
  node: AreaNode
  cursor: String!
}

type AreaTreeNode {
  id: ID
  name: String
  pCode: String
  areas: [AreaTreeNode]
  level: Int
}

type AreaTypeNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  originalId: UUID
  name: String!
  areaLevel: Int!
  parent: AreaTypeNode
  validFrom: DateTime
  validUntil: DateTime
  extras: JSONString!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  areatypeSet(offset: Int, before: String, after: String, first: Int, last: Int): AreaTypeNodeConnection!
  areaSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
}

type AreaTypeNodeConnection {
  pageInfo: PageInfo!
  edges: [AreaTypeNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AreaTypeNodeEdge {
  node: AreaTypeNode
  cursor: String!
}

scalar Arg

input AssignFspToDeliveryMechanismInput {
  paymentPlanId: ID!
  mappings: [FSPToDeliveryMechanismMappingInput]!
}

type AssignFspToDeliveryMechanismMutation {
  paymentPlan: PaymentPlanNode
}

input AvailableFspsForDeliveryMechanismsInput {
  paymentPlanId: ID!
}

type BankAccountInfoNode implements Node {
  id: ID!
  rdiMergeStatus: BankAccountInfoRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  individual: IndividualNode!
  bankName: String!
  bankAccountNumber: String!
  bankBranchName: String!
  accountHolderName: String!
  isMigrationHandled: Boolean!
  copiedFrom: BankAccountInfoNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): BankAccountInfoNodeConnection!
  type: String
}

type BankAccountInfoNodeConnection {
  pageInfo: PageInfo!
  edges: [BankAccountInfoNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type BankAccountInfoNodeEdge {
  node: BankAccountInfoNode
  cursor: String!
}

enum BankAccountInfoRdiMergeStatus {
  PENDING
  MERGED
}

input BankTransferObjectType {
  type: String!
  bankName: String!
  bankAccountNumber: String!
  bankBranchName: String
  accountHolderName: String!
}

scalar BigInt

type BulkGrievanceAddNoteMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BulkUpdateGrievanceTicketsAssigneesMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BulkUpdateGrievanceTicketsPriorityMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BulkUpdateGrievanceTicketsUrgencyMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboUsername: String
  koboToken: String
  koboUrl: String
  rapidProHost: String
  rapidProPaymentVerificationToken: String
  rapidProMessagesToken: String
  rapidProSurveyToken: String
  slug: String!
  customFields: JSONString!
  hasDataSharingAgreement: Boolean!
  parent: UserBusinessAreaNode
  isSplit: Boolean!
  postponeDeduplication: Boolean!
  deduplicationDuplicateScore: Float!
  deduplicationPossibleDuplicateScore: Float!
  deduplicationBatchDuplicatesPercentage: Int!
  deduplicationBatchDuplicatesAllowed: Int!
  deduplicationGoldenRecordDuplicatesPercentage: Int!
  deduplicationGoldenRecordDuplicatesAllowed: Int!
  screenBeneficiary: Boolean!
  deduplicationIgnoreWithdraw: Boolean!
  biometricDeduplicationThreshold: Float!
  isPaymentPlanApplicable: Boolean!
  isAccountabilityApplicable: Boolean
  active: Boolean!
  enableEmailNotification: Boolean!
  partners: [PartnerNode!]!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  dataCollectingTypes(offset: Int, before: String, after: String, first: Int, last: Int): DataCollectingTypeNodeConnection!
  partnerSet: [PartnerNode!]!
  userRoles: [UserRoleNode!]!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualSet(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  registrationdataimportSet(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  ruleSet(offset: Int, before: String, after: String, first: Int, last: Int): SteficonRuleNodeConnection!
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  financialserviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  cashplanSet(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  serviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): ServiceProviderNodeConnection!
  tickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  targetpopulationSet(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  programSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logentrySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messageSet(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveySet(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
}

type BusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [BusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type BusinessAreaNodeEdge {
  node: BusinessAreaNode
  cursor: String!
}

type CashPlanAndPaymentPlanEdges {
  cursor: String
  node: CashPlanAndPaymentPlanNode
}

type CashPlanAndPaymentPlanNode {
  adminUrl: String
  objType: String
  id: String
  unicefId: String
  verificationStatus: String
  status: String
  currency: String
  totalDeliveredQuantity: Float
  startDate: String
  endDate: String
  programName: String
  updatedAt: String
  verificationPlans: [PaymentVerificationPlanNode]
  totalNumberOfHouseholds: Int
  totalEntitledQuantity: Float
  totalUndeliveredQuantity: Float
  assistanceMeasurement: String
  dispersionDate: String
  serviceProviderFullName: String
}

type CashPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  businessArea: UserBusinessAreaNode!
  statusDate: DateTime!
  startDate: DateTime
  endDate: DateTime
  program: ProgramNode!
  exchangeRate: Float
  totalEntitledQuantity: Float
  totalEntitledQuantityUsd: Float
  totalEntitledQuantityRevised: Float
  totalEntitledQuantityRevisedUsd: Float
  totalDeliveredQuantity: Float
  totalDeliveredQuantityUsd: Float
  totalUndeliveredQuantity: Float
  totalUndeliveredQuantityUsd: Float
  name: String!
  caId: String
  caHashId: UUID
  status: CashPlanStatus!
  distributionLevel: String!
  dispersionDate: DateTime!
  coverageDuration: Int!
  coverageUnit: String!
  comments: String
  deliveryType: String
  assistanceMeasurement: String!
  assistanceThrough: String!
  serviceProvider: ServiceProviderNode
  visionId: String
  fundsCommitment: String
  downPayment: String
  validationAlertsCount: Int!
  totalPersonsCovered: Int!
  totalPersonsCoveredRevised: Int!
  paymentItems(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
  totalNumberOfHouseholds: Int
  currency: String
  canCreatePaymentVerificationPlan: Boolean
  availablePaymentRecordsCount: Int
  verificationPlans(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  paymentVerificationSummary: PaymentVerificationSummaryNode
  unicefId: String
}

type CashPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [CashPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CashPlanNodeEdge {
  node: CashPlanNode
  cursor: String!
}

enum CashPlanStatus {
  DISTRIBUTION_COMPLETED
  DISTRIBUTION_COMPLETED_WITH_ERRORS
  TRANSACTION_COMPLETED
  TRANSACTION_COMPLETED_WITH_ERRORS
}

input CategoryExtrasInput {
  sensitiveGrievanceTicketExtras: SensitiveGrievanceTicketExtras
  grievanceComplaintTicketExtras: GrievanceComplaintTicketExtras
  positiveFeedbackTicketExtras: PositiveFeedbackTicketExtras
  negativeFeedbackTicketExtras: NegativeFeedbackTicketExtras
  referralTicketExtras: ReferralTicketExtras
}

type ChartDatasetNode {
  labels: [String]
  datasets: [_DatasetsNode]
}

type ChartDetailedDatasetsNode {
  labels: [String]
  datasets: [_DetailedDatasetsNode]
}

type ChartGrievanceTicketsNode {
  labels: [String]
  datasets: [_DatasetsNode]
  totalNumberOfGrievances: Int
  totalNumberOfFeedback: Int
  totalNumberOfOpenSensitive: Int
}

type ChartPaymentVerification {
  labels: [String]
  datasets: [_DetailedDatasetsNode]
  households: Int
  averageSampleSize: Float
}

type CheckAgainstSanctionListMutation {
  ok: Boolean
  errors: [XlsxRowErrorNode]
}

type ChoiceObject {
  name: String
  value: String
}

type ChoiceObjectInt {
  name: String
  value: Int
}

input ChooseDeliveryMechanismsForPaymentPlanInput {
  paymentPlanId: ID!
  deliveryMechanisms: [String]!
}

type ChooseDeliveryMechanismsForPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type CommunicationMessageNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  title: String!
  body: String!
  createdBy: UserNode
  numberOfRecipients: Int!
  businessArea: UserBusinessAreaNode!
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  targetPopulation: TargetPopulationNode
  registrationDataImport: RegistrationDataImportNode
  samplingType: MessageSamplingType!
  fullListArguments: JSONString
  randomSamplingArguments: JSONString
  sampleSize: Int!
  program: ProgramNode
  isOriginal: Boolean!
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  copiedFrom: CommunicationMessageNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  adminUrl: String
}

type CommunicationMessageNodeConnection {
  pageInfo: PageInfo!
  edges: [CommunicationMessageNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CommunicationMessageNodeEdge {
  node: CommunicationMessageNode
  cursor: String!
}

type CommunicationMessageRecipientMapNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode
}

type CommunicationMessageRecipientMapNodeConnection {
  pageInfo: PageInfo!
  edges: [CommunicationMessageRecipientMapNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CommunicationMessageRecipientMapNodeEdge {
  node: CommunicationMessageRecipientMapNode
  cursor: String!
}

type ContentTypeObjectType {
  id: ID!
  appLabel: String!
  model: String!
  paymentverificationplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationPlanNodeConnection!
  paymentverificationSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  paymentverificationsummarySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationSummaryNodeConnection!
  ticketcomplaintdetailsSet(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  ticketsensitivedetailsSet(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  logEntries(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  name: String
}

type CopyProgram {
  validationErrors: Arg
  program: ProgramNode
}

input CopyProgramInput {
  id: String!
  name: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  dataCollectingTypeCode: String
  partners: [ProgramPartnerThroughInput]
  partnerAccess: String
  programmeCode: String
  pduFields: [PDUFieldInput]
}

input CopyTargetPopulationInput {
  id: ID
  name: String
  programCycleId: ID!
}

input CopyTargetPopulationMutationInput {
  targetPopulationData: CopyTargetPopulationInput
  clientMutationId: String
}

type CopyTargetPopulationMutationPayload {
  targetPopulation: TargetPopulationNode
  validationErrors: Arg
  clientMutationId: String
}

type CoreFieldChoiceObject {
  labels: [LabelNode]
  labelEn: String
  value: String
  admin: String
  listName: String
}

type CountAndPercentageNode {
  count: Int
  percentage: Float
}

input CreateAccountabilityCommunicationMessageInput {
  households: [ID]
  targetPopulation: ID
  registrationDataImport: ID
  samplingType: SamplingChoices!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
  title: String!
  body: String!
}

type CreateCommunicationMessageMutation {
  message: CommunicationMessageNode
}

type CreateDashboardReport {
  success: Boolean
}

input CreateDashboardReportInput {
  reportTypes: [String]!
  businessAreaSlug: String!
  year: Int!
  adminArea: ID
  program: ID
}

input CreateFeedbackInput {
  issueType: String!
  householdLookup: ID
  individualLookup: ID
  description: String!
  comments: String
  admin2: ID
  area: String
  language: String
  consent: Boolean
  program: ID
}

input CreateFeedbackMessageInput {
  description: String!
  feedback: ID!
}

type CreateFeedbackMessageMutation {
  feedbackMessage: FeedbackMessageNode
}

type CreateFeedbackMutation {
  feedback: FeedbackNode
}

type CreateFollowUpPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

input CreateGrievanceTicketExtrasInput {
  category: CategoryExtrasInput
  issueType: IssueTypeExtrasInput
}

input CreateGrievanceTicketInput {
  description: String!
  assignedTo: ID
  category: Int!
  issueType: Int
  admin: ID
  area: String
  language: String!
  consent: Boolean!
  businessArea: ID!
  linkedTickets: [ID]
  extras: CreateGrievanceTicketExtrasInput
  priority: Int
  urgency: Int
  partner: Int
  program: ID
  comments: String
  linkedFeedbackId: ID
  documentation: [GrievanceDocumentInput]
}

type CreateGrievanceTicketMutation {
  grievanceTickets: [GrievanceTicketNode]
}

input CreatePaymentPlanInput {
  businessAreaSlug: String!
  targetingId: ID!
  dispersionStartDate: Date!
  dispersionEndDate: Date!
  currency: String!
}

type CreatePaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

input CreatePaymentVerificationInput {
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
  cashOrPaymentPlanId: ID!
}

type CreateProgram {
  validationErrors: Arg
  program: ProgramNode
}

input CreateProgramInput {
  name: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  dataCollectingTypeCode: String
  partners: [ProgramPartnerThroughInput]
  partnerAccess: String
  programmeCode: String
  pduFields: [PDUFieldInput]
}

type CreateReport {
  report: ReportNode
}

input CreateReportInput {
  reportType: Int!
  businessAreaSlug: String!
  dateFrom: Date!
  dateTo: Date!
  program: ID
  adminArea1: ID
  adminArea2: [ID]
}

input CreateSurveyInput {
  title: String!
  body: String
  category: String!
  targetPopulation: ID
  program: ID
  samplingType: String!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
  flow: String!
}

type CreateSurveyMutation {
  survey: SurveyNode
}

input CreateTargetPopulationInput {
  name: String!
  targetingCriteria: TargetingCriteriaObjectType!
  businessAreaSlug: String!
  programId: ID!
  programCycleId: ID!
  excludedIds: String!
  exclusionReason: String
}

type CreateTargetPopulationMutation {
  validationErrors: Arg
  targetPopulation: TargetPopulationNode
}

input CreateTicketNoteInput {
  description: String!
  ticket: ID!
}

type CreateTicketNoteMutation {
  grievanceTicketNote: TicketNoteNode
}

type CreateVerificationPlanMutation {
  paymentPlan: GenericPaymentPlanNode
}

type DataCollectingTypeChoiceObject {
  name: String
  value: String
  description: String
}

type DataCollectingTypeNode implements Node {
  id: ID!
  created: DateTime!
  modified: DateTime!
  label: String!
  code: String!
  type: DataCollectingTypeType
  description: String!
  active: Boolean!
  deprecated: Boolean!
  individualFiltersAvailable: Boolean!
  householdFiltersAvailable: Boolean!
  recalculateComposition: Boolean!
  weight: Int!
  datacollectingtypeSet(offset: Int, before: String, after: String, first: Int, last: Int): DataCollectingTypeNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

type DataCollectingTypeNodeConnection {
  pageInfo: PageInfo!
  edges: [DataCollectingTypeNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DataCollectingTypeNodeEdge {
  node: DataCollectingTypeNode
  cursor: String!
}

enum DataCollectingTypeType {
  STANDARD
  SOCIAL
}

scalar Date

scalar DateTime

scalar Decimal

type DeduplicationEngineSimilarityPairIndividualNode {
  photo: String
  fullName: String
  unicefId: String
}

type DeduplicationEngineSimilarityPairNode {
  individual1: DeduplicationEngineSimilarityPairIndividualNode
  individual2: DeduplicationEngineSimilarityPairIndividualNode
  similarityScore: String
}

type DeduplicationResultNode {
  hitId: ID
  fullName: String
  score: Float
  proximityToScore: Float
  location: String
  age: Int
  duplicate: Boolean
  distinct: Boolean
}

type DeleteHouseholdApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type DeletePaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type DeletePaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

type DeleteProgram {
  ok: Boolean
}

type DeleteRegistrationDataImport {
  ok: Boolean
}

input DeleteTargetPopulationMutationInput {
  targetId: ID!
  clientMutationId: String
}

type DeleteTargetPopulationMutationPayload {
  ok: Boolean
  clientMutationId: String
}

type DeliveredQuantityNode {
  totalDeliveredQuantity: Decimal
  currency: String
}

enum DeliveryMechanismDataDeliveryMechanismChoice {
  CARDLESS_CASH_WITHDRAWAL
  CASH
  CASH_BY_FSP
  CHEQUE
  DEPOSIT_TO_CARD
  MOBILE_MONEY
  PRE_PAID_CARD
  REFERRAL
  TRANSFER
  TRANSFER_TO_ACCOUNT
  VOUCHER
  ATM_CARD
  CASH_OVER_THE_COUNTER
  TRANSFER_TO_DIGITAL_WALLET
}

type DeliveryMechanismDataNode implements Node {
  id: ID!
  rdiMergeStatus: DeliveryMechanismDataRdiMergeStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode!
  deliveryMechanismChoice: DeliveryMechanismDataDeliveryMechanismChoice
  deliveryMechanism: DeliveryMechanismNode!
  data: JSONString!
  isValid: Boolean
  validationErrors: JSONString!
  possibleDuplicateOf: DeliveryMechanismDataNode
  possibleDuplicates(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismDataNodeConnection!
  name: String
  individualTabData: JSONString
}

type DeliveryMechanismDataNodeConnection {
  pageInfo: PageInfo!
  edges: [DeliveryMechanismDataNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DeliveryMechanismDataNodeEdge {
  node: DeliveryMechanismDataNode
  cursor: String!
}

input DeliveryMechanismDataObjectType {
  label: String!
  approveStatus: Boolean!
  dataFields: [DeliveryMechanismDataPayloadFieldObjectType]!
}

input DeliveryMechanismDataPayloadFieldObjectType {
  name: String!
  value: String!
  previousValue: String
}

enum DeliveryMechanismDataRdiMergeStatus {
  PENDING
  MERGED
}

type DeliveryMechanismNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentGatewayId: String
  code: String
  name: String
  optionalFields: [String!]!
  requiredFields: [String!]!
  uniqueFields: [String!]!
  isActive: Boolean!
  transferType: DeliveryMechanismTransferType!
  financialserviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  deliverymechanismperpaymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismPerPaymentPlanNodeConnection!
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  deliverymechanismdataSet(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismDataNodeConnection!
}

type DeliveryMechanismNodeConnection {
  pageInfo: PageInfo!
  edges: [DeliveryMechanismNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DeliveryMechanismNodeEdge {
  node: DeliveryMechanismNode
  cursor: String!
}

enum DeliveryMechanismPerPaymentPlanDeliveryMechanismChoice {
  CARDLESS_CASH_WITHDRAWAL
  CASH
  CASH_BY_FSP
  CHEQUE
  DEPOSIT_TO_CARD
  MOBILE_MONEY
  PRE_PAID_CARD
  REFERRAL
  TRANSFER
  TRANSFER_TO_ACCOUNT
  VOUCHER
  ATM_CARD
  CASH_OVER_THE_COUNTER
  TRANSFER_TO_DIGITAL_WALLET
}

type DeliveryMechanismPerPaymentPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentPlan: PaymentPlanNode!
  financialServiceProvider: FinancialServiceProviderNode
  createdBy: UserNode!
  sentDate: DateTime!
  sentBy: UserNode
  status: String!
  deliveryMechanismChoice: DeliveryMechanismPerPaymentPlanDeliveryMechanismChoice
  deliveryMechanism: DeliveryMechanismNode
  deliveryMechanismOrder: Int!
  sentToPaymentGateway: Boolean!
  chosenConfiguration: String
  name: String
  code: String
  order: Int
  fsp: FinancialServiceProviderNode
}

type DeliveryMechanismPerPaymentPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [DeliveryMechanismPerPaymentPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DeliveryMechanismPerPaymentPlanNodeEdge {
  node: DeliveryMechanismPerPaymentPlanNode
  cursor: String!
}

enum DeliveryMechanismTransferType {
  CASH
  VOUCHER
  DIGITAL
}

type DiscardPaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

type DjangoDebug {
  sql: [DjangoDebugSQL]
}

type DjangoDebugSQL {
  vendor: String!
  alias: String!
  sql: String
  duration: Float!
  rawSql: String!
  params: String!
  startTime: Float!
  stopTime: Float!
  isSlow: Boolean!
  isSelect: Boolean!
  transId: String
  transStatus: String
  isoLevel: String
  encoding: String
}

type DocumentNode implements Node {
  id: ID!
  rdiMergeStatus: DocumentRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  documentNumber: String!
  photo: String
  individual: IndividualNode!
  type: ImportedDocumentTypeNode!
  country: String
  status: DocumentStatus!
  cleared: Boolean!
  clearedDate: DateTime!
  clearedBy: UserNode
  issuanceDate: DateTime
  expiryDate: DateTime
  program: ProgramNode
  isMigrationHandled: Boolean!
  copiedFrom: DocumentNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  countryIso3: String
}

type DocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [DocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DocumentNodeEdge {
  node: DocumentNode
  cursor: String!
}

enum DocumentRdiMergeStatus {
  PENDING
  MERGED
}

enum DocumentStatus {
  PENDING
  VALID
  NEED_INVESTIGATION
  INVALID
}

input EditBankTransferObjectType {
  id: ID!
  type: String!
  bankName: String!
  bankAccountNumber: String!
  bankBranchName: String
  accountHolderName: String!
}

input EditDeliveryMechanismDataObjectType {
  id: ID!
  label: String!
  approveStatus: Boolean!
  dataFields: [DeliveryMechanismDataPayloadFieldObjectType]!
}

input EditIndividualDocumentObjectType {
  id: ID!
  country: String!
  key: String!
  number: String!
  photo: Arg
  photoraw: Arg
}

input EditIndividualIdentityObjectType {
  id: ID!
  country: String!
  partner: String!
  number: String!
}

input EditPaymentVerificationInput {
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
  paymentVerificationPlanId: ID!
}

type EditPaymentVerificationMutation {
  paymentPlan: GenericPaymentPlanNode
}

type EraseRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

type ExcludeHouseholdsMutation {
  paymentPlan: PaymentPlanNode
}

type ExportPDFPaymentPlanSummaryMutation {
  paymentPlan: PaymentPlanNode
}

type ExportSurveySampleMutationMutation {
  survey: SurveyNode
}

type ExportXLSXPaymentPlanPaymentListMutation {
  paymentPlan: PaymentPlanNode
}

type ExportXLSXPaymentPlanPaymentListPerFSPMutation {
  paymentPlan: PaymentPlanNode
}

type ExportXlsxPaymentVerificationPlanFile {
  paymentPlan: GenericPaymentPlanNode
}

input FSPToDeliveryMechanismMappingInput {
  fspId: ID!
  deliveryMechanism: String!
  chosenConfiguration: String
  order: Int!
}

enum FeedbackIssueType {
  POSITIVE_FEEDBACK
  NEGATIVE_FEEDBACK
}

type FeedbackMessageNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  createdBy: UserNode
}

type FeedbackMessageNodeConnection {
  pageInfo: PageInfo!
  edges: [FeedbackMessageNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FeedbackMessageNodeEdge {
  node: FeedbackMessageNode
  cursor: String!
}

type FeedbackNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  businessArea: UserBusinessAreaNode!
  issueType: FeedbackIssueType!
  householdLookup: HouseholdNode
  individualLookup: IndividualNode
  description: String!
  comments: String
  admin2: AreaNode
  area: String!
  language: String!
  consent: Boolean!
  program: ProgramNode
  createdBy: UserNode
  linkedGrievance: GrievanceTicketNode
  isOriginal: Boolean!
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  copiedFrom: FeedbackNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  feedbackMessages(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackMessageNodeConnection!
  adminUrl: String
}

type FeedbackNodeConnection {
  pageInfo: PageInfo!
  edges: [FeedbackNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FeedbackNodeEdge {
  node: FeedbackNode
  cursor: String!
}

type FieldAttributeNode {
  id: String
  type: String
  name: String
  labels: [LabelNode]
  labelEn: String
  hint: String
  required: Boolean
  choices: [CoreFieldChoiceObject]
  associatedWith: String
  isFlexField: Boolean
  pduData: PeriodicFieldDataNode
}

type FilteredActionsListNode {
  approval: [ApprovalNode]
  authorization: [ApprovalNode]
  financeRelease: [ApprovalNode]
  reject: [ApprovalNode]
}

type FinalizeTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

enum FinancialServiceProviderCommunicationChannel {
  API
  SFTP
  XLSX
}

type FinancialServiceProviderNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  createdBy: UserNode
  name: String!
  visionVendorNumber: String!
  deliveryMechanismsChoices: [String!]
  deliveryMechanisms(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismNodeConnection!
  distributionLimit: Float
  communicationChannel: FinancialServiceProviderCommunicationChannel!
  dataTransferConfiguration: JSONString
  xlsxTemplates(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderXlsxTemplateNodeConnection!
  paymentGatewayId: String
  deliveryMechanismsPerPaymentPlan(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismPerPaymentPlanNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  fullName: String
  isPaymentGateway: Boolean
}

type FinancialServiceProviderNodeConnection {
  pageInfo: PageInfo!
  edges: [FinancialServiceProviderNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FinancialServiceProviderNodeEdge {
  node: FinancialServiceProviderNode
  cursor: String!
}

type FinancialServiceProviderXlsxTemplateNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: UserNode
  name: String!
  columns: [String]
  coreFields: [String!]!
  flexFields: [String!]!
  financialServiceProviders(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
}

type FinancialServiceProviderXlsxTemplateNodeConnection {
  pageInfo: PageInfo!
  edges: [FinancialServiceProviderXlsxTemplateNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FinancialServiceProviderXlsxTemplateNodeEdge {
  node: FinancialServiceProviderXlsxTemplateNode
  cursor: String!
}

type FinishPaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

enum FlexFieldClassificationChoices {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

scalar FlexFieldsScalar

type FspChoice {
  id: String
  name: String
  configurations: [FspConfiguration]
}

type FspChoices {
  deliveryMechanism: String
  fsps: [FspChoice]
}

type FspConfiguration {
  id: String
  key: String
  label: String
}

input FullListArguments {
  excludedAdminAreas: [String]
}

type GenericPaymentNode {
  id: String
  objType: String
  unicefId: String
  currency: String
  deliveredQuantity: Float
  deliveredQuantityUsd: Float
  household: HouseholdNode
}

type GenericPaymentPlanNode {
  id: String
  objType: String
  paymentVerificationSummary: PaymentVerificationSummaryNode
  availablePaymentRecordsCount: Int
  verificationPlans(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  statusDate: DateTime
  status: String
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
  deliveryType: String
  totalNumberOfHouseholds: Int
  currency: String
  totalDeliveredQuantity: Float
  totalEntitledQuantity: Float
  totalUndeliveredQuantity: Float
  canCreatePaymentVerificationPlan: Boolean
}

scalar GeoJSON

input GetAccountabilityCommunicationMessageSampleSizeInput {
  households: [ID]
  targetPopulation: ID
  registrationDataImport: ID
  samplingType: SamplingChoices!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
}

input GetCashplanVerificationSampleSizeInput {
  cashOrPaymentPlanId: ID
  paymentVerificationPlanId: ID
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

type GetCashplanVerificationSampleSizeObject {
  paymentRecordCount: Int
  sampleSize: Int
}

type GetCommunicationMessageSampleSizeNode {
  numberOfRecipients: Int
  sampleSize: Int
}

input GrievanceComplaintTicketExtras {
  household: ID
  individual: ID
  paymentRecord: [ID]
}

input GrievanceDocumentInput {
  name: String!
  file: Upload!
}

type GrievanceDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  createdBy: UserNode
  grievanceTicket: GrievanceTicketNode
  fileSize: Int
  contentType: String!
  filePath: String
  fileName: String
}

type GrievanceDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [GrievanceDocumentNodeEdge]!
}

type GrievanceDocumentNodeEdge {
  node: GrievanceDocumentNode
  cursor: String!
}

input GrievanceDocumentUpdateInput {
  id: ID!
  name: String
  file: Upload
}

type GrievanceStatusChangeMutation {
  grievanceTicket: GrievanceTicketNode
}

type GrievanceTicketNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  userModified: DateTime
  lastNotificationSent: DateTime
  createdBy: UserNode
  assignedTo: UserNode
  status: Int!
  category: Int!
  issueType: Int
  description: String!
  admin2: AreaNode
  area: String!
  language: String!
  consent: Boolean!
  businessArea: UserBusinessAreaNode!
  linkedTickets: [GrievanceTicketNode]
  registrationDataImport: RegistrationDataImportNode
  extras: JSONString!
  ignored: Boolean!
  householdUnicefId: String
  priority: Int
  urgency: Int
  partner: PartnerType
  programs: [ProgramNode]
  comments: String
  isOriginal: Boolean!
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  copiedFrom: GrievanceTicketNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  ticketNotes(offset: Int, before: String, after: String, first: Int, last: Int): TicketNoteNodeConnection!
  complaintTicketDetails: TicketComplaintDetailsNode
  sensitiveTicketDetails: TicketSensitiveDetailsNode
  householdDataUpdateTicketDetails: TicketHouseholdDataUpdateDetailsNode
  individualDataUpdateTicketDetails: TicketIndividualDataUpdateDetailsNode
  addIndividualTicketDetails: TicketAddIndividualDetailsNode
  deleteIndividualTicketDetails: TicketDeleteIndividualDetailsNode
  deleteHouseholdTicketDetails: TicketDeleteHouseholdDetailsNode
  systemFlaggingTicketDetails: TicketSystemFlaggingDetailsNode
  needsAdjudicationTicketDetails: TicketNeedsAdjudicationDetailsNode
  paymentVerificationTicketDetails: TicketPaymentVerificationDetailsNode
  positiveFeedbackTicketDetails: TicketPositiveFeedbackDetailsNode
  negativeFeedbackTicketDetails: TicketNegativeFeedbackDetailsNode
  referralTicketDetails: TicketReferralDetailsNode
  supportDocuments(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceDocumentNodeConnection!
  feedback: FeedbackNode
  adminUrl: String
  household: HouseholdNode
  individual: IndividualNode
  paymentRecord: PaymentRecordAndPaymentNode
  admin: String
  existingTickets: [GrievanceTicketNode]
  relatedTickets: [GrievanceTicketNode]
  totalDays: String
  documentation: [GrievanceDocumentNode]
}

type GrievanceTicketNodeConnection {
  pageInfo: PageInfo!
  edges: [GrievanceTicketNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type GrievanceTicketNodeEdge {
  node: GrievanceTicketNode
  cursor: String!
}

type GroupAttributeNode {
  id: UUID!
  name: String!
  label: JSONString!
  flexAttributes(flexField: Boolean): [FieldAttributeNode]
  labelEn: String
}

enum HouseholdCollectIndividualData {
  A_
  A_2
  A_1
  A_3
  A_0
}

enum HouseholdCollectType {
  STANDARD
  SINGLE
}

enum HouseholdConsentSharing {
  A_
  GOVERNMENT_PARTNER
  HUMANITARIAN_PARTNER
  PRIVATE_PARTNER
  UNICEF
}

enum HouseholdCurrency {
  A_
  AED
  AFN
  ALL
  AMD
  ANG
  AOA
  ARS
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BHD
  BIF
  BMD
  BND
  BOB
  BOV
  BRL
  BSD
  BTN
  BWP
  BYN
  BZD
  CAD
  CDF
  CHF
  CLP
  CNY
  COP
  CRC
  CUC
  CUP
  CVE
  CZK
  DJF
  DKK
  DOP
  DZD
  EGP
  ERN
  ETB
  EUR
  FJD
  FKP
  GBP
  GEL
  GHS
  GIP
  GMD
  GNF
  GTQ
  GYD
  HKD
  HNL
  HRK
  HTG
  HUF
  IDR
  ILS
  INR
  IQD
  IRR
  ISK
  JMD
  JOD
  JPY
  KES
  KGS
  KHR
  KMF
  KPW
  KRW
  KWD
  KYD
  KZT
  LAK
  LBP
  LKR
  LRD
  LSL
  LYD
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRU
  MUR
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NIO
  NOK
  NPR
  NZD
  OMR
  PAB
  PEN
  PGK
  PHP
  PKR
  PLN
  PYG
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SDG
  SEK
  SGD
  SHP
  SLL
  SOS
  SRD
  SSP
  STN
  SVC
  SYP
  SZL
  THB
  TJS
  TMT
  TND
  TOP
  TRY
  TTD
  TWD
  TZS
  UAH
  UGX
  USD
  UYU
  UYW
  UZS
  VES
  VND
  VUV
  WST
  XAF
  XAG
  XAU
  XCD
  XOF
  XPF
  YER
  ZAR
  ZMW
  ZWL
  USDC
}

type HouseholdDataChangeApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input HouseholdDataUpdateIssueTypeExtras {
  household: ID!
  householdData: HouseholdUpdateDataObjectType!
}

input HouseholdDeleteIssueTypeExtras {
  household: ID!
}

type HouseholdNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode
  rdiMergeStatus: HouseholdRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  unicefId: String
  withdrawn: Boolean!
  withdrawnDate: DateTime
  consentSign: String!
  consent: Boolean
  consentSharing: [String]
  residenceStatus: String
  countryOrigin: String
  country: String
  address: String!
  zipCode: String
  adminArea: AreaNode
  admin1: AreaNode
  admin2: AreaNode
  admin3: AreaNode
  admin4: AreaNode
  geopoint: GeoJSON
  representatives(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  childrenCount: Int
  maleChildrenCount: Int
  femaleChildrenCount: Int
  childrenDisabledCount: Int
  maleChildrenDisabledCount: Int
  femaleChildrenDisabledCount: Int
  registrationDataImport: RegistrationDataImportNode
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  returnee: Boolean
  flexFields: FlexFieldsScalar
  firstRegistrationDate: DateTime!
  lastRegistrationDate: DateTime!
  fchildHoh: Boolean
  childHoh: Boolean
  businessArea: UserBusinessAreaNode!
  start: DateTime
  deviceid: String!
  nameEnumerator: String!
  orgEnumerator: HouseholdOrgEnumerator!
  orgNameEnumerator: String!
  village: String!
  registrationMethod: HouseholdRegistrationMethod!
  collectIndividualData: HouseholdCollectIndividualData!
  currency: String
  unhcrId: String!
  userFields: JSONString!
  detailId: String
  registrationId: String
  programRegistrationId: String
  totalCashReceivedUsd: Decimal
  totalCashReceived: Decimal
  familyId: String
  program: ProgramNode
  copiedFrom: HouseholdNode
  originUnicefId: String
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  isRecalculatedGroupAges: Boolean!
  collectType: HouseholdCollectType!
  koboSubmissionUuid: UUID
  koboSubmissionTime: DateTime
  enumeratorRecId: Int
  misUnicefId: String
  flexRegistrationsRecordId: Int
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualsAndRoles: [IndividualRoleInHouseholdNode!]!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int, household_Id: UUID, businessArea: String, fullName: String, fullName_Startswith: String, fullName_Endswith: String, sex: [String], household_AdminArea: ID, withdrawn: Boolean, program: ID, age: String, programs: [ID], search: String, documentType: String, documentNumber: String, lastRegistrationDate: String, admin1: [ID], admin2: [ID], status: [String], excludedId: String, flags: [String], isActiveProgram: Boolean, orderBy: String): IndividualNodeConnection
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  householdDataUpdateTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketHouseholdDataUpdateDetailsNodeConnection!
  addIndividualTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketAddIndividualDetailsNodeConnection!
  deleteHouseholdTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketDeleteHouseholdDetailsNodeConnection!
  positiveFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPositiveFeedbackDetailsNodeConnection!
  negativeFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketNegativeFeedbackDetailsNodeConnection!
  referralTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketReferralDetailsNodeConnection!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  selections: [HouseholdSelectionNode!]!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  adminUrl: String
  selection: HouseholdSelectionNode
  sanctionListPossibleMatch: Boolean
  sanctionListConfirmedMatch: Boolean
  hasDuplicates: Boolean
  adminAreaTitle: String
  status: String
  deliveredQuantities: [DeliveredQuantityNode]
  activeIndividualsCount: Int
  importId: String
}

type HouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [HouseholdNodeEdge]!
  totalCount: Int
  individualsCount: Int
  edgeCount: Int
}

type HouseholdNodeEdge {
  node: HouseholdNode
  cursor: String!
}

enum HouseholdOrgEnumerator {
  A_
  PARTNER
  UNICEF
}

enum HouseholdRdiMergeStatus {
  PENDING
  MERGED
}

enum HouseholdRegistrationMethod {
  A_
  COMMUNITY
  HH_REGISTRATION
}

enum HouseholdResidenceStatus {
  A_
  IDP
  REFUGEE
  OTHERS_OF_CONCERN
  HOST
  NON_HOST
  RETURNEE
}

type HouseholdSelectionNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode!
  targetPopulation: TargetPopulationNode!
  vulnerabilityScore: Float
  isOriginal: Boolean!
  isMigrationHandled: Boolean!
}

input HouseholdUpdateDataObjectType {
  adminAreaTitle: String
  status: String
  consent: Boolean
  consentSharing: [String]
  residenceStatus: String
  countryOrigin: String
  country: String
  size: Int
  address: String
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  returnee: Boolean
  fchildHoh: Boolean
  childHoh: Boolean
  start: DateTime
  end: DateTime
  nameEnumerator: String
  orgEnumerator: String
  orgNameEnumerator: String
  village: String
  registrationMethod: String
  collectIndividualData: String
  currency: String
  unhcrId: String
  flexFields: Arg
}

enum ImportDataDataType {
  XLSX
  JSON
  FLEX
}

type ImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ImportDataStatus!
  businessAreaSlug: String!
  file: String
  dataType: ImportDataDataType!
  numberOfHouseholds: Int
  numberOfIndividuals: Int
  error: String!
  validationErrors: String!
  deliveryMechanismsValidationErrors: String!
  createdById: UUID
  registrationDataImportHope: RegistrationDataImportNode
  koboimportdata: KoboImportDataNode
  registrationDataImport: RegistrationDataImportDatahubNode
  xlsxValidationErrors: [XlsxRowErrorNode]
}

enum ImportDataStatus {
  PENDING
  RUNNING
  FINISHED
  ERROR
  VALIDATION_ERROR
  DELIVERY_MECHANISMS_VALIDATION_ERROR
}

type ImportXLSXPaymentPlanPaymentListMutation {
  paymentPlan: PaymentPlanNode
  errors: [XlsxErrorNode]
}

type ImportXLSXPaymentPlanPaymentListPerFSPMutation {
  paymentPlan: PaymentPlanNode
  errors: [XlsxErrorNode]
}

type ImportXlsxPaymentVerificationPlanFile {
  paymentPlan: GenericPaymentPlanNode
  errors: [XlsxErrorNode]
}

type ImportedDocumentNode implements Node {
  id: ID!
  rdiMergeStatus: DocumentRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  documentNumber: String!
  photo: String
  individual: IndividualNode!
  type: ImportedDocumentTypeNode!
  country: String
  status: DocumentStatus!
  cleared: Boolean!
  clearedDate: DateTime!
  clearedBy: UserNode
  issuanceDate: DateTime
  expiryDate: DateTime
  program: ProgramNode
  isMigrationHandled: Boolean!
  copiedFrom: DocumentNode
}

type ImportedDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedDocumentNodeEdge {
  node: ImportedDocumentNode
  cursor: String!
}

type ImportedDocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  key: String!
  isIdentityDocument: Boolean!
  uniqueForIndividual: Boolean!
  validForDeduplication: Boolean!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
}

type ImportedHouseholdNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode
  rdiMergeStatus: HouseholdRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  unicefId: String
  withdrawn: Boolean!
  withdrawnDate: DateTime
  consentSign: String!
  consent: Boolean
  consentSharing: HouseholdConsentSharing!
  residenceStatus: HouseholdResidenceStatus
  countryOrigin: String
  country: String
  address: String!
  zipCode: String
  adminArea: AreaNode
  admin1: AreaNode
  admin2: AreaNode
  admin3: AreaNode
  admin4: AreaNode
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  childrenCount: Int
  maleChildrenCount: Int
  femaleChildrenCount: Int
  childrenDisabledCount: Int
  maleChildrenDisabledCount: Int
  femaleChildrenDisabledCount: Int
  registrationDataImport: RegistrationDataImportNode
  returnee: Boolean
  flexFields: Arg
  firstRegistrationDate: DateTime!
  lastRegistrationDate: DateTime!
  fchildHoh: Boolean
  childHoh: Boolean
  businessArea: UserBusinessAreaNode!
  start: DateTime
  deviceid: String!
  nameEnumerator: String!
  orgEnumerator: HouseholdOrgEnumerator!
  orgNameEnumerator: String!
  village: String!
  registrationMethod: HouseholdRegistrationMethod!
  collectIndividualData: HouseholdCollectIndividualData!
  currency: HouseholdCurrency!
  unhcrId: String!
  userFields: JSONString!
  detailId: String
  registrationId: String
  programRegistrationId: String
  totalCashReceivedUsd: Float
  totalCashReceived: Float
  familyId: String
  program: ProgramNode
  copiedFrom: HouseholdNode
  originUnicefId: String
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  isRecalculatedGroupAges: Boolean!
  collectType: HouseholdCollectType!
  koboSubmissionUuid: UUID
  koboSubmissionTime: DateTime
  enumeratorRecId: Int
  misUnicefId: String
  flexRegistrationsRecordId: Int
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection
  hasDuplicates: Boolean
  importId: String
}

type ImportedHouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedHouseholdNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedHouseholdNodeEdge {
  node: ImportedHouseholdNode
  cursor: String!
}

type ImportedIndividualIdentityNode implements Node {
  id: ID!
  created: DateTime!
  modified: DateTime!
  rdiMergeStatus: IndividualIdentityRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  individual: IndividualNode!
  number: String!
  partner: String
  country: String
  isMigrationHandled: Boolean!
  copiedFrom: IndividualIdentityNode
}

type ImportedIndividualIdentityNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedIndividualIdentityNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedIndividualIdentityNodeEdge {
  node: ImportedIndividualIdentityNode
  cursor: String!
}

type ImportedIndividualNode implements Node {
  id: ID!
  rdiMergeStatus: IndividualRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  unicefId: String
  duplicate: Boolean!
  duplicateDate: DateTime
  withdrawn: Boolean!
  withdrawnDate: DateTime
  individualId: String!
  photo: String!
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  sex: IndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: IndividualMaritalStatus!
  phoneNo: String!
  phoneNoValid: Boolean
  phoneNoAlternative: String!
  phoneNoAlternativeValid: Boolean
  email: String
  paymentDeliveryPhoneNo: String
  relationship: String
  household: HouseholdNode
  registrationDataImport: RegistrationDataImportNode!
  workStatus: String!
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  flexFields: FlexFieldsScalar
  userFields: JSONString!
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus!
  deduplicationBatchStatus: IndividualDeduplicationBatchStatus!
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  deduplicationBatchResults: [DeduplicationResultNode]
  importedIndividualId: UUID
  sanctionListPossibleMatch: Boolean!
  sanctionListConfirmedMatch: Boolean!
  pregnant: Boolean
  disability: IndividualDisability!
  observedDisability: [String]
  disabilityCertificatePicture: String
  seeingDisability: String!
  hearingDisability: String!
  physicalDisability: String!
  memoryDisability: String!
  selfcareDisability: String!
  commsDisability: String!
  whoAnswersPhone: String!
  whoAnswersAltPhone: String!
  businessArea: UserBusinessAreaNode!
  fchildHoh: Boolean!
  childHoh: Boolean!
  detailId: String
  registrationId: String
  programRegistrationId: String
  preferredLanguage: String
  relationshipConfirmed: Boolean!
  ageAtRegistration: Int
  walletName: String!
  blockchainName: String!
  walletAddress: String!
  program: ProgramNode
  copiedFrom: IndividualNode
  originUnicefId: String
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  misUnicefId: String
  role: String
  age: Int
  importId: String
  documents(offset: Int, before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection
  identities(offset: Int, before: String, after: String, first: Int, last: Int): ImportedIndividualIdentityNodeConnection
}

type ImportedIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedIndividualNodeEdge {
  node: ImportedIndividualNode
  cursor: String!
}

type IndividualDataChangeApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input IndividualDataUpdateIssueTypeExtras {
  individual: ID!
  individualData: IndividualUpdateDataObjectType!
}

enum IndividualDeduplicationBatchStatus {
  DUPLICATE_IN_BATCH
  NOT_PROCESSED
  SIMILAR_IN_BATCH
  UNIQUE_IN_BATCH
}

enum IndividualDeduplicationGoldenRecordStatus {
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
  POSTPONE
  UNIQUE
}

input IndividualDeleteIssueTypeExtras {
  individual: ID!
}

enum IndividualDisability {
  DISABLED
  NOT_DISABLED
}

input IndividualDocumentObjectType {
  country: String!
  key: String!
  number: String!
  photo: Arg
  photoraw: Arg
}

type IndividualIdentityNode implements Node {
  id: ID!
  created: DateTime!
  modified: DateTime!
  rdiMergeStatus: IndividualIdentityRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  individual: IndividualNode!
  number: String!
  partner: String
  country: String
  isMigrationHandled: Boolean!
  copiedFrom: IndividualIdentityNode
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  countryIso3: String
}

type IndividualIdentityNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualIdentityNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualIdentityNodeEdge {
  node: IndividualIdentityNode
  cursor: String!
}

input IndividualIdentityObjectType {
  country: String!
  partner: String!
  number: String!
}

enum IndividualIdentityRdiMergeStatus {
  PENDING
  MERGED
}

enum IndividualMaritalStatus {
  A_
  DIVORCED
  MARRIED
  SEPARATED
  SINGLE
  WIDOWED
}

type IndividualNode implements Node {
  id: ID!
  rdiMergeStatus: IndividualRdiMergeStatus!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  unicefId: String
  duplicate: Boolean!
  duplicateDate: DateTime
  withdrawn: Boolean!
  withdrawnDate: DateTime
  individualId: String!
  photo: String
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  sex: IndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: IndividualMaritalStatus!
  phoneNo: String!
  phoneNoValid: Boolean
  phoneNoAlternative: String!
  phoneNoAlternativeValid: Boolean
  email: String!
  paymentDeliveryPhoneNo: String
  relationship: IndividualRelationship
  household: HouseholdNode
  registrationDataImport: RegistrationDataImportNode!
  workStatus: String!
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  flexFields: FlexFieldsScalar
  userFields: JSONString!
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus!
  deduplicationBatchStatus: IndividualDeduplicationBatchStatus!
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  deduplicationBatchResults: [DeduplicationResultNode]
  importedIndividualId: UUID
  sanctionListPossibleMatch: Boolean!
  sanctionListConfirmedMatch: Boolean!
  pregnant: Boolean
  disability: IndividualDisability!
  observedDisability: [String]
  disabilityCertificatePicture: String
  seeingDisability: String!
  hearingDisability: String!
  physicalDisability: String!
  memoryDisability: String!
  selfcareDisability: String!
  commsDisability: String!
  whoAnswersPhone: String!
  whoAnswersAltPhone: String!
  businessArea: UserBusinessAreaNode!
  fchildHoh: Boolean!
  childHoh: Boolean!
  detailId: String
  registrationId: String
  programRegistrationId: String
  preferredLanguage: String
  relationshipConfirmed: Boolean!
  ageAtRegistration: Int
  walletName: String!
  blockchainName: String!
  walletAddress: String!
  program: ProgramNode
  copiedFrom: IndividualNode
  originUnicefId: String
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  misUnicefId: String
  representedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  headingHousehold: HouseholdNode
  documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  identities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  householdsAndRoles: [IndividualRoleInHouseholdNode!]!
  copiedTo(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  bankAccountInfo: BankAccountInfoNode
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  collectorPayments(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  deliveryMechanismsData: [DeliveryMechanismDataNode]
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  individualDataUpdateTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketIndividualDataUpdateDetailsNodeConnection!
  deleteIndividualTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketDeleteIndividualDetailsNodeConnection!
  ticketsystemflaggingdetailsSet(offset: Int, before: String, after: String, first: Int, last: Int): TicketSystemFlaggingDetailsNodeConnection!
  ticketGoldenRecords(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  ticketDuplicates(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  selectedDistinct(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  ticketSelected(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  positiveFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPositiveFeedbackDetailsNodeConnection!
  negativeFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketNegativeFeedbackDetailsNodeConnection!
  referralTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketReferralDetailsNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  adminUrl: String
  status: String
  role: String
  age: Int
  sanctionListLastCheck: DateTime
  paymentChannels: [BankAccountInfoNode]
}

type IndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualNodeEdge {
  node: IndividualNode
  cursor: String!
}

enum IndividualRdiMergeStatus {
  PENDING
  MERGED
}

enum IndividualRelationship {
  UNKNOWN
  AUNT_UNCLE
  BROTHER_SISTER
  COUSIN
  DAUGHTERINLAW_SONINLAW
  GRANDDAUGHER_GRANDSON
  GRANDMOTHER_GRANDFATHER
  HEAD
  MOTHER_FATHER
  MOTHERINLAW_FATHERINLAW
  NEPHEW_NIECE
  NON_BENEFICIARY
  OTHER
  SISTERINLAW_BROTHERINLAW
  SON_DAUGHTER
  WIFE_HUSBAND
  FOSTER_CHILD
  FREE_UNION
}

type IndividualRoleInHouseholdNode {
  id: UUID!
  rdiMergeStatus: IndividualRoleInHouseholdRdiMergeStatus!
  isRemoved: Boolean!
  isOriginal: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  individual: IndividualNode!
  household: HouseholdNode!
  role: IndividualRoleInHouseholdRole
  isMigrationHandled: Boolean!
  migratedAt: DateTime
  copiedFrom: IndividualRoleInHouseholdNode
  copiedTo: [IndividualRoleInHouseholdNode!]!
}

enum IndividualRoleInHouseholdRdiMergeStatus {
  PENDING
  MERGED
}

enum IndividualRoleInHouseholdRole {
  NO_ROLE
  ALTERNATE
  PRIMARY
}

enum IndividualSex {
  MALE
  FEMALE
}

input IndividualUpdateDataObjectType {
  status: String
  fullName: String
  givenName: String
  middleName: String
  familyName: String
  sex: String
  birthDate: Date
  estimatedBirthDate: Boolean
  maritalStatus: String
  phoneNo: String
  phoneNoAlternative: String
  email: String
  relationship: String
  disability: String
  workStatus: String
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String
  hearingDisability: String
  physicalDisability: String
  memoryDisability: String
  selfcareDisability: String
  commsDisability: String
  whoAnswersPhone: String
  whoAnswersAltPhone: String
  role: String
  documents: [IndividualDocumentObjectType]
  documentsToRemove: [ID]
  documentsToEdit: [EditIndividualDocumentObjectType]
  identities: [IndividualIdentityObjectType]
  identitiesToRemove: [ID]
  identitiesToEdit: [EditIndividualIdentityObjectType]
  paymentChannels: [BankTransferObjectType]
  paymentChannelsToEdit: [EditBankTransferObjectType]
  paymentChannelsToRemove: [ID]
  preferredLanguage: String
  flexFields: Arg
  paymentDeliveryPhoneNo: String
  blockchainName: String
  walletAddress: String
  walletName: String
  deliveryMechanismData: [DeliveryMechanismDataObjectType]
  deliveryMechanismDataToEdit: [EditDeliveryMechanismDataObjectType]
  deliveryMechanismDataToRemove: [ID]
}

type InvalidPaymentVerificationPlan {
  paymentPlan: GenericPaymentPlanNode
}

input IssueTypeExtrasInput {
  householdDataUpdateIssueTypeExtras: HouseholdDataUpdateIssueTypeExtras
  individualDataUpdateIssueTypeExtras: IndividualDataUpdateIssueTypeExtras
  individualDeleteIssueTypeExtras: IndividualDeleteIssueTypeExtras
  householdDeleteIssueTypeExtras: HouseholdDeleteIssueTypeExtras
  addIndividualIssueTypeExtras: AddIndividualIssueTypeExtras
}

type IssueTypesObject {
  category: String
  label: String
  subCategories: [ChoiceObject]
}

scalar JSONString

type KoboAssetObject {
  id: String
  name: String
  sector: String
  country: String
  assetType: String
  dateModified: DateTime
  deploymentActive: Boolean
  hasDeployment: Boolean
  xlsLink: String
}

type KoboAssetObjectConnection {
  pageInfo: PageInfo!
  edges: [KoboAssetObjectEdge]!
  totalCount: Int
}

type KoboAssetObjectEdge {
  node: KoboAssetObject
  cursor: String!
}

type KoboErrorNode {
  header: String
  message: String
}

type KoboImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ImportDataStatus!
  businessAreaSlug: String!
  file: String
  dataType: ImportDataDataType!
  numberOfHouseholds: Int
  numberOfIndividuals: Int
  error: String!
  validationErrors: String!
  deliveryMechanismsValidationErrors: String!
  createdById: UUID
  importdataPtr: ImportDataNode!
  koboAssetId: String!
  onlyActiveSubmissions: Boolean!
  pullPictures: Boolean!
  koboValidationErrors: [KoboErrorNode]
}

type LabelNode {
  language: String
  label: String
}

type LanguageObject {
  english: String
  code: String
}

type LanguageObjectConnection {
  pageInfo: PageInfo!
  edges: [LanguageObjectEdge]!
  totalCount: Int
}

type LanguageObjectEdge {
  node: LanguageObject
  cursor: String!
}

type LockTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

enum LogEntryAction {
  CREATE
  UPDATE
  DELETE
  SOFT_DELETE
}

type LogEntryNode implements Node {
  id: ID!
  contentType: ContentTypeObjectType
  objectId: UUID
  action: LogEntryAction!
  objectRepr: String!
  changes: Arg
  user: UserNode
  businessArea: UserBusinessAreaNode
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  timestamp: DateTime
  isUserGenerated: Boolean
}

type LogEntryNodeConnection {
  pageInfo: PageInfo!
  edges: [LogEntryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type LogEntryNodeEdge {
  node: LogEntryNode
  cursor: String!
}

type MarkPaymentAsFailedMutation {
  payment: PaymentNode
}

type MarkPaymentRecordAsFailedMutation {
  paymentRecord: PaymentRecordNode
}

type MergeRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

enum MessageSamplingType {
  FULL_LIST
  RANDOM
}

type Mutations {
  createAccountabilityCommunicationMessage(input: CreateAccountabilityCommunicationMessageInput!): CreateCommunicationMessageMutation
  createFeedback(input: CreateFeedbackInput!): CreateFeedbackMutation
  updateFeedback(input: UpdateFeedbackInput!): UpdateFeedbackMutation
  createFeedbackMessage(input: CreateFeedbackMessageInput!): CreateFeedbackMessageMutation
  createSurvey(input: CreateSurveyInput!): CreateSurveyMutation
  exportSurveySample(surveyId: ID!): ExportSurveySampleMutationMutation
  createReport(reportData: CreateReportInput!): CreateReport
  restartCreateReport(reportData: RestartCreateReportInput!): RestartCreateReport
  createDashboardReport(reportData: CreateDashboardReportInput!): CreateDashboardReport
  createGrievanceTicket(input: CreateGrievanceTicketInput!): CreateGrievanceTicketMutation
  updateGrievanceTicket(input: UpdateGrievanceTicketInput!, version: BigInt): UpdateGrievanceTicketMutation
  grievanceStatusChange(grievanceTicketId: ID, status: Int, version: BigInt): GrievanceStatusChangeMutation
  createTicketNote(noteInput: CreateTicketNoteInput!, version: BigInt): CreateTicketNoteMutation
  approveIndividualDataChange(approvedDeliveryMechanismDataToCreate: [Int], approvedDeliveryMechanismDataToEdit: [Int], approvedDeliveryMechanismDataToRemove: [Int], approvedDocumentsToCreate: [Int], approvedDocumentsToEdit: [Int], approvedDocumentsToRemove: [Int], approvedIdentitiesToCreate: [Int], approvedIdentitiesToEdit: [Int], approvedIdentitiesToRemove: [Int], approvedPaymentChannelsToCreate: [Int], approvedPaymentChannelsToEdit: [Int], approvedPaymentChannelsToRemove: [Int], flexFieldsApproveData: JSONString, grievanceTicketId: ID!, individualApproveData: JSONString, version: BigInt): IndividualDataChangeApproveMutation
  approveHouseholdDataChange(flexFieldsApproveData: JSONString, grievanceTicketId: ID!, householdApproveData: JSONString, version: BigInt): HouseholdDataChangeApproveMutation
  approveAddIndividual(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveDeleteIndividual(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveDeleteHousehold(approveStatus: Boolean!, grievanceTicketId: ID!, reasonHhId: String, version: BigInt): DeleteHouseholdApproveMutation
  approveSystemFlagging(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveNeedsAdjudication(clearIndividualIds: [ID], distinctIndividualIds: [ID], duplicateIndividualIds: [ID], grievanceTicketId: ID!, selectedIndividualId: ID, version: BigInt): NeedsAdjudicationApproveMutation
  approvePaymentDetails(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): PaymentDetailsApproveMutation
  reassignRole(grievanceTicketId: ID!, householdId: ID!, householdVersion: BigInt, individualId: ID!, individualVersion: BigInt, newIndividualId: ID, role: String!, version: BigInt): ReassignRoleMutation
  bulkUpdateGrievanceAssignee(assignedTo: String!, businessAreaSlug: String!, grievanceTicketIds: [ID]!): BulkUpdateGrievanceTicketsAssigneesMutation
  bulkUpdateGrievancePriority(businessAreaSlug: String!, grievanceTicketIds: [ID]!, priority: Int!): BulkUpdateGrievanceTicketsPriorityMutation
  bulkUpdateGrievanceUrgency(businessAreaSlug: String!, grievanceTicketIds: [ID]!, urgency: Int!): BulkUpdateGrievanceTicketsUrgencyMutation
  bulkGrievanceAddNote(businessAreaSlug: String!, grievanceTicketIds: [ID]!, note: String!): BulkGrievanceAddNoteMutation
  createPaymentVerificationPlan(input: CreatePaymentVerificationInput!, version: BigInt): CreateVerificationPlanMutation
  editPaymentVerificationPlan(input: EditPaymentVerificationInput!, version: BigInt): EditPaymentVerificationMutation
  exportXlsxPaymentVerificationPlanFile(paymentVerificationPlanId: ID!): ExportXlsxPaymentVerificationPlanFile
  importXlsxPaymentVerificationPlanFile(file: Upload!, paymentVerificationPlanId: ID!): ImportXlsxPaymentVerificationPlanFile
  activatePaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): ActivatePaymentVerificationPlan
  finishPaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): FinishPaymentVerificationPlan
  discardPaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): DiscardPaymentVerificationPlan
  invalidPaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): InvalidPaymentVerificationPlan
  deletePaymentVerificationPlan(paymentVerificationPlanId: ID!, version: BigInt): DeletePaymentVerificationPlan
  updatePaymentVerificationStatusAndReceivedAmount(paymentVerificationId: ID!, receivedAmount: Decimal!, status: PaymentVerificationStatusForUpdate, version: BigInt): UpdatePaymentVerificationStatusAndReceivedAmount
  markPaymentRecordAsFailed(paymentRecordId: ID!): MarkPaymentRecordAsFailedMutation
  revertMarkPaymentRecordAsFailed(deliveredQuantity: Decimal!, deliveryDate: Date!, paymentRecordId: ID!): RevertMarkPaymentRecordAsFailedMutation
  markPaymentAsFailed(paymentId: ID!): MarkPaymentAsFailedMutation
  revertMarkPaymentAsFailed(deliveredQuantity: Decimal!, deliveryDate: Date!, paymentId: ID!): RevertMarkPaymentAsFailedMutation
  updatePaymentVerificationReceivedAndReceivedAmount(paymentVerificationId: ID!, received: Boolean!, receivedAmount: Decimal!, version: BigInt): UpdatePaymentVerificationReceivedAndReceivedAmount
  actionPaymentPlanMutation(input: ActionPaymentPlanInput!): ActionPaymentPlanMutation
  createPaymentPlan(input: CreatePaymentPlanInput!): CreatePaymentPlanMutation
  createFollowUpPaymentPlan(dispersionEndDate: Date!, dispersionStartDate: Date!, paymentPlanId: ID!): CreateFollowUpPaymentPlanMutation
  updatePaymentPlan(input: UpdatePaymentPlanInput!): UpdatePaymentPlanMutation
  deletePaymentPlan(paymentPlanId: ID!): DeletePaymentPlanMutation
  chooseDeliveryMechanismsForPaymentPlan(input: ChooseDeliveryMechanismsForPaymentPlanInput!): ChooseDeliveryMechanismsForPaymentPlanMutation
  assignFspToDeliveryMechanism(input: AssignFspToDeliveryMechanismInput!): AssignFspToDeliveryMechanismMutation
  splitPaymentPlan(paymentPlanId: ID!, paymentsNo: Int, splitType: String!): SplitPaymentPlanMutation
  exportXlsxPaymentPlanPaymentList(paymentPlanId: ID!): ExportXLSXPaymentPlanPaymentListMutation
  exportXlsxPaymentPlanPaymentListPerFsp(paymentPlanId: ID!): ExportXLSXPaymentPlanPaymentListPerFSPMutation
  importXlsxPaymentPlanPaymentList(file: Upload!, paymentPlanId: ID!): ImportXLSXPaymentPlanPaymentListMutation
  importXlsxPaymentPlanPaymentListPerFsp(file: Upload!, paymentPlanId: ID!): ImportXLSXPaymentPlanPaymentListPerFSPMutation
  setSteficonRuleOnPaymentPlanPaymentList(paymentPlanId: ID!, steficonRuleId: ID!): SetSteficonRuleOnPaymentPlanPaymentListMutation
  excludeHouseholds(excludedHouseholdsIds: [String]!, exclusionReason: String, paymentPlanId: ID!): ExcludeHouseholdsMutation
  exportPdfPaymentPlanSummary(paymentPlanId: ID!): ExportPDFPaymentPlanSummaryMutation
  createTargetPopulation(input: CreateTargetPopulationInput!): CreateTargetPopulationMutation
  updateTargetPopulation(input: UpdateTargetPopulationInput!, version: BigInt): UpdateTargetPopulationMutation
  copyTargetPopulation(input: CopyTargetPopulationMutationInput!): CopyTargetPopulationMutationPayload
  deleteTargetPopulation(input: DeleteTargetPopulationMutationInput!): DeleteTargetPopulationMutationPayload
  lockTargetPopulation(id: ID!, version: BigInt): LockTargetPopulationMutation
  unlockTargetPopulation(id: ID!, version: BigInt): UnlockTargetPopulationMutation
  finalizeTargetPopulation(id: ID!, version: BigInt): FinalizeTargetPopulationMutation
  setSteficonRuleOnTargetPopulation(input: SetSteficonRuleOnTargetPopulationMutationInput!): SetSteficonRuleOnTargetPopulationMutationPayload
  targetPopulationRebuild(id: ID!): RebuildTargetPopulationMutation
  createProgram(programData: CreateProgramInput!): CreateProgram
  updateProgram(programData: UpdateProgramInput, version: BigInt): UpdateProgram
  updateProgramPartners(programData: UpdateProgramPartnersInput, version: BigInt): UpdateProgramPartners
  deleteProgram(programId: String!): DeleteProgram
  copyProgram(programData: CopyProgramInput!): CopyProgram
  uploadImportDataXlsxFileAsync(businessAreaSlug: String!, file: Upload!): UploadImportDataXLSXFileAsync
  deleteRegistrationDataImport(registrationDataImportId: String!): DeleteRegistrationDataImport
  registrationXlsxImport(registrationDataImportData: RegistrationXlsxImportMutationInput!): RegistrationXlsxImportMutation
  registrationProgramPopulationImport(registrationDataImportData: RegistrationProgramPopulationImportMutationInput!): RegistrationProgramPopulationImportMutation
  registrationKoboImport(registrationDataImportData: RegistrationKoboImportMutationInput!): RegistrationKoboImportMutation
  saveKoboImportDataAsync(businessAreaSlug: String!, onlyActiveSubmissions: Boolean!, pullPictures: Boolean!, uid: Upload!): SaveKoboProjectImportDataAsync
  mergeRegistrationDataImport(id: ID!, version: BigInt): MergeRegistrationDataImportMutation
  refuseRegistrationDataImport(id: ID!, refuseReason: String, version: BigInt): RefuseRegistrationDataImportMutation
  rerunDedupe(registrationDataImportId: ID!, version: BigInt): RegistrationDeduplicationMutation
  eraseRegistrationDataImport(id: ID!, version: BigInt): EraseRegistrationDataImportMutation
  checkAgainstSanctionList(file: Upload!): CheckAgainstSanctionListMutation
}

type NeedsAdjudicationApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input NegativeFeedbackTicketExtras {
  household: ID
  individual: ID
}

interface Node {
  id: ID!
}

input PDUFieldInput {
  id: String
  label: String
  pduData: PeriodicFieldDataInput
}

type PDUSubtypeChoiceObject {
  value: String
  displayName: String
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PageInfoNode {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type PaginatedCashPlanAndPaymentPlanNode {
  pageInfo: PageInfoNode
  edges: [CashPlanAndPaymentPlanEdges]
  totalCount: Int
}

type PaginatedPaymentRecordsAndPaymentsNode {
  pageInfo: PageInfoNode
  edges: [PaymentRecordsAndPaymentsEdges]
  totalCount: Int
}

type PartnerNode {
  id: ID!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  name: String
  parent: PartnerNode
  isUn: Boolean!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  partnerSet: [PartnerNode!]!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserNodeConnection!
  individualIdentities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  areas: [AreaNode]
  areaAccess: String
}

type PartnerRoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  partner: PartnerNode!
  roles: [RoleNode!]!
}

type PartnerType {
  id: ID!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  name: String!
  parent: PartnerNode
  isUn: Boolean!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  partnerSet: [PartnerNode!]!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserNodeConnection!
  individualIdentities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
}

type PaymentConflictDataNode {
  paymentPlanId: String
  paymentPlanUnicefId: String
  paymentPlanStartDate: String
  paymentPlanEndDate: String
  paymentPlanStatus: String
  paymentId: String
  paymentUnicefId: String
}

enum PaymentDeliveryTypeChoice {
  CARDLESS_CASH_WITHDRAWAL
  CASH
  CASH_BY_FSP
  CHEQUE
  DEPOSIT_TO_CARD
  MOBILE_MONEY
  PRE_PAID_CARD
  REFERRAL
  TRANSFER
  TRANSFER_TO_ACCOUNT
  VOUCHER
  ATM_CARD
  CASH_OVER_THE_COUNTER
  TRANSFER_TO_DIGITAL_WALLET
}

type PaymentDetailsApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type PaymentHouseholdSnapshotNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  snapshotData: JSONString!
  householdId: UUID!
  payment: PaymentNode!
}

type PaymentNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  signatureHash: String!
  businessArea: UserBusinessAreaNode!
  status: PaymentStatus!
  statusDate: DateTime!
  household: HouseholdNode!
  headOfHousehold: IndividualNode
  deliveryTypeChoice: PaymentDeliveryTypeChoice
  deliveryType: DeliveryMechanismNode
  currency: String!
  entitlementQuantity: Float
  entitlementQuantityUsd: Float
  deliveredQuantity: Float
  deliveredQuantityUsd: Float
  deliveryDate: DateTime
  transactionReferenceId: String
  transactionStatusBlockchainLink: String
  parent: PaymentPlanNode!
  conflicted: Boolean!
  excluded: Boolean!
  entitlementDate: DateTime
  financialServiceProvider: FinancialServiceProviderNode
  collector: IndividualNode!
  sourcePayment: PaymentNode
  isFollowUp: Boolean!
  reasonForUnsuccessfulPayment: String
  program: ProgramNode
  orderNumber: Int
  tokenNumber: Int
  additionalCollectorName: String
  additionalDocumentType: String
  additionalDocumentNumber: String
  fspAuthCode: String
  followUps(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  householdSnapshot: PaymentHouseholdSnapshotNode
  adminUrl: String
  paymentPlanHardConflicted: Boolean
  paymentPlanHardConflictedData: [PaymentConflictDataNode]
  paymentPlanSoftConflicted: Boolean
  paymentPlanSoftConflictedData: [PaymentConflictDataNode]
  fullName: String
  targetPopulation: TargetPopulationNode
  verification: PaymentVerificationNode
  distributionModality: String
  serviceProvider: FinancialServiceProviderNode
  debitCardNumber: String
  debitCardIssuer: String
  totalPersonsCovered: Int
  snapshotCollectorFullName: String
  snapshotCollectorDeliveryPhoneNo: String
  snapshotCollectorBankName: String
  snapshotCollectorBankAccountNumber: String
  snapshotCollectorDebitCardNumber: String
}

type PaymentNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentNodeEdge {
  node: PaymentNode
  cursor: String!
}

enum PaymentPlanBackgroundActionStatus {
  RULE_ENGINE_RUN
  RULE_ENGINE_ERROR
  XLSX_EXPORTING
  XLSX_EXPORT_ERROR
  XLSX_IMPORT_ERROR
  XLSX_IMPORTING_ENTITLEMENTS
  XLSX_IMPORTING_RECONCILIATION
  EXCLUDE_BENEFICIARIES
  EXCLUDE_BENEFICIARIES_ERROR
  SEND_TO_PAYMENT_GATEWAY
  SEND_TO_PAYMENT_GATEWAY_ERROR
}

enum PaymentPlanCurrency {
  A_
  AED
  AFN
  ALL
  AMD
  ANG
  AOA
  ARS
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BHD
  BIF
  BMD
  BND
  BOB
  BOV
  BRL
  BSD
  BTN
  BWP
  BYN
  BZD
  CAD
  CDF
  CHF
  CLP
  CNY
  COP
  CRC
  CUC
  CUP
  CVE
  CZK
  DJF
  DKK
  DOP
  DZD
  EGP
  ERN
  ETB
  EUR
  FJD
  FKP
  GBP
  GEL
  GHS
  GIP
  GMD
  GNF
  GTQ
  GYD
  HKD
  HNL
  HRK
  HTG
  HUF
  IDR
  ILS
  INR
  IQD
  IRR
  ISK
  JMD
  JOD
  JPY
  KES
  KGS
  KHR
  KMF
  KPW
  KRW
  KWD
  KYD
  KZT
  LAK
  LBP
  LKR
  LRD
  LSL
  LYD
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRU
  MUR
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NIO
  NOK
  NPR
  NZD
  OMR
  PAB
  PEN
  PGK
  PHP
  PKR
  PLN
  PYG
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SDG
  SEK
  SGD
  SHP
  SLL
  SOS
  SRD
  SSP
  STN
  SVC
  SYP
  SZL
  THB
  TJS
  TMT
  TND
  TOP
  TRY
  TTD
  TWD
  TZS
  UAH
  UGX
  USD
  UYU
  UYW
  UZS
  VES
  VND
  VUV
  WST
  XAF
  XAG
  XAU
  XCD
  XOF
  XPF
  YER
  ZAR
  ZMW
  ZWL
  USDC
}

type PaymentPlanNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  businessArea: UserBusinessAreaNode!
  statusDate: DateTime!
  startDate: Date
  endDate: Date
  program: ProgramNode!
  exchangeRate: Float
  totalEntitledQuantity: Float
  totalEntitledQuantityUsd: Float
  totalEntitledQuantityRevised: Float
  totalEntitledQuantityRevisedUsd: Float
  totalDeliveredQuantity: Float
  totalDeliveredQuantityUsd: Float
  totalUndeliveredQuantity: Float
  totalUndeliveredQuantityUsd: Float
  programCycle: ProgramCycleNode
  createdBy: UserNode!
  status: PaymentPlanStatus!
  backgroundActionStatus: PaymentPlanBackgroundActionStatus
  targetPopulation: TargetPopulationNode!
  currency: PaymentPlanCurrency!
  dispersionStartDate: Date
  dispersionEndDate: Date
  femaleChildrenCount: Int!
  maleChildrenCount: Int!
  femaleAdultsCount: Int!
  maleAdultsCount: Int!
  totalHouseholdsCount: Int!
  totalIndividualsCount: Int!
  importedFileDate: DateTime
  steficonRule: RuleCommitNode
  steficonAppliedDate: DateTime
  sourcePaymentPlan: PaymentPlanNode
  isFollowUp: Boolean!
  exclusionReason: String!
  excludeHouseholdError: String!
  name: String
  followUps(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  deliveryMechanisms: [DeliveryMechanismPerPaymentPlanNode]
  paymentItems(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  approvalProcess(offset: Int, before: String, after: String, first: Int, last: Int): ApprovalProcessNodeConnection!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanSupportingDocumentNodeConnection!
  adminUrl: String
  currencyName: String
  hasPaymentListExportFile: Boolean
  hasFspDeliveryMechanismXlsxTemplate: Boolean
  importedFileName: String
  paymentsConflictsCount: Int
  volumeByDeliveryMechanism: [VolumeByDeliveryMechanismNode]
  splitChoices: [ChoiceObject]
  verificationPlans(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  paymentVerificationSummary: PaymentVerificationSummaryNode
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
  canCreatePaymentVerificationPlan: Boolean
  availablePaymentRecordsCount: Int
  reconciliationSummary: ReconciliationSummaryNode
  excludedHouseholds: [HouseholdNode]
  excludedIndividuals: [IndividualNode]
  canCreateFollowUp: Boolean
  totalWithdrawnHouseholdsCount: Int
  unsuccessfulPaymentsCount: Int
  canSendToPaymentGateway: Boolean
  canSplit: Boolean
  supportingDocuments: [PaymentPlanSupportingDocumentNode]
}

type PaymentPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentPlanNodeEdge {
  node: PaymentPlanNode
  cursor: String!
}

enum PaymentPlanStatus {
  PREPARING
  OPEN
  LOCKED
  LOCKED_FSP
  IN_APPROVAL
  IN_AUTHORIZATION
  IN_REVIEW
  ACCEPTED
  FINISHED
}

type PaymentPlanSupportingDocumentNode implements Node {
  id: ID!
  paymentPlan: PaymentPlanNode!
  title: String!
  file: String!
  uploadedAt: DateTime!
  createdBy: UserNode
}

type PaymentPlanSupportingDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentPlanSupportingDocumentNodeEdge]!
}

type PaymentPlanSupportingDocumentNodeEdge {
  node: PaymentPlanSupportingDocumentNode
  cursor: String!
}

type PaymentRecordAndPaymentNode {
  objType: String
  id: String
  caId: String
  status: String
  fullName: String
  parent: CashPlanAndPaymentPlanNode
  entitlementQuantity: Float
  deliveredQuantity: Float
  deliveredQuantityUsd: Float
  currency: String
  deliveryDate: String
  verification: PaymentVerificationNode
}

enum PaymentRecordDeliveryTypeChoice {
  CARDLESS_CASH_WITHDRAWAL
  CASH
  CASH_BY_FSP
  CHEQUE
  DEPOSIT_TO_CARD
  MOBILE_MONEY
  PRE_PAID_CARD
  REFERRAL
  TRANSFER
  TRANSFER_TO_ACCOUNT
  VOUCHER
  ATM_CARD
  CASH_OVER_THE_COUNTER
  TRANSFER_TO_DIGITAL_WALLET
}

enum PaymentRecordEntitlementCardStatus {
  ACTIVE
  INACTIVE
}

type PaymentRecordNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  businessArea: UserBusinessAreaNode!
  status: PaymentRecordStatus!
  statusDate: DateTime!
  household: HouseholdNode!
  headOfHousehold: IndividualNode
  deliveryTypeChoice: PaymentRecordDeliveryTypeChoice
  deliveryType: DeliveryMechanismNode
  currency: String!
  entitlementQuantity: Float
  entitlementQuantityUsd: Float
  deliveredQuantity: Float
  deliveredQuantityUsd: Float
  deliveryDate: DateTime
  transactionReferenceId: String
  transactionStatusBlockchainLink: String
  caId: String
  caHashId: UUID
  parent: CashPlanNode
  fullName: String!
  totalPersonsCovered: Int!
  distributionModality: String!
  targetPopulation: TargetPopulationNode!
  targetPopulationCashAssistId: String!
  entitlementCardNumber: String
  entitlementCardStatus: PaymentRecordEntitlementCardStatus
  entitlementCardIssueDate: Date
  visionId: String
  registrationCaId: String
  serviceProvider: ServiceProviderNode!
  adminUrl: String
  verification: PaymentVerificationNode
  unicefId: String
}

type PaymentRecordNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentRecordNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentRecordNodeEdge {
  node: PaymentRecordNode
  cursor: String!
}

enum PaymentRecordStatus {
  DISTRIBUTION_SUCCESSFUL
  NOT_DISTRIBUTED
  TRANSACTION_SUCCESSFUL
  TRANSACTION_ERRONEOUS
  FORCE_FAILED
  PARTIALLY_DISTRIBUTED
  PENDING
  SENT_TO_PAYMENT_GATEWAY
  SENT_TO_FSP
  MANUALLY_CANCELLED
}

type PaymentRecordsAndPaymentsEdges {
  cursor: String
  node: PaymentRecordAndPaymentNode
}

enum PaymentStatus {
  DISTRIBUTION_SUCCESSFUL
  NOT_DISTRIBUTED
  TRANSACTION_SUCCESSFUL
  TRANSACTION_ERRONEOUS
  FORCE_FAILED
  PARTIALLY_DISTRIBUTED
  PENDING
  SENT_TO_PAYMENT_GATEWAY
  SENT_TO_FSP
  MANUALLY_CANCELLED
}

type PaymentVerificationLogEntryNode implements Node {
  id: ID!
  contentType: ContentTypeObjectType
  objectId: UUID
  action: LogEntryAction!
  objectRepr: String!
  changes: Arg
  user: UserNode
  businessArea: UserBusinessAreaNode
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  timestamp: DateTime
  isUserGenerated: Boolean
  contentObject: PaymentVerificationPlanNode
}

type PaymentVerificationLogEntryNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationLogEntryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationLogEntryNodeEdge {
  node: PaymentVerificationLogEntryNode
  cursor: String!
}

type PaymentVerificationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  paymentVerificationPlan: PaymentVerificationPlanNode!
  paymentContentType: ContentTypeObjectType!
  paymentObjectId: UUID!
  status: PaymentVerificationStatus!
  statusDate: DateTime
  receivedAmount: Float
  sentToRapidPro: Boolean!
  ticketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPaymentVerificationDetailsNodeConnection!
  ticketDetail(offset: Int, before: String, after: String, first: Int, last: Int): TicketPaymentVerificationDetailsNodeConnection!
  adminUrl: String
  isManuallyEditable: Boolean
  payment: GenericPaymentNode
}

type PaymentVerificationNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationNodeEdge {
  node: PaymentVerificationNode
  cursor: String!
}

type PaymentVerificationPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  status: PaymentVerificationPlanStatus!
  paymentPlanContentType: ContentTypeObjectType!
  paymentPlanObjectId: UUID!
  sampling: PaymentVerificationPlanSampling!
  verificationChannel: PaymentVerificationPlanVerificationChannel!
  sampleSize: Int
  respondedCount: Int
  receivedCount: Int
  notReceivedCount: Int
  receivedWithProblemsCount: Int
  confidenceInterval: Float
  marginOfError: Float
  rapidProFlowId: String!
  rapidProFlowStartUuids: [String!]!
  ageFilter: AgeFilterObject
  excludedAdminAreasFilter: [String]
  sexFilter: String
  activationDate: DateTime
  completionDate: DateTime
  xlsxFileExporting: Boolean!
  xlsxFileImported: Boolean!
  error: String
  paymentRecordVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  adminUrl: String
  xlsxFileWasDownloaded: Boolean
  hasXlsxFile: Boolean
  paymentPlan: PaymentPlanNode
}

type PaymentVerificationPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationPlanNodeEdge {
  node: PaymentVerificationPlanNode
  cursor: String!
}

enum PaymentVerificationPlanSampling {
  FULL_LIST
  RANDOM
}

enum PaymentVerificationPlanStatus {
  ACTIVE
  FINISHED
  PENDING
  INVALID
  RAPID_PRO_ERROR
}

enum PaymentVerificationPlanVerificationChannel {
  MANUAL
  RAPIDPRO
  XLSX
}

enum PaymentVerificationStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

enum PaymentVerificationStatusForUpdate {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type PaymentVerificationSummaryNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: PaymentVerificationSummaryStatus!
  activationDate: DateTime
  completionDate: DateTime
  paymentPlanContentType: ContentTypeObjectType!
  paymentPlanObjectId: UUID!
}

type PaymentVerificationSummaryNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationSummaryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationSummaryNodeEdge {
  node: PaymentVerificationSummaryNode
  cursor: String!
}

enum PaymentVerificationSummaryStatus {
  ACTIVE
  FINISHED
  PENDING
}

input PeriodicFieldDataInput {
  subtype: String
  numberOfRounds: Int
  roundsNames: [String]
}

type PeriodicFieldDataNode {
  id: ID!
  subtype: PeriodicFieldDataSubtype!
  numberOfRounds: Int!
  roundsNames: [String!]!
}

enum PeriodicFieldDataSubtype {
  DATE
  DECIMAL
  STRING
  BOOL
}

type PeriodicFieldNode implements Node {
  name: String!
  pduData: PeriodicFieldDataNode
  label: JSONString!
  id: ID!
}

input PositiveFeedbackTicketExtras {
  household: ID
  individual: ID
}

type ProgramCycleNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  title: String
  status: ProgramCycleStatus!
  startDate: Date!
  endDate: Date
  program: ProgramNode!
  createdBy: UserNode
  paymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  totalDeliveredQuantityUsd: Float
  totalEntitledQuantityUsd: Float
  totalUndeliveredQuantityUsd: Float
}

type ProgramCycleNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramCycleNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramCycleNodeEdge {
  node: ProgramCycleNode
  cursor: String!
}

enum ProgramCycleStatus {
  DRAFT
  ACTIVE
  FINISHED
}

enum ProgramFrequencyOfPayments {
  ONE_OFF
  REGULAR
}

type ProgramNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  version: BigInt!
  name: String!
  status: ProgramStatus!
  startDate: Date!
  endDate: Date
  description: String!
  caId: String
  caHashId: String
  adminAreas(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  businessArea: UserBusinessAreaNode!
  budget: Decimal
  frequencyOfPayments: ProgramFrequencyOfPayments!
  sector: ProgramSector!
  scope: ProgramScope
  cashPlus: Boolean!
  populationGoal: Int!
  administrativeAreasOfImplementation: String!
  dataCollectingType: DataCollectingTypeNode
  isVisible: Boolean!
  householdCount: Int!
  individualCount: Int!
  programmeCode: String
  partnerAccess: ProgramPartnerAccess!
  partners: [PartnerNode]
  biometricDeduplicationEnabled: Boolean!
  deduplicationSetId: UUID
  pduFields: [PeriodicFieldNode]
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  registrationImports(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  cashplanSet(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  grievanceTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  targetpopulationSet(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  cycles(offset: Int, before: String, after: String, first: Int, last: Int, search: String, status: [String], startDate: Date, endDate: Date, totalDeliveredQuantityUsdFrom: Float, totalDeliveredQuantityUsdTo: Float, orderBy: String): ProgramCycleNodeConnection
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  activityLogs(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  adminUrl: String
  totalEntitledQuantity: Decimal
  totalDeliveredQuantity: Decimal
  totalUndeliveredQuantity: Decimal
  totalNumberOfHouseholds: Int
  totalNumberOfHouseholdsWithTpInProgram: Int
  isSocialWorkerProgram: Boolean
  targetPopulationsCount: Int
  canFinish: Boolean
}

type ProgramNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramNodeEdge {
  node: ProgramNode
  cursor: String!
}

enum ProgramPartnerAccess {
  ALL_PARTNERS_ACCESS
  NONE_PARTNERS_ACCESS
  SELECTED_PARTNERS_ACCESS
}

input ProgramPartnerThroughInput {
  partner: String
  areas: [String]
  areaAccess: String
}

enum ProgramScope {
  FOR_PARTNERS
  UNICEF
}

enum ProgramSector {
  CHILD_PROTECTION
  EDUCATION
  HEALTH
  MULTI_PURPOSE
  NUTRITION
  SOCIAL_POLICY
  WASH
}

enum ProgramStatus {
  ACTIVE
  DRAFT
  FINISHED
}

type Query {
  accountabilityCommunicationMessage(id: ID!): CommunicationMessageNode
  allAccountabilityCommunicationMessages(offset: Int, before: String, after: String, first: Int, last: Int, numberOfRecipients: Int, numberOfRecipients_Gte: Int, numberOfRecipients_Lte: Int, targetPopulation: ID, createdBy: ID, program: String, createdAtRange: String, title: String, body: String, samplingType: String, orderBy: String): CommunicationMessageNodeConnection
  allAccountabilityCommunicationMessageRecipients(offset: Int, before: String, after: String, first: Int, last: Int, messageId: String!, recipientId: String, fullName: String, phoneNo: String, sex: String, orderBy: String): CommunicationMessageRecipientMapNodeConnection
  accountabilityCommunicationMessageSampleSize(input: GetAccountabilityCommunicationMessageSampleSizeInput): GetCommunicationMessageSampleSizeNode
  feedback(id: ID!): FeedbackNode
  allFeedbacks(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, issueType: String, createdAtRange: String, createdBy: String, feedbackId: String, isActiveProgram: String, program: String, orderBy: String): FeedbackNodeConnection
  feedbackIssueTypeChoices: [ChoiceObject]
  survey(id: ID!): SurveyNode
  allSurveys(offset: Int, before: String, after: String, first: Int, last: Int, program: ID, targetPopulation: ID, businessArea: String, createdAtRange: String, search: String, createdBy: String, orderBy: String): SurveyNodeConnection
  recipients(offset: Int, before: String, after: String, first: Int, last: Int, survey: String!, orderBy: String): RecipientNodeConnection
  accountabilitySampleSize(input: AccountabilitySampleSizeInput): AccountabilitySampleSizeNode
  surveyCategoryChoices: [ChoiceObject]
  surveyAvailableFlows: [RapidProFlowNode]
  adminArea(id: ID!): AreaNode
  allAdminAreas(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Istartswith: String, businessArea: String, level: Int, parentId: String): AreaNodeConnection
  allAreasTree(businessArea: String!): [AreaTreeNode]
  allLogEntries(offset: Int, before: String, after: String, first: Int, last: Int, objectId: UUID, user: ID, businessArea: String!, search: String, module: String, userId: String, programId: String): LogEntryNodeConnection
  logEntryActionChoices: [ChoiceObject]
  report(id: ID!): ReportNode
  allReports(offset: Int, before: String, after: String, first: Int, last: Int, createdBy: ID, reportType: [String], status: [String], businessArea: String!, createdFrom: DateTime, createdTo: DateTime, orderBy: String): ReportNodeConnection
  reportTypesChoices: [ChoiceObject]
  reportStatusChoices: [ChoiceObject]
  dashboardReportTypesChoices(businessAreaSlug: String!): [ChoiceObject]
  dashboardYearsChoices(businessAreaSlug: String!): [String]
  sanctionListIndividual(id: ID!): SanctionListIndividualNode
  allSanctionListIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, fullName: String, fullName_Startswith: String, referenceNumber: String, orderBy: String): SanctionListIndividualNodeConnection
  ticketsByType(businessAreaSlug: String!): TicketByType
  ticketsByCategory(businessAreaSlug: String!): ChartDatasetNode
  ticketsByStatus(businessAreaSlug: String!): ChartDatasetNode
  ticketsByLocationAndCategory(businessAreaSlug: String!): ChartDetailedDatasetsNode
  grievanceTicket(id: ID!): GrievanceTicketNode
  allGrievanceTicket(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, id_Startswith: UUID, category: String, area: String, area_Startswith: String, assignedTo: ID, registrationDataImport: ID, admin2: ID, createdBy: ID, businessArea: String!, search: String, documentType: String, documentNumber: String, status: [String], fsp: String, cashPlan: String, createdAtRange: String, permissions: [String], issueType: String, scoreMin: String, scoreMax: String, household: String, preferredLanguage: String, priority: String, urgency: String, grievanceType: String, grievanceStatus: String, totalDays: Int, program: String, isActiveProgram: Boolean, isCrossArea: Boolean, admin1: ID, orderBy: String): GrievanceTicketNodeConnection
  crossAreaFilterAvailable: Boolean
  existingGrievanceTickets(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, businessArea: String!, category: String, issueType: String, household: ID, individual: ID, paymentRecord: [ID], permissions: [String], orderBy: String): GrievanceTicketNodeConnection
  allTicketNotes(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, ticket: UUID!): TicketNoteNodeConnection
  chartGrievances(businessAreaSlug: String!, year: Int!, administrativeArea: String): ChartGrievanceTicketsNode
  allAddIndividualsFieldsAttributes: [FieldAttributeNode]
  allEditHouseholdFieldsAttributes: [FieldAttributeNode]
  grievanceTicketStatusChoices: [ChoiceObject]
  grievanceTicketCategoryChoices: [ChoiceObject]
  grievanceTicketManualCategoryChoices: [ChoiceObject]
  grievanceTicketSystemCategoryChoices: [ChoiceObject]
  grievanceTicketIssueTypeChoices: [IssueTypesObject]
  grievanceTicketPriorityChoices: [ChoiceObjectInt]
  grievanceTicketUrgencyChoices: [ChoiceObjectInt]
  allSteficonRules(offset: Int, before: String, after: String, first: Int, last: Int, enabled: Boolean, deprecated: Boolean, type: String!): SteficonRuleNodeConnection
  payment(id: ID!): PaymentNode
  allPayments(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, paymentPlanId: String!, programId: String, orderBy: String): PaymentNodeConnection
  paymentRecord(id: ID!): PaymentRecordNode
  allPaymentRecords(offset: Int, before: String, after: String, first: Int, last: Int, parent: ID, household: ID, individual: String, businessArea: String, programId: String, orderBy: String): PaymentRecordNodeConnection
  allPaymentRecordsAndPayments(businessArea: String!, program: String, household: ID, orderBy: String, first: Int, last: Int, before: String, after: String): PaginatedPaymentRecordsAndPaymentsNode
  financialServiceProviderXlsxTemplate(id: ID!): FinancialServiceProviderXlsxTemplateNode
  allFinancialServiceProviderXlsxTemplates(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdBy: ID, orderBy: String): FinancialServiceProviderXlsxTemplateNodeConnection
  financialServiceProvider(id: ID!): FinancialServiceProviderNode
  allFinancialServiceProviders(offset: Int, before: String, after: String, first: Int, last: Int, createdBy: ID, name: String, visionVendorNumber: String, deliveryMechanisms: [String], distributionLimit: Float, communicationChannel: String, xlsxTemplates: [ID], orderBy: String): FinancialServiceProviderNodeConnection
  paymentRecordVerification(id: ID!): PaymentVerificationNode
  allPaymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int, paymentVerificationPlan: ID, status: String, paymentPlanId: String, search: String, businessArea: String!, verificationChannel: String, orderBy: String): PaymentVerificationNodeConnection
  paymentVerificationPlan(id: ID!): PaymentVerificationPlanNode
  allPaymentVerificationPlan(offset: Int, before: String, after: String, first: Int, last: Int, programId: String): PaymentVerificationPlanNodeConnection
  chartPaymentVerification(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartPaymentVerification
  chartPaymentVerificationForPeople(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartPaymentVerification
  chartVolumeByDeliveryMechanism(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartPayment(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  sectionTotalTransferred(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  tableTotalCashTransferredByAdministrativeArea(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String, order: String, orderBy: String): TableTotalCashTransferred
  tableTotalCashTransferredByAdministrativeAreaForPeople(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String, order: String, orderBy: String): TableTotalCashTransferredForPeople
  chartTotalTransferredCashByCountry(year: Int!): ChartDetailedDatasetsNode
  paymentRecordStatusChoices: [ChoiceObject]
  paymentRecordEntitlementCardStatusChoices: [ChoiceObject]
  paymentRecordDeliveryTypeChoices: [ChoiceObject]
  cashPlanVerificationStatusChoices: [ChoiceObject]
  cashPlanVerificationSamplingChoices: [ChoiceObject]
  cashPlanVerificationVerificationChannelChoices: [ChoiceObject]
  paymentVerificationStatusChoices: [ChoiceObject]
  allRapidProFlows(businessAreaSlug: String!): [RapidProFlow]
  sampleSize(input: GetCashplanVerificationSampleSizeInput): GetCashplanVerificationSampleSizeObject
  allPaymentVerificationLogEntries(offset: Int, before: String, after: String, first: Int, last: Int, objectId: UUID, user: ID, businessArea: String!, search: String, module: String, userId: String, programId: String, objectType: String): PaymentVerificationLogEntryNodeConnection
  paymentPlan(id: ID!): PaymentPlanNode
  allPaymentPlans(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], totalEntitledQuantityFrom: Float, totalEntitledQuantityTo: Float, dispersionStartDate: Date, dispersionEndDate: Date, isFollowUp: Boolean, sourcePaymentPlanId: String, program: String, programCycle: String, orderBy: String): PaymentPlanNodeConnection
  paymentPlanStatusChoices: [ChoiceObject]
  currencyChoices: [ChoiceObject]
  allDeliveryMechanisms: [ChoiceObject]
  paymentPlanBackgroundActionStatusChoices: [ChoiceObject]
  availableFspsForDeliveryMechanisms(input: AvailableFspsForDeliveryMechanismsInput): [FspChoices]
  allCashPlansAndPaymentPlans(businessArea: String!, program: String, search: String, serviceProvider: String, deliveryType: [String], verificationStatus: [String], startDateGte: String, endDateLte: String, orderBy: String, first: Int, last: Int, before: String, after: String, isPaymentVerificationPage: Boolean): PaginatedCashPlanAndPaymentPlanNode
  businessArea(businessAreaSlug: String!): BusinessAreaNode
  allBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, slug: String): BusinessAreaNodeConnection
  allFieldsAttributes(flexField: Boolean, businessAreaSlug: String, programId: String): [FieldAttributeNode]
  allPduFields(businessAreaSlug: String!, programId: String!): [FieldAttributeNode]
  allGroupsWithFields: [GroupAttributeNode]
  koboProject(uid: String!, businessAreaSlug: String!): KoboAssetObject
  allKoboProjects(businessAreaSlug: String!, onlyDeployed: Boolean, before: String, after: String, first: Int, last: Int): KoboAssetObjectConnection
  cashAssistUrlPrefix: String
  allLanguages(code: String, before: String, after: String, first: Int, last: Int): LanguageObjectConnection
  dataCollectingType(id: ID!): DataCollectingTypeNode
  dataCollectionTypeChoices: [DataCollectingTypeChoiceObject]
  pduSubtypeChoices: [PDUSubtypeChoiceObject]
  program(id: ID!): ProgramNode
  allPrograms(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], sector: [String], numberOfHouseholds: String, budget: String, startDate: Date, endDate: Date, name: String, numberOfHouseholdsWithTpInProgram: String, dataCollectingType: String, compatibleDct: Boolean, orderBy: String): ProgramNodeConnection
  chartProgrammesBySector(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  chartTotalTransferredByMonth(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  cashPlan(id: ID!): CashPlanNode
  allCashPlans(offset: Int, before: String, after: String, first: Int, last: Int, program: ID, assistanceThrough: String, assistanceThrough_Startswith: String, serviceProvider_FullName: String, serviceProvider_FullName_Startswith: String, startDate: DateTime, startDate_Lte: DateTime, startDate_Gte: DateTime, endDate: DateTime, endDate_Lte: DateTime, endDate_Gte: DateTime, businessArea: String, search: String, deliveryType: [String], verificationStatus: [String], orderBy: String): CashPlanNodeConnection
  programStatusChoices: [ChoiceObject]
  programCycleStatusChoices: [ChoiceObject]
  programFrequencyOfPaymentsChoices: [ChoiceObject]
  programSectorChoices: [ChoiceObject]
  programScopeChoices: [ChoiceObject]
  cashPlanStatusChoices: [ChoiceObject]
  dataCollectingTypeChoices: [ChoiceObject]
  allActivePrograms(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], sector: [String], numberOfHouseholds: String, budget: String, startDate: Date, endDate: Date, name: String, numberOfHouseholdsWithTpInProgram: String, dataCollectingType: String, compatibleDct: Boolean, orderBy: String): ProgramNodeConnection
  programCycle(id: ID!): ProgramCycleNode
  canRunDeduplication: Boolean
  isDeduplicationDisabled: Boolean
  targetPopulation(id: ID!): TargetPopulationNode
  allTargetPopulation(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection
  targetPopulationHouseholds(targetPopulation: ID!, offset: Int, before: String, after: String, first: Int, last: Int, orderBy: String, businessArea: String): HouseholdNodeConnection
  targetPopulationStatusChoices: [ChoiceObject]
  allActiveTargetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection
  household(id: ID!): HouseholdNode
  allHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, address: String, address_Startswith: String, headOfHousehold_FullName: String, headOfHousehold_FullName_Startswith: String, size_Range: [Int], size_Lte: Int, size_Gte: Int, adminArea: ID, admin1: ID, admin2: ID, targetPopulations: [ID], residenceStatus: String, withdrawn: Boolean, program: ID, size: String, search: String, documentType: String, documentNumber: String, headOfHousehold_PhoneNoValid: Boolean, lastRegistrationDate: String, countryOrigin: String, isActiveProgram: Boolean, orderBy: String): HouseholdNodeConnection
  individual(id: ID!): IndividualNode
  allIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household_Id: UUID, businessArea: String, fullName: String, fullName_Startswith: String, fullName_Endswith: String, sex: [String], household_AdminArea: ID, withdrawn: Boolean, program: ID, age: String, programs: [ID], search: String, documentType: String, documentNumber: String, lastRegistrationDate: String, admin1: [ID], admin2: [ID], status: [String], excludedId: String, flags: [String], isActiveProgram: Boolean, orderBy: String): IndividualNodeConnection
  allMergedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, rdiId: String, orderBy: String): HouseholdNodeConnection
  allMergedIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household: ID, rdiId: String, duplicatesOnly: Boolean, businessArea: String, orderBy: String): IndividualNodeConnection
  sectionHouseholdsReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionIndividualsReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionPeopleReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionChildReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  chartIndividualsReachedByAgeAndGender(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartPeopleReachedByAgeAndGender(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartIndividualsWithDisabilityReachedByAge(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  chartPeopleWithDisabilityReachedByAge(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  residenceStatusChoices: [ChoiceObject]
  sexChoices: [ChoiceObject]
  maritalStatusChoices: [ChoiceObject]
  workStatusChoices: [ChoiceObject]
  relationshipChoices: [ChoiceObject]
  roleChoices: [ChoiceObject]
  documentTypeChoices: [ChoiceObject]
  identityTypeChoices: [ChoiceObject]
  countriesChoices: [ChoiceObject]
  observedDisabilityChoices: [ChoiceObject]
  severityOfDisabilityChoices: [ChoiceObject]
  flagChoices: [ChoiceObject]
  allHouseholdsFlexFieldsAttributes: [FieldAttributeNode]
  allIndividualsFlexFieldsAttributes: [FieldAttributeNode]
  me: UserNode
  allUsers(offset: Int, before: String, after: String, first: Int, last: Int, status: [String], partner: [String], businessArea: String!, program: String, search: String, roles: [String], isTicketCreator: Boolean, isSurveyCreator: Boolean, isMessageCreator: Boolean, isFeedbackCreator: Boolean, orderBy: String): UserNodeConnection
  userRolesChoices: [RoleChoiceObject]
  userStatusChoices: [ChoiceObject]
  userPartnerChoices: [ChoiceObject]
  partnerForGrievanceChoices(householdId: ID, individualId: ID): [ChoiceObject]
  hasAvailableUsersToExport(businessAreaSlug: String!): Boolean
  importedHousehold(id: ID!): ImportedHouseholdNode
  allImportedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, rdiId: String, businessArea: String, orderBy: String): ImportedHouseholdNodeConnection
  registrationDataImportDatahub(id: ID!): RegistrationDataImportDatahubNode
  importedIndividual(id: ID!): ImportedIndividualNode
  allImportedIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household: ID, rdiId: String, duplicatesOnly: Boolean, businessArea: String, orderBy: String): ImportedIndividualNodeConnection
  importData(id: ID!): ImportDataNode
  koboImportData(id: ID!): KoboImportDataNode
  deduplicationBatchStatusChoices: [ChoiceObject]
  deduplicationGoldenRecordStatusChoices: [ChoiceObject]
  registrationDataImport(id: ID!): RegistrationDataImportNode
  allRegistrationDataImports(offset: Int, before: String, after: String, first: Int, last: Int, importedBy_Id: UUID, importDate: Date, status: String, name: String, name_Startswith: String, businessArea: String, importDateRange: String, size: String, program: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, orderBy: String): RegistrationDataImportNodeConnection
  registrationDataStatusChoices: [ChoiceObject]
  _debug: DjangoDebug
}

input RandomSamplingArguments {
  confidenceInterval: Float!
  marginOfError: Float!
  excludedAdminAreas: [String]
  age: AgeInput
  sex: String
}

input RapidProArguments {
  flowId: String!
}

type RapidProFlow {
  id: String
  name: String
  type: String
  archived: Boolean
  labels: [String]
  expires: Int
  runs: [RapidProFlowRun]
  results: [RapidProFlowResult]
  createdOn: DateTime
  modifiedOn: DateTime
}

type RapidProFlowNode {
  id: String
  name: String
}

type RapidProFlowResult {
  key: String
  name: String
  categories: [String]
  nodeUuids: [String]
}

type RapidProFlowRun {
  active: Int
  completed: Int
  interrupted: Int
  expired: Int
}

type ReassignRoleMutation {
  household: HouseholdNode
  individual: IndividualNode
}

type RebuildTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

type RecipientNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode
}

type RecipientNodeConnection {
  pageInfo: PageInfo!
  edges: [RecipientNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RecipientNodeEdge {
  node: RecipientNode
  cursor: String!
}

type ReconciliationSummaryNode {
  deliveredFully: Int
  deliveredPartially: Int
  notDelivered: Int
  unsuccessful: Int
  pending: Int
  forceFailed: Int
  numberOfPayments: Int
  reconciled: Int
}

input ReferralTicketExtras {
  household: ID
  individual: ID
}

type RefuseRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

enum RegistrationDataImportDataSource {
  XLS
  KOBO
  FLEX_REGISTRATION
  API
  EDOPOMOGA
  PROGRAM_POPULATION
  ENROLL_FROM_PROGRAM
}

enum RegistrationDataImportDatahubImportDone {
  LOADING
  NOT_STARTED
  STARTED
  DONE
}

type RegistrationDataImportDatahubNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  importDate: DateTime!
  hctId: UUID
  importData: ImportDataNode
  importDone: RegistrationDataImportDatahubImportDone!
  businessAreaSlug: String!
}

enum RegistrationDataImportDeduplicationEngineStatus {
  PENDING
  UPLOADED
  IN_PROGRESS
  FINISHED
  ERROR
  UPLOAD_ERROR
}

type RegistrationDataImportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  name: String!
  status: RegistrationDataImportStatus!
  importDate: DateTime!
  importedBy: UserNode
  dataSource: RegistrationDataImportDataSource!
  numberOfIndividuals: Int!
  numberOfHouseholds: Int!
  batchDuplicates: Int!
  batchPossibleDuplicates: Int!
  batchUnique: Int!
  goldenRecordDuplicates: Int!
  goldenRecordPossibleDuplicates: Int!
  goldenRecordUnique: Int!
  dedupEngineBatchDuplicates: Int!
  dedupEngineGoldenRecordDuplicates: Int!
  datahubId: UUID
  errorMessage: String!
  sentryId: String
  pullPictures: Boolean!
  businessArea: UserBusinessAreaNode
  screenBeneficiary: Boolean!
  excluded: Boolean!
  program: ProgramNode
  erased: Boolean!
  refuseReason: String
  allowDeliveryMechanismsValidationErrors: Boolean!
  importData: ImportDataNode
  deduplicationEngineStatus: RegistrationDataImportDeduplicationEngineStatus
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  adminUrl: String
  batchDuplicatesCountAndPercentage: [CountAndPercentageNode]
  batchUniqueCountAndPercentage: [CountAndPercentageNode]
  goldenRecordDuplicatesCountAndPercentage: [CountAndPercentageNode]
  goldenRecordPossibleDuplicatesCountAndPercentage: [CountAndPercentageNode]
  goldenRecordUniqueCountAndPercentage: [CountAndPercentageNode]
  totalHouseholdsCountWithValidPhoneNo: Int
  biometricDeduplicated: String
  canMerge: Boolean
  biometricDeduplicationEnabled: Boolean
}

type RegistrationDataImportNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportNodeEdge {
  node: RegistrationDataImportNode
  cursor: String!
}

enum RegistrationDataImportStatus {
  LOADING
  DEDUPLICATION
  DEDUPLICATION_FAILED
  IMPORT_SCHEDULED
  IMPORTING
  IMPORT_ERROR
  IN_REVIEW
  MERGE_SCHEDULED
  MERGED
  MERGING
  MERGE_ERROR
  REFUSED
}

type RegistrationDeduplicationMutation {
  ok: Boolean
}

type RegistrationKoboImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationKoboImportMutationInput {
  importDataId: String
  name: String
  pullPictures: Boolean
  businessAreaSlug: String
  screenBeneficiary: Boolean
  allowDeliveryMechanismsValidationErrors: Boolean
}

type RegistrationProgramPopulationImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationProgramPopulationImportMutationInput {
  importFromProgramId: String
  name: String
  businessAreaSlug: String
  screenBeneficiary: Boolean
}

type RegistrationXlsxImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationXlsxImportMutationInput {
  importDataId: ID
  name: String
  businessAreaSlug: String
  screenBeneficiary: Boolean
  allowDeliveryMechanismsValidationErrors: Boolean
}

type ReportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  file: String
  createdBy: UserNode!
  status: Int!
  reportType: Int!
  dateFrom: Date!
  dateTo: Date!
  numberOfRecords: Int
  program: ProgramNode
  adminArea(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  fileUrl: String
  adminArea1(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection
  adminArea2(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection
}

type ReportNodeConnection {
  pageInfo: PageInfo!
  edges: [ReportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ReportNodeEdge {
  node: ReportNode
  cursor: String!
}

type RestartCreateReport {
  report: ReportNode
}

input RestartCreateReportInput {
  reportId: ID!
  businessAreaSlug: String!
}

type RevertMarkPaymentAsFailedMutation {
  payment: PaymentNode
}

type RevertMarkPaymentRecordAsFailedMutation {
  paymentRecord: PaymentRecordNode
}

type RoleChoiceObject {
  name: String
  value: String
  subsystem: String
}

type RoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  subsystem: RoleSubsystem!
  permissions: [String!]
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  userRoles: [UserRoleNode!]!
}

enum RoleSubsystem {
  HOPE
  KOBO
  CA
  API
}

enum RuleCommitLanguage {
  PYTHON
}

type RuleCommitNode implements Node {
  id: ID!
  timestamp: DateTime!
  rule: SteficonRuleNode
  updatedBy: UserNode
  definition: String!
  isRelease: Boolean!
  enabled: Boolean!
  deprecated: Boolean!
  language: RuleCommitLanguage!
  affectedFields: [String!]!
  before: JSONString!
  after: JSONString!
  paymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
}

type RuleCommitNodeConnection {
  pageInfo: PageInfo!
  edges: [RuleCommitNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RuleCommitNodeEdge {
  node: RuleCommitNode
  cursor: String!
}

enum RuleLanguage {
  PYTHON
}

enum RuleSecurity {
  A_0
  A_2
  A_4
}

enum RuleType {
  PAYMENT_PLAN
  TARGETING
}

enum SamplingChoices {
  FULL_LIST
  RANDOM
}

type SanctionListIndividualAliasNameNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type SanctionListIndividualAliasNameNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualAliasNameNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualAliasNameNodeEdge {
  node: SanctionListIndividualAliasNameNode
  cursor: String!
}

type SanctionListIndividualCountriesNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: String
}

type SanctionListIndividualCountriesNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualCountriesNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualCountriesNodeEdge {
  node: SanctionListIndividualCountriesNode
  cursor: String!
}

type SanctionListIndividualDateOfBirthNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  date: Date!
}

type SanctionListIndividualDateOfBirthNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualDateOfBirthNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualDateOfBirthNodeEdge {
  node: SanctionListIndividualDateOfBirthNode
  cursor: String!
}

type SanctionListIndividualDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  typeOfDocument: String!
  dateOfIssue: String
  issuingCountry: String
  note: String!
}

type SanctionListIndividualDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualDocumentNodeEdge {
  node: SanctionListIndividualDocumentNode
  cursor: String!
}

type SanctionListIndividualNationalitiesNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  nationality: String
}

type SanctionListIndividualNationalitiesNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualNationalitiesNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualNationalitiesNodeEdge {
  node: SanctionListIndividualNationalitiesNode
  cursor: String!
}

type SanctionListIndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  dataId: Int!
  versionNum: Int!
  firstName: String!
  secondName: String!
  thirdName: String!
  fourthName: String!
  fullName: String!
  nameOriginalScript: String!
  unListType: String!
  referenceNumber: String!
  listedOn: DateTime!
  comments: String!
  designation: String!
  listType: String!
  street: String!
  city: String!
  stateProvince: String!
  addressNote: String!
  countryOfBirth: String
  active: Boolean!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualDocumentNodeConnection!
  nationalities(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualNationalitiesNodeConnection!
  countries(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualCountriesNodeConnection!
  aliasNames(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualAliasNameNodeConnection!
  datesOfBirth(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualDateOfBirthNodeConnection!
}

type SanctionListIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualNodeEdge {
  node: SanctionListIndividualNode
  cursor: String!
}

type SaveKoboProjectImportDataAsync {
  importData: KoboImportDataNode
}

type SectionTotalNode {
  total: Float
}

input SensitiveGrievanceTicketExtras {
  household: ID
  individual: ID
  paymentRecord: [ID]
}

type ServiceProviderNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  caId: String!
  fullName: String
  shortName: String
  country: String!
  visionId: String
  cashPlans(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
}

type ServiceProviderNodeConnection {
  pageInfo: PageInfo!
  edges: [ServiceProviderNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ServiceProviderNodeEdge {
  node: ServiceProviderNode
  cursor: String!
}

type SetSteficonRuleOnPaymentPlanPaymentListMutation {
  paymentPlan: PaymentPlanNode
}

input SetSteficonRuleOnTargetPopulationMutationInput {
  targetId: ID!
  steficonRuleId: ID
  version: BigInt
  clientMutationId: String
}

type SetSteficonRuleOnTargetPopulationMutationPayload {
  targetPopulation: TargetPopulationNode
  clientMutationId: String
}

type SimpleApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type SplitPaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type SteficonRuleNode implements Node {
  id: ID!
  allowedBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  name: String!
  definition: String!
  description: String
  enabled: Boolean!
  deprecated: Boolean!
  language: RuleLanguage!
  security: RuleSecurity!
  createdBy: UserNode
  updatedBy: UserNode
  createdAt: DateTime!
  updatedAt: DateTime!
  type: RuleType!
  flags: JSONString!
  history(offset: Int, before: String, after: String, first: Int, last: Int): RuleCommitNodeConnection!
}

type SteficonRuleNodeConnection {
  pageInfo: PageInfo!
  edges: [SteficonRuleNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SteficonRuleNodeEdge {
  node: SteficonRuleNode
  cursor: String!
}

enum SurveyCategory {
  RAPID_PRO
  SMS
  MANUAL
}

type SurveyNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  title: String!
  body: String!
  category: SurveyCategory!
  numberOfRecipients: Int!
  createdBy: UserNode
  recipients(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  targetPopulation: TargetPopulationNode
  program: ProgramNode
  businessArea: UserBusinessAreaNode!
  sampleFile: String
  sampleFileGeneratedAt: DateTime
  samplingType: SurveySamplingType!
  fullListArguments: JSONString!
  randomSamplingArguments: JSONString!
  sampleSize: Int!
  flowId: String
  successfulRapidProCalls: [JSONString!]!
  adminUrl: String
  sampleFilePath: String
  hasValidSampleFile: Boolean
  rapidProUrl: String
}

type SurveyNodeConnection {
  pageInfo: PageInfo!
  edges: [SurveyNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SurveyNodeEdge {
  node: SurveyNode
  cursor: String!
}

enum SurveySamplingType {
  FULL_LIST
  RANDOM
}

type TableTotalCashTransferred {
  data: [_TableTotalCashTransferredDataNode]
}

type TableTotalCashTransferredForPeople {
  data: [_TableTotalCashTransferredDataForPeopleNode]
}

enum TargetPopulationBuildStatus {
  PENDING
  BUILDING
  FAILED
  OK
}

type TargetPopulationNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  name: String!
  caId: String
  caHashId: String
  createdBy: UserNode
  changeDate: DateTime
  changedBy: UserNode
  finalizedAt: DateTime
  finalizedBy: UserNode
  businessArea: UserBusinessAreaNode
  status: TargetPopulationStatus!
  buildStatus: TargetPopulationBuildStatus!
  builtAt: DateTime
  households(offset: Int, before: String, after: String, first: Int, last: Int, orderBy: String, businessArea: String): HouseholdNodeConnection
  program: ProgramNode
  programCycle: ProgramCycleNode
  targetingCriteria: TargetingCriteriaNode
  sentToDatahub: Boolean!
  steficonRule: RuleCommitNode
  steficonAppliedDate: DateTime
  vulnerabilityScoreMin: Float
  vulnerabilityScoreMax: Float
  excludedIds: String!
  exclusionReason: String!
  totalHouseholdsCount: Int
  totalIndividualsCount: Int
  childMaleCount: Int
  childFemaleCount: Int
  adultMaleCount: Int
  adultFemaleCount: Int
  paymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  paymentRecords(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  selections: [HouseholdSelectionNode!]!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  adminUrl: String
  totalFamilySize: Int
  householdList(offset: Int, before: String, after: String, first: Int, last: Int, orderBy: String, businessArea: String): HouseholdNodeConnection
  totalHouseholdsCountWithValidPhoneNo: Int
  hasEmptyCriteria: Boolean
  hasEmptyIdsCriteria: Boolean
}

type TargetPopulationNodeConnection {
  pageInfo: PageInfo!
  edges: [TargetPopulationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TargetPopulationNodeEdge {
  node: TargetPopulationNode
  cursor: String!
}

enum TargetPopulationStatus {
  OPEN
  LOCKED
  STEFICON_WAIT
  STEFICON_RUN
  STEFICON_COMPLETED
  STEFICON_ERROR
  PROCESSING
  SENDING_TO_CASH_ASSIST
  READY_FOR_CASH_ASSIST
  READY_FOR_PAYMENT_MODULE
  ASSIGNED
}

type TargetingCriteriaNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  flagExcludeIfActiveAdjudicationTicket: Boolean!
  flagExcludeIfOnSanctionList: Boolean!
  householdIds: String!
  individualIds: String!
  targetPopulation: TargetPopulationNode
  rules: [TargetingCriteriaRuleNode]
}

input TargetingCriteriaObjectType {
  rules: [TargetingCriteriaRuleObjectType]
  flagExcludeIfActiveAdjudicationTicket: Boolean
  flagExcludeIfOnSanctionList: Boolean
  householdIds: String
  individualIds: String
}

enum TargetingCriteriaRuleFilterComparisonMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
  IS_NULL
}

enum TargetingCriteriaRuleFilterFlexFieldClassification {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

type TargetingCriteriaRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  flexFieldClassification: TargetingCriteriaRuleFilterFlexFieldClassification!
  fieldName: String!
  arguments: [Arg]
  roundNumber: Int
  fieldAttribute: FieldAttributeNode
}

input TargetingCriteriaRuleFilterObjectType {
  comparisonMethod: String!
  flexFieldClassification: FlexFieldClassificationChoices!
  fieldName: String!
  arguments: [Arg]!
  roundNumber: Int
}

type TargetingCriteriaRuleNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteria: TargetingCriteriaNode!
  individualsFiltersBlocks: [TargetingIndividualRuleFilterBlockNode]
  filters: [TargetingCriteriaRuleFilterNode]
}

input TargetingCriteriaRuleObjectType {
  filters: [TargetingCriteriaRuleFilterObjectType]
  individualsFiltersBlocks: [TargetingIndividualRuleFilterBlockObjectType]
}

enum TargetingIndividualBlockRuleFilterComparisonMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
  IS_NULL
}

enum TargetingIndividualBlockRuleFilterFlexFieldClassification {
  NOT_FLEX_FIELD
  FLEX_FIELD_BASIC
  FLEX_FIELD_PDU
}

type TargetingIndividualBlockRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod!
  individualsFiltersBlock: TargetingIndividualRuleFilterBlockNode!
  flexFieldClassification: TargetingIndividualBlockRuleFilterFlexFieldClassification!
  fieldName: String!
  arguments: [Arg]
  roundNumber: Int
  fieldAttribute: FieldAttributeNode
}

type TargetingIndividualRuleFilterBlockNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  targetOnlyHoh: Boolean!
  individualBlockFilters: [TargetingIndividualBlockRuleFilterNode]
}

input TargetingIndividualRuleFilterBlockObjectType {
  individualBlockFilters: [TargetingCriteriaRuleFilterObjectType]
}

type TicketAddIndividualDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individualData: Arg
  approveStatus: Boolean!
}

type TicketAddIndividualDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketAddIndividualDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketAddIndividualDetailsNodeEdge {
  node: TicketAddIndividualDetailsNode
  cursor: String!
}

type TicketByType {
  userGeneratedCount: Int
  systemGeneratedCount: Int
  closedUserGeneratedCount: Int
  closedSystemGeneratedCount: Int
  userGeneratedAvgResolution: Float
  systemGeneratedAvgResolution: Float
}

type TicketComplaintDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentContentType: ContentTypeObjectType
  paymentObjectId: UUID
  household: HouseholdNode
  individual: IndividualNode
  paymentRecord: PaymentRecordAndPaymentNode
}

type TicketComplaintDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketComplaintDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketComplaintDetailsNodeEdge {
  node: TicketComplaintDetailsNode
  cursor: String!
}

type TicketDeleteHouseholdDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  roleReassignData: JSONString!
  approveStatus: Boolean!
  reasonHousehold: HouseholdNode
  householdData: Arg
}

type TicketDeleteHouseholdDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketDeleteHouseholdDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketDeleteHouseholdDetailsNodeEdge {
  node: TicketDeleteHouseholdDetailsNode
  cursor: String!
}

type TicketDeleteIndividualDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode
  roleReassignData: JSONString!
  approveStatus: Boolean!
  individualData: Arg
}

type TicketDeleteIndividualDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketDeleteIndividualDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketDeleteIndividualDetailsNodeEdge {
  node: TicketDeleteIndividualDetailsNode
  cursor: String!
}

type TicketHouseholdDataUpdateDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  householdData: Arg
}

type TicketHouseholdDataUpdateDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketHouseholdDataUpdateDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketHouseholdDataUpdateDetailsNodeEdge {
  node: TicketHouseholdDataUpdateDetailsNode
  cursor: String!
}

type TicketIndividualDataUpdateDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode
  individualData: Arg
  roleReassignData: JSONString!
}

type TicketIndividualDataUpdateDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketIndividualDataUpdateDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketIndividualDataUpdateDetailsNodeEdge {
  node: TicketIndividualDataUpdateDetailsNode
  cursor: String!
}

type TicketNeedsAdjudicationDetailsExtraDataNode {
  goldenRecords: [DeduplicationResultNode]
  possibleDuplicate: [DeduplicationResultNode]
  dedupEngineSimilarityPair: DeduplicationEngineSimilarityPairNode
}

type TicketNeedsAdjudicationDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isMultipleDuplicatesVersion: Boolean!
  goldenRecordsIndividual: IndividualNode!
  possibleDuplicates: [IndividualNode]
  selectedDistinct: [IndividualNode]
  selectedIndividuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  roleReassignData: JSONString!
  extraData: TicketNeedsAdjudicationDetailsExtraDataNode
  scoreMin: Float!
  scoreMax: Float!
  isCrossArea: Boolean!
  selectedIndividual: IndividualNode
  possibleDuplicate: IndividualNode
  hasDuplicatedDocument: Boolean
  selectedDuplicates: [IndividualNode]
}

type TicketNeedsAdjudicationDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNeedsAdjudicationDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNeedsAdjudicationDetailsNodeEdge {
  node: TicketNeedsAdjudicationDetailsNode
  cursor: String!
}

type TicketNegativeFeedbackDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketNegativeFeedbackDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNegativeFeedbackDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNegativeFeedbackDetailsNodeEdge {
  node: TicketNegativeFeedbackDetailsNode
  cursor: String!
}

type TicketNoteNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  createdBy: UserNode
}

type TicketNoteNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNoteNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNoteNodeEdge {
  node: TicketNoteNode
  cursor: String!
}

input TicketPaymentVerificationDetailsExtras {
  newReceivedAmount: Float
  newStatus: String
}

enum TicketPaymentVerificationDetailsNewStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type TicketPaymentVerificationDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus!
  paymentVerification: PaymentVerificationNode
  newStatus: TicketPaymentVerificationDetailsNewStatus
  oldReceivedAmount: Float
  newReceivedAmount: Float
  approveStatus: Boolean!
  hasMultiplePaymentVerifications: Boolean
}

type TicketPaymentVerificationDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketPaymentVerificationDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketPaymentVerificationDetailsNodeEdge {
  node: TicketPaymentVerificationDetailsNode
  cursor: String!
}

enum TicketPaymentVerificationDetailsPaymentVerificationStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type TicketPositiveFeedbackDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketPositiveFeedbackDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketPositiveFeedbackDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketPositiveFeedbackDetailsNodeEdge {
  node: TicketPositiveFeedbackDetailsNode
  cursor: String!
}

type TicketReferralDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketReferralDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketReferralDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketReferralDetailsNodeEdge {
  node: TicketReferralDetailsNode
  cursor: String!
}

type TicketSensitiveDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentContentType: ContentTypeObjectType
  paymentObjectId: UUID
  household: HouseholdNode
  individual: IndividualNode
  paymentRecord: PaymentRecordAndPaymentNode
}

type TicketSensitiveDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketSensitiveDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketSensitiveDetailsNodeEdge {
  node: TicketSensitiveDetailsNode
  cursor: String!
}

type TicketSystemFlaggingDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  goldenRecordsIndividual: IndividualNode!
  sanctionListIndividual: SanctionListIndividualNode!
  approveStatus: Boolean!
  roleReassignData: JSONString!
}

type TicketSystemFlaggingDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketSystemFlaggingDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketSystemFlaggingDetailsNodeEdge {
  node: TicketSystemFlaggingDetailsNode
  cursor: String!
}

scalar UUID

type UnlockTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

input UpdateAddIndividualIssueTypeExtras {
  individualData: AddIndividualDataObjectType!
}

input UpdateFeedbackInput {
  feedbackId: ID!
  issueType: String
  householdLookup: ID
  individualLookup: ID
  description: String
  comments: String
  admin2: ID
  area: String
  language: String
  consent: Boolean
  program: ID
}

type UpdateFeedbackMutation {
  feedback: FeedbackNode
}

input UpdateGrievanceTicketExtrasInput {
  householdDataUpdateIssueTypeExtras: UpdateHouseholdDataUpdateIssueTypeExtras
  individualDataUpdateIssueTypeExtras: UpdateIndividualDataUpdateIssueTypeExtras
  addIndividualIssueTypeExtras: UpdateAddIndividualIssueTypeExtras
  category: CategoryExtrasInput
  ticketPaymentVerificationDetailsExtras: TicketPaymentVerificationDetailsExtras
}

input UpdateGrievanceTicketInput {
  ticketId: ID!
  description: String
  assignedTo: ID
  admin: ID
  area: String
  language: String
  linkedTickets: [ID]
  household: ID
  individual: ID
  paymentRecord: ID
  extras: UpdateGrievanceTicketExtrasInput
  priority: Int
  urgency: Int
  partner: Int
  program: ID
  comments: String
  documentation: [GrievanceDocumentInput]
  documentationToUpdate: [GrievanceDocumentUpdateInput]
  documentationToDelete: [ID]
}

type UpdateGrievanceTicketMutation {
  grievanceTicket: GrievanceTicketNode
}

input UpdateHouseholdDataUpdateIssueTypeExtras {
  householdData: HouseholdUpdateDataObjectType!
}

input UpdateIndividualDataUpdateIssueTypeExtras {
  individualData: IndividualUpdateDataObjectType!
}

input UpdatePaymentPlanInput {
  paymentPlanId: ID!
  targetingId: ID
  dispersionStartDate: Date
  dispersionEndDate: Date
  currency: String
}

type UpdatePaymentPlanMutation {
  paymentPlan: PaymentPlanNode
}

type UpdatePaymentVerificationReceivedAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdatePaymentVerificationStatusAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdateProgram {
  validationErrors: Arg
  program: ProgramNode
}

input UpdateProgramInput {
  id: String!
  name: String
  status: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  dataCollectingTypeCode: String
  programmeCode: String
  pduFields: [PDUFieldInput]
}

type UpdateProgramPartners {
  validationErrors: Arg
  program: ProgramNode
}

input UpdateProgramPartnersInput {
  id: String!
  partners: [ProgramPartnerThroughInput]
  partnerAccess: String
}

input UpdateTargetPopulationInput {
  id: ID!
  name: String
  targetingCriteria: TargetingCriteriaObjectType
  programId: ID
  programCycleId: ID
  vulnerabilityScoreMin: Decimal
  vulnerabilityScoreMax: Decimal
  excludedIds: String
  exclusionReason: String
}

type UpdateTargetPopulationMutation {
  validationErrors: Arg
  targetPopulation: TargetPopulationNode
}

scalar Upload

type UploadImportDataXLSXFileAsync {
  importData: ImportDataNode
  errors: [XlsxRowErrorNode]
}

type UserBusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboUsername: String
  koboToken: String
  koboUrl: String
  rapidProHost: String
  rapidProPaymentVerificationToken: String
  rapidProMessagesToken: String
  rapidProSurveyToken: String
  slug: String!
  customFields: JSONString!
  hasDataSharingAgreement: Boolean!
  parent: UserBusinessAreaNode
  isSplit: Boolean!
  postponeDeduplication: Boolean!
  deduplicationDuplicateScore: Float!
  deduplicationPossibleDuplicateScore: Float!
  deduplicationBatchDuplicatesPercentage: Int!
  deduplicationBatchDuplicatesAllowed: Int!
  deduplicationGoldenRecordDuplicatesPercentage: Int!
  deduplicationGoldenRecordDuplicatesAllowed: Int!
  screenBeneficiary: Boolean!
  deduplicationIgnoreWithdraw: Boolean!
  biometricDeduplicationThreshold: Float!
  isPaymentPlanApplicable: Boolean!
  isAccountabilityApplicable: Boolean
  active: Boolean!
  enableEmailNotification: Boolean!
  partners: [PartnerNode!]!
  businessAreaPartnerThrough: [PartnerRoleNode!]!
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  dataCollectingTypes(offset: Int, before: String, after: String, first: Int, last: Int): DataCollectingTypeNodeConnection!
  partnerSet: [PartnerNode!]!
  userRoles: [UserRoleNode!]!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualSet(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  registrationdataimportSet(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  ruleSet(offset: Int, before: String, after: String, first: Int, last: Int): SteficonRuleNodeConnection!
  paymentplanSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  financialserviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  cashplanSet(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  paymentSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentNodeConnection!
  serviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): ServiceProviderNodeConnection!
  tickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  targetpopulationSet(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  programSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logentrySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messageSet(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveySet(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  permissions: [String]
}

type UserBusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [UserBusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserBusinessAreaNodeEdge {
  node: UserBusinessAreaNode
  cursor: String!
}

type UserNode implements Node {
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  id: ID!
  status: UserStatus!
  partner: PartnerNode
  email: String!
  availableForExport: Boolean!
  customFields: JSONString!
  jobTitle: String!
  adUuid: String
  lastModifyDate: DateTime
  lastDoapSync: DateTime
  doapHash: String!
  userRoles: [UserRoleNode!]!
  documentSet(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  registrationDataImports(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  createdPaymentPlans(offset: Int, before: String, after: String, first: Int, last: Int): PaymentPlanNodeConnection!
  createdFinancialServiceProviderXlsxTemplates(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderXlsxTemplateNodeConnection!
  createdFinancialServiceProviders(offset: Int, before: String, after: String, first: Int, last: Int): FinancialServiceProviderNodeConnection!
  createdDeliveryMechanisms(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismPerPaymentPlanNodeConnection!
  sentDeliveryMechanisms(offset: Int, before: String, after: String, first: Int, last: Int): DeliveryMechanismPerPaymentPlanNodeConnection!
  approvalSet: [ApprovalNode!]!
  createdTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  assignedTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  ticketNotes(offset: Int, before: String, after: String, first: Int, last: Int): TicketNoteNodeConnection!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  changedTargetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  finalizedTargetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, program: [ID], createdAt: DateTime, createdAt_Lte: DateTime, createdAt_Gte: DateTime, updatedAt: DateTime, updatedAt_Lte: DateTime, updatedAt_Gte: DateTime, status: String, households: [ID], name: String, createdByName: String, totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, createdAtRange: String, paymentPlanApplicable: Boolean, statusNot: String, totalHouseholdsCountWithValidPhoneNoMax: Int, totalHouseholdsCountWithValidPhoneNoMin: Int, programCycle: String, orderBy: String): TargetPopulationNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logs(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  feedbackMessages(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection
  partnerRoles: [PartnerRoleNode]
}

type UserNodeConnection {
  pageInfo: PageInfo!
  edges: [UserNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserNodeEdge {
  node: UserNode
  cursor: String!
}

type UserRoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  role: RoleNode!
  expiryDate: Date
}

enum UserStatus {
  ACTIVE
  INACTIVE
  INVITED
}

type VolumeByDeliveryMechanismNode implements Node {
  id: ID!
  deliveryMechanism: DeliveryMechanismPerPaymentPlanNode
  volume: Float
  volumeUsd: Float
}

type XlsxErrorNode {
  sheet: String
  coordinates: String
  message: String
}

type XlsxRowErrorNode {
  rowNumber: Int
  header: String
  message: String
}

type _DatasetsNode {
  data: [Float]
}

type _DetailedDatasetsNode {
  label: String
  data: [Float]
}

type _TableTotalCashTransferredDataForPeopleNode {
  id: String
  admin2: String
  totalCashTransferred: Float
  totalPeople: Int
}

type _TableTotalCashTransferredDataNode {
  id: String
  admin2: String
  totalCashTransferred: Float
  totalHouseholds: Int
}
