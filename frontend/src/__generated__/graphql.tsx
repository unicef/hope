import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Arg: { input: any; output: any; }
  BigInt: { input: any; output: any; }
  Date: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  Decimal: { input: any; output: any; }
  FlexFieldsScalar: { input: any; output: any; }
  GeoJSON: { input: any; output: any; }
  JSONString: { input: any; output: any; }
  UUID: { input: any; output: any; }
  Upload: { input: any; output: any; }
};

export type AccountabilityCommunicationMessageAgeInput = {
  max?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
};

export type AccountabilityFullListArguments = {
  excludedAdminAreas?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type AccountabilityRandomSamplingArguments = {
  age?: InputMaybe<AccountabilityCommunicationMessageAgeInput>;
  confidenceInterval: Scalars['Float']['input'];
  excludedAdminAreas?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  marginOfError: Scalars['Float']['input'];
  sex?: InputMaybe<Scalars['String']['input']>;
};

export type AccountabilitySampleSizeInput = {
  fullListArguments?: InputMaybe<AccountabilityFullListArguments>;
  program?: InputMaybe<Scalars['ID']['input']>;
  randomSamplingArguments?: InputMaybe<AccountabilityRandomSamplingArguments>;
  samplingType: Scalars['String']['input'];
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
};

export type AccountabilitySampleSizeNode = {
  __typename?: 'AccountabilitySampleSizeNode';
  numberOfRecipients?: Maybe<Scalars['Int']['output']>;
  sampleSize?: Maybe<Scalars['Int']['output']>;
};

export enum Action {
  Approve = 'APPROVE',
  Authorize = 'AUTHORIZE',
  Finish = 'FINISH',
  Lock = 'LOCK',
  LockFsp = 'LOCK_FSP',
  Reject = 'REJECT',
  Review = 'REVIEW',
  SendForApproval = 'SEND_FOR_APPROVAL',
  SendToPaymentGateway = 'SEND_TO_PAYMENT_GATEWAY',
  Unlock = 'UNLOCK',
  UnlockFsp = 'UNLOCK_FSP'
}

export type ActionPaymentPlanInput = {
  action: Action;
  comment?: InputMaybe<Scalars['String']['input']>;
  paymentPlanId: Scalars['ID']['input'];
};

export type ActionPaymentPlanMutation = {
  __typename?: 'ActionPaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ActivatePaymentVerificationPlan = {
  __typename?: 'ActivatePaymentVerificationPlan';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type AddIndividualDataObjectType = {
  administrationOfRutf?: InputMaybe<Scalars['Boolean']['input']>;
  birthDate: Scalars['Date']['input'];
  businessArea?: InputMaybe<Scalars['String']['input']>;
  commsDisability?: InputMaybe<Scalars['String']['input']>;
  disability?: InputMaybe<Scalars['String']['input']>;
  documents?: InputMaybe<Array<InputMaybe<IndividualDocumentObjectType>>>;
  email?: InputMaybe<Scalars['String']['input']>;
  enrolledInNutritionProgramme?: InputMaybe<Scalars['Boolean']['input']>;
  estimatedBirthDate: Scalars['Boolean']['input'];
  familyName?: InputMaybe<Scalars['String']['input']>;
  flexFields?: InputMaybe<Scalars['Arg']['input']>;
  fullName: Scalars['String']['input'];
  givenName?: InputMaybe<Scalars['String']['input']>;
  hearingDisability?: InputMaybe<Scalars['String']['input']>;
  identities?: InputMaybe<Array<InputMaybe<IndividualIdentityObjectType>>>;
  maritalStatus?: InputMaybe<Scalars['String']['input']>;
  memoryDisability?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  observedDisability?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  paymentChannels?: InputMaybe<Array<InputMaybe<BankTransferObjectType>>>;
  paymentDeliveryPhoneNo?: InputMaybe<Scalars['String']['input']>;
  phoneNo?: InputMaybe<Scalars['String']['input']>;
  phoneNoAlternative?: InputMaybe<Scalars['String']['input']>;
  physicalDisability?: InputMaybe<Scalars['String']['input']>;
  preferredLanguage?: InputMaybe<Scalars['String']['input']>;
  pregnant?: InputMaybe<Scalars['Boolean']['input']>;
  relationship: Scalars['String']['input'];
  role: Scalars['String']['input'];
  seeingDisability?: InputMaybe<Scalars['String']['input']>;
  selfcareDisability?: InputMaybe<Scalars['String']['input']>;
  sex: Scalars['String']['input'];
  whoAnswersAltPhone?: InputMaybe<Scalars['String']['input']>;
  whoAnswersPhone?: InputMaybe<Scalars['String']['input']>;
  workStatus?: InputMaybe<Scalars['String']['input']>;
};

export type AddIndividualIssueTypeExtras = {
  household: Scalars['ID']['input'];
  individualData: AddIndividualDataObjectType;
};

export type AgeFilterObject = {
  __typename?: 'AgeFilterObject';
  max?: Maybe<Scalars['Int']['output']>;
  min?: Maybe<Scalars['Int']['output']>;
};

export type AgeInput = {
  max?: InputMaybe<Scalars['Int']['input']>;
  min?: InputMaybe<Scalars['Int']['input']>;
};

export type ApprovalNode = {
  __typename?: 'ApprovalNode';
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  info?: Maybe<Scalars['String']['output']>;
};

export type ApprovalProcessNode = Node & {
  __typename?: 'ApprovalProcessNode';
  actions?: Maybe<FilteredActionsListNode>;
  approvalNumberRequired: Scalars['Int']['output'];
  authorizationNumberRequired: Scalars['Int']['output'];
  createdAt: Scalars['DateTime']['output'];
  financeReleaseNumberRequired: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  paymentPlan: PaymentPlanNode;
  rejectedOn?: Maybe<Scalars['String']['output']>;
  sentForApprovalBy?: Maybe<UserNode>;
  sentForApprovalDate?: Maybe<Scalars['DateTime']['output']>;
  sentForAuthorizationBy?: Maybe<UserNode>;
  sentForAuthorizationDate?: Maybe<Scalars['DateTime']['output']>;
  sentForFinanceReleaseBy?: Maybe<UserNode>;
  sentForFinanceReleaseDate?: Maybe<Scalars['DateTime']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type ApprovalProcessNodeConnection = {
  __typename?: 'ApprovalProcessNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ApprovalProcessNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ApprovalProcessNodeEdge = {
  __typename?: 'ApprovalProcessNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ApprovalProcessNode>;
};

export type AreaGroupNode = {
  __typename?: 'AreaGroupNode';
  ids?: Maybe<Array<Maybe<Scalars['ID']['output']>>>;
  level?: Maybe<Scalars['Int']['output']>;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AreaNode = Node & {
  __typename?: 'AreaNode';
  areaSet: AreaNodeConnection;
  areaType: AreaTypeNode;
  createdAt: Scalars['DateTime']['output'];
  extras: Scalars['JSONString']['output'];
  feedbackSet: FeedbackNodeConnection;
  grievanceticketSet: GrievanceTicketNodeConnection;
  householdSet: HouseholdNodeConnection;
  id: Scalars['ID']['output'];
  level: Scalars['Int']['output'];
  lft: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  originalId?: Maybe<Scalars['UUID']['output']>;
  pCode?: Maybe<Scalars['String']['output']>;
  parent?: Maybe<AreaNode>;
  programs: ProgramNodeConnection;
  reports: ReportNodeConnection;
  rght: Scalars['Int']['output'];
  treeId: Scalars['Int']['output'];
  updatedAt: Scalars['DateTime']['output'];
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
};


export type AreaNodeAreaSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type AreaNodeFeedbackSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type AreaNodeGrievanceticketSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type AreaNodeHouseholdSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type AreaNodeProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type AreaNodeReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type AreaNodeConnection = {
  __typename?: 'AreaNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<AreaNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AreaNodeEdge = {
  __typename?: 'AreaNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<AreaNode>;
};

export type AreaTreeNode = {
  __typename?: 'AreaTreeNode';
  areas?: Maybe<Array<Maybe<AreaTreeNode>>>;
  id?: Maybe<Scalars['ID']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pCode?: Maybe<Scalars['String']['output']>;
};

export type AreaTypeNode = Node & {
  __typename?: 'AreaTypeNode';
  areaLevel: Scalars['Int']['output'];
  areaSet: AreaNodeConnection;
  areatypeSet: AreaTypeNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  extras: Scalars['JSONString']['output'];
  id: Scalars['ID']['output'];
  level: Scalars['Int']['output'];
  lft: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  originalId?: Maybe<Scalars['UUID']['output']>;
  parent?: Maybe<AreaTypeNode>;
  rght: Scalars['Int']['output'];
  treeId: Scalars['Int']['output'];
  updatedAt: Scalars['DateTime']['output'];
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
};


export type AreaTypeNodeAreaSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type AreaTypeNodeAreatypeSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type AreaTypeNodeConnection = {
  __typename?: 'AreaTypeNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<AreaTypeNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type AreaTypeNodeEdge = {
  __typename?: 'AreaTypeNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<AreaTypeNode>;
};

export type AssignFspToDeliveryMechanismInput = {
  mappings: Array<InputMaybe<FspToDeliveryMechanismMappingInput>>;
  paymentPlanId: Scalars['ID']['input'];
};

export type AssignFspToDeliveryMechanismMutation = {
  __typename?: 'AssignFspToDeliveryMechanismMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type AvailableFspsForDeliveryMechanismsInput = {
  paymentPlanId: Scalars['ID']['input'];
};

export type BankAccountInfoNode = Node & {
  __typename?: 'BankAccountInfoNode';
  accountHolderName: Scalars['String']['output'];
  bankAccountNumber: Scalars['String']['output'];
  bankBranchName: Scalars['String']['output'];
  bankName: Scalars['String']['output'];
  copiedFrom?: Maybe<BankAccountInfoNode>;
  copiedTo: BankAccountInfoNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  individual: IndividualNode;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  lastSyncAt?: Maybe<Scalars['DateTime']['output']>;
  removedDate?: Maybe<Scalars['DateTime']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


export type BankAccountInfoNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type BankAccountInfoNodeConnection = {
  __typename?: 'BankAccountInfoNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<BankAccountInfoNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type BankAccountInfoNodeEdge = {
  __typename?: 'BankAccountInfoNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<BankAccountInfoNode>;
};

export type BankTransferObjectType = {
  accountHolderName: Scalars['String']['input'];
  bankAccountNumber: Scalars['String']['input'];
  bankBranchName?: InputMaybe<Scalars['String']['input']>;
  bankName: Scalars['String']['input'];
  type: Scalars['String']['input'];
};

export type BulkGrievanceAddNoteMutation = {
  __typename?: 'BulkGrievanceAddNoteMutation';
  grievanceTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
};

export type BulkUpdateGrievanceTicketsAssigneesMutation = {
  __typename?: 'BulkUpdateGrievanceTicketsAssigneesMutation';
  grievanceTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
};

export type BulkUpdateGrievanceTicketsPriorityMutation = {
  __typename?: 'BulkUpdateGrievanceTicketsPriorityMutation';
  grievanceTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
};

export type BulkUpdateGrievanceTicketsUrgencyMutation = {
  __typename?: 'BulkUpdateGrievanceTicketsUrgencyMutation';
  grievanceTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
};

export type BusinessAreaNode = Node & {
  __typename?: 'BusinessAreaNode';
  active: Scalars['Boolean']['output'];
  cashplanSet: CashPlanNodeConnection;
  children: UserBusinessAreaNodeConnection;
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  customFields: Scalars['JSONString']['output'];
  dataCollectingTypes: DataCollectingTypeNodeConnection;
  deduplicationBatchDuplicatesAllowed: Scalars['Int']['output'];
  deduplicationBatchDuplicatesPercentage: Scalars['Int']['output'];
  deduplicationDuplicateScore: Scalars['Float']['output'];
  deduplicationGoldenRecordDuplicatesAllowed: Scalars['Int']['output'];
  deduplicationGoldenRecordDuplicatesPercentage: Scalars['Int']['output'];
  deduplicationIgnoreWithdraw: Scalars['Boolean']['output'];
  deduplicationPossibleDuplicateScore: Scalars['Float']['output'];
  enableEmailNotification: Scalars['Boolean']['output'];
  feedbackSet: FeedbackNodeConnection;
  financialserviceproviderSet: FinancialServiceProviderNodeConnection;
  hasDataSharingAgreement: Scalars['Boolean']['output'];
  householdSet: HouseholdNodeConnection;
  id: Scalars['ID']['output'];
  individualSet: IndividualNodeConnection;
  isAccountabilityApplicable?: Maybe<Scalars['Boolean']['output']>;
  isPaymentPlanApplicable: Scalars['Boolean']['output'];
  isSplit: Scalars['Boolean']['output'];
  koboToken?: Maybe<Scalars['String']['output']>;
  koboUrl?: Maybe<Scalars['String']['output']>;
  koboUsername?: Maybe<Scalars['String']['output']>;
  logentrySet: PaymentVerificationLogEntryNodeConnection;
  longName: Scalars['String']['output'];
  messageSet: CommunicationMessageNodeConnection;
  name: Scalars['String']['output'];
  parent?: Maybe<UserBusinessAreaNode>;
  partnerSet: Array<PartnerNodeForProgram>;
  paymentSet: PaymentNodeConnection;
  paymentplanSet: PaymentPlanNodeConnection;
  paymentrecordSet: PaymentRecordNodeConnection;
  postponeDeduplication: Scalars['Boolean']['output'];
  programSet: ProgramNodeConnection;
  rapidProHost?: Maybe<Scalars['String']['output']>;
  rapidProMessagesToken?: Maybe<Scalars['String']['output']>;
  rapidProPaymentVerificationToken?: Maybe<Scalars['String']['output']>;
  rapidProSurveyToken?: Maybe<Scalars['String']['output']>;
  regionCode: Scalars['String']['output'];
  regionName: Scalars['String']['output'];
  registrationdataimportSet: RegistrationDataImportNodeConnection;
  reports: ReportNodeConnection;
  ruleSet: SteficonRuleNodeConnection;
  screenBeneficiary: Scalars['Boolean']['output'];
  serviceproviderSet: ServiceProviderNodeConnection;
  slug: Scalars['String']['output'];
  surveySet: SurveyNodeConnection;
  targetpopulationSet: TargetPopulationNodeConnection;
  tickets: GrievanceTicketNodeConnection;
  updatedAt: Scalars['DateTime']['output'];
  userRoles: Array<UserRoleNode>;
};


export type BusinessAreaNodeCashplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeDataCollectingTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeFeedbackSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeFinancialserviceproviderSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeHouseholdSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeIndividualSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeLogentrySetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeMessageSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodePaymentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodePaymentplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodePaymentrecordSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeProgramSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeRegistrationdataimportSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeRuleSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeServiceproviderSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeSurveySetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAreaNodeTargetpopulationSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type BusinessAreaNodeTicketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type BusinessAreaNodeConnection = {
  __typename?: 'BusinessAreaNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<BusinessAreaNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type BusinessAreaNodeEdge = {
  __typename?: 'BusinessAreaNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<BusinessAreaNode>;
};

export type CashPlanAndPaymentPlanEdges = {
  __typename?: 'CashPlanAndPaymentPlanEdges';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<CashPlanAndPaymentPlanNode>;
};

export type CashPlanAndPaymentPlanNode = {
  __typename?: 'CashPlanAndPaymentPlanNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  assistanceMeasurement?: Maybe<Scalars['String']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  dispersionDate?: Maybe<Scalars['String']['output']>;
  endDate?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  objType?: Maybe<Scalars['String']['output']>;
  programName?: Maybe<Scalars['String']['output']>;
  serviceProviderFullName?: Maybe<Scalars['String']['output']>;
  startDate?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalDeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantity?: Maybe<Scalars['Float']['output']>;
  totalNumberOfHouseholds?: Maybe<Scalars['Int']['output']>;
  totalUndeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['String']['output']>;
  verificationPlans?: Maybe<Array<Maybe<PaymentVerificationPlanNode>>>;
  verificationStatus?: Maybe<Scalars['String']['output']>;
};

export type CashPlanNode = Node & {
  __typename?: 'CashPlanNode';
  assistanceMeasurement: Scalars['String']['output'];
  assistanceThrough: Scalars['String']['output'];
  availablePaymentRecordsCount?: Maybe<Scalars['Int']['output']>;
  bankReconciliationError?: Maybe<Scalars['Int']['output']>;
  bankReconciliationSuccess?: Maybe<Scalars['Int']['output']>;
  businessArea: UserBusinessAreaNode;
  caHashId?: Maybe<Scalars['UUID']['output']>;
  caId?: Maybe<Scalars['String']['output']>;
  canCreatePaymentVerificationPlan?: Maybe<Scalars['Boolean']['output']>;
  comments?: Maybe<Scalars['String']['output']>;
  coverageDuration: Scalars['Int']['output'];
  coverageUnit: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  deliveryType?: Maybe<Scalars['String']['output']>;
  dispersionDate: Scalars['DateTime']['output'];
  distributionLevel: Scalars['String']['output'];
  downPayment?: Maybe<Scalars['String']['output']>;
  endDate: Scalars['DateTime']['output'];
  exchangeRate?: Maybe<Scalars['Float']['output']>;
  fundsCommitment?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  paymentItems: PaymentRecordNodeConnection;
  paymentVerificationSummary?: Maybe<PaymentVerificationSummaryNode>;
  program: ProgramNode;
  serviceProvider?: Maybe<ServiceProviderNode>;
  startDate: Scalars['DateTime']['output'];
  status: CashPlanStatus;
  statusDate: Scalars['DateTime']['output'];
  totalDeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  totalDeliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantity?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantityRevised?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantityRevisedUsd?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantityUsd?: Maybe<Scalars['Float']['output']>;
  totalNumberOfHouseholds?: Maybe<Scalars['Int']['output']>;
  totalPersonsCovered: Scalars['Int']['output'];
  totalPersonsCoveredRevised: Scalars['Int']['output'];
  totalUndeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  totalUndeliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  validationAlertsCount: Scalars['Int']['output'];
  verificationPlans?: Maybe<PaymentVerificationPlanNodeConnection>;
  version: Scalars['BigInt']['output'];
  visionId?: Maybe<Scalars['String']['output']>;
};


export type CashPlanNodePaymentItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type CashPlanNodeVerificationPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
};

export type CashPlanNodeConnection = {
  __typename?: 'CashPlanNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<CashPlanNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CashPlanNodeEdge = {
  __typename?: 'CashPlanNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<CashPlanNode>;
};

export enum CashPlanStatus {
  DistributionCompleted = 'DISTRIBUTION_COMPLETED',
  DistributionCompletedWithErrors = 'DISTRIBUTION_COMPLETED_WITH_ERRORS',
  TransactionCompleted = 'TRANSACTION_COMPLETED',
  TransactionCompletedWithErrors = 'TRANSACTION_COMPLETED_WITH_ERRORS'
}

export type CategoryExtrasInput = {
  grievanceComplaintTicketExtras?: InputMaybe<GrievanceComplaintTicketExtras>;
  negativeFeedbackTicketExtras?: InputMaybe<NegativeFeedbackTicketExtras>;
  positiveFeedbackTicketExtras?: InputMaybe<PositiveFeedbackTicketExtras>;
  referralTicketExtras?: InputMaybe<ReferralTicketExtras>;
  sensitiveGrievanceTicketExtras?: InputMaybe<SensitiveGrievanceTicketExtras>;
};

export type ChartDatasetNode = {
  __typename?: 'ChartDatasetNode';
  datasets?: Maybe<Array<Maybe<_DatasetsNode>>>;
  labels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type ChartDetailedDatasetsNode = {
  __typename?: 'ChartDetailedDatasetsNode';
  datasets?: Maybe<Array<Maybe<_DetailedDatasetsNode>>>;
  labels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type ChartGrievanceTicketsNode = {
  __typename?: 'ChartGrievanceTicketsNode';
  datasets?: Maybe<Array<Maybe<_DatasetsNode>>>;
  labels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  totalNumberOfFeedback?: Maybe<Scalars['Int']['output']>;
  totalNumberOfGrievances?: Maybe<Scalars['Int']['output']>;
  totalNumberOfOpenSensitive?: Maybe<Scalars['Int']['output']>;
};

export type ChartPaymentVerification = {
  __typename?: 'ChartPaymentVerification';
  averageSampleSize?: Maybe<Scalars['Float']['output']>;
  datasets?: Maybe<Array<Maybe<_DetailedDatasetsNode>>>;
  households?: Maybe<Scalars['Int']['output']>;
  labels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type CheckAgainstSanctionListMutation = {
  __typename?: 'CheckAgainstSanctionListMutation';
  errors?: Maybe<Array<Maybe<XlsxRowErrorNode>>>;
  ok?: Maybe<Scalars['Boolean']['output']>;
};

export type ChoiceObject = {
  __typename?: 'ChoiceObject';
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type ChoiceObjectInt = {
  __typename?: 'ChoiceObjectInt';
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

export type ChooseDeliveryMechanismsForPaymentPlanInput = {
  deliveryMechanisms: Array<InputMaybe<Scalars['String']['input']>>;
  paymentPlanId: Scalars['ID']['input'];
};

export type ChooseDeliveryMechanismsForPaymentPlanMutation = {
  __typename?: 'ChooseDeliveryMechanismsForPaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type CommunicationMessageNode = Node & {
  __typename?: 'CommunicationMessageNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  body: Scalars['String']['output'];
  businessArea: UserBusinessAreaNode;
  copiedFrom?: Maybe<CommunicationMessageNode>;
  copiedTo: CommunicationMessageNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  fullListArguments?: Maybe<Scalars['JSONString']['output']>;
  households: HouseholdNodeConnection;
  id: Scalars['ID']['output'];
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  migratedAt?: Maybe<Scalars['DateTime']['output']>;
  numberOfRecipients: Scalars['Int']['output'];
  program?: Maybe<ProgramNode>;
  randomSamplingArguments?: Maybe<Scalars['JSONString']['output']>;
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  sampleSize: Scalars['Int']['output'];
  samplingType: MessageSamplingType;
  targetPopulation?: Maybe<TargetPopulationNode>;
  title: Scalars['String']['output'];
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


export type CommunicationMessageNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type CommunicationMessageNodeHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type CommunicationMessageNodeConnection = {
  __typename?: 'CommunicationMessageNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<CommunicationMessageNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CommunicationMessageNodeEdge = {
  __typename?: 'CommunicationMessageNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<CommunicationMessageNode>;
};

export type CommunicationMessageRecipientMapNode = Node & {
  __typename?: 'CommunicationMessageRecipientMapNode';
  headOfHousehold: IndividualNode;
  id: Scalars['ID']['output'];
  size?: Maybe<Scalars['Int']['output']>;
};

export type CommunicationMessageRecipientMapNodeConnection = {
  __typename?: 'CommunicationMessageRecipientMapNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<CommunicationMessageRecipientMapNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type CommunicationMessageRecipientMapNodeEdge = {
  __typename?: 'CommunicationMessageRecipientMapNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<CommunicationMessageRecipientMapNode>;
};

export type ContentTypeObjectType = {
  __typename?: 'ContentTypeObjectType';
  appLabel: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  logEntries: PaymentVerificationLogEntryNodeConnection;
  model: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  paymentverificationSet: PaymentVerificationNodeConnection;
  paymentverificationplanSet: PaymentVerificationPlanNodeConnection;
  paymentverificationsummarySet: PaymentVerificationSummaryNodeConnection;
  ticketcomplaintdetailsSet: TicketComplaintDetailsNodeConnection;
  ticketsensitivedetailsSet: TicketSensitiveDetailsNodeConnection;
};


export type ContentTypeObjectTypeLogEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ContentTypeObjectTypePaymentverificationSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ContentTypeObjectTypePaymentverificationplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ContentTypeObjectTypePaymentverificationsummarySetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ContentTypeObjectTypeTicketcomplaintdetailsSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ContentTypeObjectTypeTicketsensitivedetailsSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type CopyProgram = {
  __typename?: 'CopyProgram';
  program?: Maybe<ProgramNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type CopyProgramInput = {
  administrativeAreasOfImplementation?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['Decimal']['input']>;
  businessAreaSlug?: InputMaybe<Scalars['String']['input']>;
  cashPlus?: InputMaybe<Scalars['Boolean']['input']>;
  dataCollectingTypeCode?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  frequencyOfPayments?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  partners?: InputMaybe<Array<InputMaybe<PartnerProgramInput>>>;
  populationGoal?: InputMaybe<Scalars['Int']['input']>;
  programmeCode?: InputMaybe<Scalars['String']['input']>;
  sector?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

export type CopyTargetPopulationInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type CopyTargetPopulationMutationInput = {
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  targetPopulationData?: InputMaybe<CopyTargetPopulationInput>;
};

export type CopyTargetPopulationMutationPayload = {
  __typename?: 'CopyTargetPopulationMutationPayload';
  clientMutationId?: Maybe<Scalars['String']['output']>;
  targetPopulation?: Maybe<TargetPopulationNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type CoreFieldChoiceObject = {
  __typename?: 'CoreFieldChoiceObject';
  admin?: Maybe<Scalars['String']['output']>;
  labelEn?: Maybe<Scalars['String']['output']>;
  labels?: Maybe<Array<Maybe<LabelNode>>>;
  listName?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type CountAndPercentageNode = {
  __typename?: 'CountAndPercentageNode';
  count?: Maybe<Scalars['Int']['output']>;
  percentage?: Maybe<Scalars['Float']['output']>;
};

export type CreateAccountabilityCommunicationMessageInput = {
  body: Scalars['String']['input'];
  fullListArguments?: InputMaybe<AccountabilityFullListArguments>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  randomSamplingArguments?: InputMaybe<AccountabilityRandomSamplingArguments>;
  registrationDataImport?: InputMaybe<Scalars['ID']['input']>;
  samplingType: SamplingChoices;
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
};

export type CreateCommunicationMessageMutation = {
  __typename?: 'CreateCommunicationMessageMutation';
  message?: Maybe<CommunicationMessageNode>;
};

export type CreateDashboardReport = {
  __typename?: 'CreateDashboardReport';
  success?: Maybe<Scalars['Boolean']['output']>;
};

export type CreateDashboardReportInput = {
  adminArea?: InputMaybe<Scalars['ID']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['ID']['input']>;
  reportTypes: Array<InputMaybe<Scalars['String']['input']>>;
  year: Scalars['Int']['input'];
};

export type CreateFeedbackInput = {
  admin2?: InputMaybe<Scalars['ID']['input']>;
  area?: InputMaybe<Scalars['String']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  consent?: InputMaybe<Scalars['Boolean']['input']>;
  description: Scalars['String']['input'];
  householdLookup?: InputMaybe<Scalars['ID']['input']>;
  individualLookup?: InputMaybe<Scalars['ID']['input']>;
  issueType: Scalars['String']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
};

export type CreateFeedbackMessageInput = {
  description: Scalars['String']['input'];
  feedback: Scalars['ID']['input'];
};

export type CreateFeedbackMessageMutation = {
  __typename?: 'CreateFeedbackMessageMutation';
  feedbackMessage?: Maybe<FeedbackMessageNode>;
};

export type CreateFeedbackMutation = {
  __typename?: 'CreateFeedbackMutation';
  feedback?: Maybe<FeedbackNode>;
};

export type CreateFollowUpPaymentPlanMutation = {
  __typename?: 'CreateFollowUpPaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type CreateGrievanceTicketExtrasInput = {
  category?: InputMaybe<CategoryExtrasInput>;
  issueType?: InputMaybe<IssueTypeExtrasInput>;
};

export type CreateGrievanceTicketInput = {
  admin?: InputMaybe<Scalars['ID']['input']>;
  area?: InputMaybe<Scalars['String']['input']>;
  assignedTo?: InputMaybe<Scalars['ID']['input']>;
  businessArea: Scalars['ID']['input'];
  category: Scalars['Int']['input'];
  comments?: InputMaybe<Scalars['String']['input']>;
  consent: Scalars['Boolean']['input'];
  description: Scalars['String']['input'];
  documentation?: InputMaybe<Array<InputMaybe<GrievanceDocumentInput>>>;
  extras?: InputMaybe<CreateGrievanceTicketExtrasInput>;
  issueType?: InputMaybe<Scalars['Int']['input']>;
  language: Scalars['String']['input'];
  linkedFeedbackId?: InputMaybe<Scalars['ID']['input']>;
  linkedTickets?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  partner?: InputMaybe<Scalars['Int']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  urgency?: InputMaybe<Scalars['Int']['input']>;
};

export type CreateGrievanceTicketMutation = {
  __typename?: 'CreateGrievanceTicketMutation';
  grievanceTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
};

export type CreatePaymentPlanInput = {
  businessAreaSlug: Scalars['String']['input'];
  currency: Scalars['String']['input'];
  dispersionEndDate: Scalars['Date']['input'];
  dispersionStartDate: Scalars['Date']['input'];
  endDate: Scalars['Date']['input'];
  startDate: Scalars['Date']['input'];
  targetingId: Scalars['ID']['input'];
};

export type CreatePaymentPlanMutation = {
  __typename?: 'CreatePaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type CreatePaymentVerificationInput = {
  businessAreaSlug: Scalars['String']['input'];
  cashOrPaymentPlanId: Scalars['ID']['input'];
  fullListArguments?: InputMaybe<FullListArguments>;
  randomSamplingArguments?: InputMaybe<RandomSamplingArguments>;
  rapidProArguments?: InputMaybe<RapidProArguments>;
  sampling: Scalars['String']['input'];
  verificationChannel: Scalars['String']['input'];
};

export type CreateProgram = {
  __typename?: 'CreateProgram';
  program?: Maybe<ProgramNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type CreateProgramInput = {
  administrativeAreasOfImplementation?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['Decimal']['input']>;
  businessAreaSlug?: InputMaybe<Scalars['String']['input']>;
  cashPlus?: InputMaybe<Scalars['Boolean']['input']>;
  dataCollectingTypeCode?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  frequencyOfPayments?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  partners?: InputMaybe<Array<InputMaybe<PartnerProgramInput>>>;
  populationGoal?: InputMaybe<Scalars['Int']['input']>;
  programmeCode?: InputMaybe<Scalars['String']['input']>;
  sector?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

export type CreateReport = {
  __typename?: 'CreateReport';
  report?: Maybe<ReportNode>;
};

export type CreateReportInput = {
  adminArea1?: InputMaybe<Scalars['ID']['input']>;
  adminArea2?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  businessAreaSlug: Scalars['String']['input'];
  dateFrom: Scalars['Date']['input'];
  dateTo: Scalars['Date']['input'];
  program?: InputMaybe<Scalars['ID']['input']>;
  reportType: Scalars['Int']['input'];
};

export type CreateSurveyInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  category: Scalars['String']['input'];
  flow: Scalars['String']['input'];
  fullListArguments?: InputMaybe<AccountabilityFullListArguments>;
  program?: InputMaybe<Scalars['ID']['input']>;
  randomSamplingArguments?: InputMaybe<AccountabilityRandomSamplingArguments>;
  samplingType: Scalars['String']['input'];
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
};

export type CreateSurveyMutation = {
  __typename?: 'CreateSurveyMutation';
  survey?: Maybe<SurveyNode>;
};

export type CreateTargetPopulationInput = {
  businessAreaSlug: Scalars['String']['input'];
  excludedIds: Scalars['String']['input'];
  exclusionReason?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  programId: Scalars['ID']['input'];
  targetingCriteria: TargetingCriteriaObjectType;
};

export type CreateTargetPopulationMutation = {
  __typename?: 'CreateTargetPopulationMutation';
  targetPopulation?: Maybe<TargetPopulationNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type CreateTicketNoteInput = {
  description: Scalars['String']['input'];
  ticket: Scalars['ID']['input'];
};

export type CreateTicketNoteMutation = {
  __typename?: 'CreateTicketNoteMutation';
  grievanceTicketNote?: Maybe<TicketNoteNode>;
};

export type CreateVerificationPlanMutation = {
  __typename?: 'CreateVerificationPlanMutation';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type DataCollectingTypeChoiceObject = {
  __typename?: 'DataCollectingTypeChoiceObject';
  description?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type DataCollectingTypeNode = Node & {
  __typename?: 'DataCollectingTypeNode';
  active: Scalars['Boolean']['output'];
  code: Scalars['String']['output'];
  compatibleTypes: DataCollectingTypeNodeConnection;
  created: Scalars['DateTime']['output'];
  datacollectingtypeSet: DataCollectingTypeNodeConnection;
  deprecated: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  householdFiltersAvailable: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  individualFiltersAvailable: Scalars['Boolean']['output'];
  label: Scalars['String']['output'];
  limitTo: UserBusinessAreaNodeConnection;
  modified: Scalars['DateTime']['output'];
  programs: ProgramNodeConnection;
  recalculateComposition: Scalars['Boolean']['output'];
  type?: Maybe<DataCollectingTypeType>;
  weight: Scalars['Int']['output'];
};


export type DataCollectingTypeNodeCompatibleTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type DataCollectingTypeNodeDatacollectingtypeSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type DataCollectingTypeNodeLimitToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type DataCollectingTypeNodeProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type DataCollectingTypeNodeConnection = {
  __typename?: 'DataCollectingTypeNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<DataCollectingTypeNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type DataCollectingTypeNodeEdge = {
  __typename?: 'DataCollectingTypeNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<DataCollectingTypeNode>;
};

export enum DataCollectingTypeType {
  Social = 'SOCIAL',
  Standard = 'STANDARD'
}

export type DeduplicationResultNode = {
  __typename?: 'DeduplicationResultNode';
  age?: Maybe<Scalars['Int']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  hitId?: Maybe<Scalars['ID']['output']>;
  location?: Maybe<Scalars['String']['output']>;
  proximityToScore?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

export type DeleteHouseholdApproveMutation = {
  __typename?: 'DeleteHouseholdApproveMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type DeletePaymentPlanMutation = {
  __typename?: 'DeletePaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type DeletePaymentVerificationPlan = {
  __typename?: 'DeletePaymentVerificationPlan';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type DeleteProgram = {
  __typename?: 'DeleteProgram';
  ok?: Maybe<Scalars['Boolean']['output']>;
};

export type DeleteRegistrationDataImport = {
  __typename?: 'DeleteRegistrationDataImport';
  ok?: Maybe<Scalars['Boolean']['output']>;
};

export type DeleteTargetPopulationMutationInput = {
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  targetId: Scalars['ID']['input'];
};

export type DeleteTargetPopulationMutationPayload = {
  __typename?: 'DeleteTargetPopulationMutationPayload';
  clientMutationId?: Maybe<Scalars['String']['output']>;
  ok?: Maybe<Scalars['Boolean']['output']>;
};

export type DeliveredQuantityNode = {
  __typename?: 'DeliveredQuantityNode';
  currency?: Maybe<Scalars['String']['output']>;
  totalDeliveredQuantity?: Maybe<Scalars['Decimal']['output']>;
};

export type DeliveryMechanismNode = Node & {
  __typename?: 'DeliveryMechanismNode';
  chosenConfiguration?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy: UserNode;
  deliveryMechanism?: Maybe<DeliveryMechanismPerPaymentPlanDeliveryMechanism>;
  deliveryMechanismOrder: Scalars['Int']['output'];
  financialServiceProvider?: Maybe<FinancialServiceProviderNode>;
  fsp?: Maybe<FinancialServiceProviderNode>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  paymentPlan: PaymentPlanNode;
  sentBy?: Maybe<UserNode>;
  sentDate: Scalars['DateTime']['output'];
  sentToPaymentGateway: Scalars['Boolean']['output'];
  status: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type DeliveryMechanismNodeConnection = {
  __typename?: 'DeliveryMechanismNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<DeliveryMechanismNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type DeliveryMechanismNodeEdge = {
  __typename?: 'DeliveryMechanismNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<DeliveryMechanismNode>;
};

export enum DeliveryMechanismPerPaymentPlanDeliveryMechanism {
  CardlessCashWithdrawal = 'CARDLESS_CASH_WITHDRAWAL',
  Cash = 'CASH',
  CashByFsp = 'CASH_BY_FSP',
  CashOverTheCounter = 'CASH_OVER_THE_COUNTER',
  Cheque = 'CHEQUE',
  DepositToCard = 'DEPOSIT_TO_CARD',
  MobileMoney = 'MOBILE_MONEY',
  PrePaidCard = 'PRE_PAID_CARD',
  Referral = 'REFERRAL',
  Transfer = 'TRANSFER',
  TransferToAccount = 'TRANSFER_TO_ACCOUNT',
  Voucher = 'VOUCHER'
}

export type DiscardPaymentVerificationPlan = {
  __typename?: 'DiscardPaymentVerificationPlan';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type DjangoDebug = {
  __typename?: 'DjangoDebug';
  sql?: Maybe<Array<Maybe<DjangoDebugSql>>>;
};

export type DjangoDebugSql = {
  __typename?: 'DjangoDebugSQL';
  alias: Scalars['String']['output'];
  duration: Scalars['Float']['output'];
  encoding?: Maybe<Scalars['String']['output']>;
  isSelect: Scalars['Boolean']['output'];
  isSlow: Scalars['Boolean']['output'];
  isoLevel?: Maybe<Scalars['String']['output']>;
  params: Scalars['String']['output'];
  rawSql: Scalars['String']['output'];
  sql?: Maybe<Scalars['String']['output']>;
  startTime: Scalars['Float']['output'];
  stopTime: Scalars['Float']['output'];
  transId?: Maybe<Scalars['String']['output']>;
  transStatus?: Maybe<Scalars['String']['output']>;
  vendor: Scalars['String']['output'];
};

export type DocumentNode = Node & {
  __typename?: 'DocumentNode';
  cleared: Scalars['Boolean']['output'];
  clearedBy?: Maybe<UserNode>;
  clearedDate: Scalars['DateTime']['output'];
  copiedFrom?: Maybe<DocumentNode>;
  copiedTo: DocumentNodeConnection;
  country?: Maybe<Scalars['String']['output']>;
  countryIso3?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  documentNumber: Scalars['String']['output'];
  expiryDate?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  individual: IndividualNode;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  issuanceDate?: Maybe<Scalars['DateTime']['output']>;
  lastSyncAt?: Maybe<Scalars['DateTime']['output']>;
  photo?: Maybe<Scalars['String']['output']>;
  program?: Maybe<ProgramNode>;
  status: DocumentStatus;
  type: DocumentTypeNode;
  updatedAt: Scalars['DateTime']['output'];
};


export type DocumentNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type DocumentNodeConnection = {
  __typename?: 'DocumentNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<DocumentNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type DocumentNodeEdge = {
  __typename?: 'DocumentNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<DocumentNode>;
};

export enum DocumentStatus {
  Invalid = 'INVALID',
  NeedInvestigation = 'NEED_INVESTIGATION',
  Pending = 'PENDING',
  Valid = 'VALID'
}

export type DocumentTypeNode = {
  __typename?: 'DocumentTypeNode';
  createdAt: Scalars['DateTime']['output'];
  documents: DocumentNodeConnection;
  id: Scalars['UUID']['output'];
  isIdentityDocument: Scalars['Boolean']['output'];
  key: Scalars['String']['output'];
  label: Scalars['String']['output'];
  uniqueForIndividual: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
  validForDeduplication: Scalars['Boolean']['output'];
};


export type DocumentTypeNodeDocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type EditBankTransferObjectType = {
  accountHolderName: Scalars['String']['input'];
  bankAccountNumber: Scalars['String']['input'];
  bankBranchName?: InputMaybe<Scalars['String']['input']>;
  bankName: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  type: Scalars['String']['input'];
};

export type EditIndividualDocumentObjectType = {
  country: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  key: Scalars['String']['input'];
  number: Scalars['String']['input'];
  photo?: InputMaybe<Scalars['Arg']['input']>;
  photoraw?: InputMaybe<Scalars['Arg']['input']>;
};

export type EditIndividualIdentityObjectType = {
  country: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  number: Scalars['String']['input'];
  partner: Scalars['String']['input'];
};

export type EditPaymentVerificationInput = {
  businessAreaSlug: Scalars['String']['input'];
  fullListArguments?: InputMaybe<FullListArguments>;
  paymentVerificationPlanId: Scalars['ID']['input'];
  randomSamplingArguments?: InputMaybe<RandomSamplingArguments>;
  rapidProArguments?: InputMaybe<RapidProArguments>;
  sampling: Scalars['String']['input'];
  verificationChannel: Scalars['String']['input'];
};

export type EditPaymentVerificationMutation = {
  __typename?: 'EditPaymentVerificationMutation';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type EraseRegistrationDataImportMutation = {
  __typename?: 'EraseRegistrationDataImportMutation';
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
};

export type ExcludeHouseholdsMutation = {
  __typename?: 'ExcludeHouseholdsMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ExportPdfPaymentPlanSummaryMutation = {
  __typename?: 'ExportPDFPaymentPlanSummaryMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ExportSurveySampleMutationMutation = {
  __typename?: 'ExportSurveySampleMutationMutation';
  survey?: Maybe<SurveyNode>;
};

export type ExportXlsxPaymentPlanPaymentListMutation = {
  __typename?: 'ExportXLSXPaymentPlanPaymentListMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ExportXlsxPaymentPlanPaymentListPerFspMutation = {
  __typename?: 'ExportXLSXPaymentPlanPaymentListPerFSPMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ExportXlsxPaymentVerificationPlanFile = {
  __typename?: 'ExportXlsxPaymentVerificationPlanFile';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type FspToDeliveryMechanismMappingInput = {
  chosenConfiguration?: InputMaybe<Scalars['String']['input']>;
  deliveryMechanism: Scalars['String']['input'];
  fspId: Scalars['ID']['input'];
  order: Scalars['Int']['input'];
};

export enum FeedbackIssueType {
  NegativeFeedback = 'NEGATIVE_FEEDBACK',
  PositiveFeedback = 'POSITIVE_FEEDBACK'
}

export type FeedbackMessageNode = Node & {
  __typename?: 'FeedbackMessageNode';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type FeedbackMessageNodeConnection = {
  __typename?: 'FeedbackMessageNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<FeedbackMessageNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type FeedbackMessageNodeEdge = {
  __typename?: 'FeedbackMessageNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<FeedbackMessageNode>;
};

export type FeedbackNode = Node & {
  __typename?: 'FeedbackNode';
  admin2?: Maybe<AreaNode>;
  adminUrl?: Maybe<Scalars['String']['output']>;
  area: Scalars['String']['output'];
  businessArea: UserBusinessAreaNode;
  comments?: Maybe<Scalars['String']['output']>;
  consent: Scalars['Boolean']['output'];
  copiedFrom?: Maybe<FeedbackNode>;
  copiedTo: FeedbackNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  description: Scalars['String']['output'];
  feedbackMessages: FeedbackMessageNodeConnection;
  householdLookup?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individualLookup?: Maybe<IndividualNode>;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  issueType: FeedbackIssueType;
  language: Scalars['String']['output'];
  linkedGrievance?: Maybe<GrievanceTicketNode>;
  migratedAt?: Maybe<Scalars['DateTime']['output']>;
  program?: Maybe<ProgramNode>;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


export type FeedbackNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type FeedbackNodeFeedbackMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type FeedbackNodeConnection = {
  __typename?: 'FeedbackNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<FeedbackNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type FeedbackNodeEdge = {
  __typename?: 'FeedbackNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<FeedbackNode>;
};

export type FieldAttributeNode = {
  __typename?: 'FieldAttributeNode';
  associatedWith?: Maybe<Scalars['String']['output']>;
  choices?: Maybe<Array<Maybe<CoreFieldChoiceObject>>>;
  hint?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isFlexField?: Maybe<Scalars['Boolean']['output']>;
  labelEn?: Maybe<Scalars['String']['output']>;
  labels?: Maybe<Array<Maybe<LabelNode>>>;
  name?: Maybe<Scalars['String']['output']>;
  required?: Maybe<Scalars['Boolean']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

export type FilteredActionsListNode = {
  __typename?: 'FilteredActionsListNode';
  approval?: Maybe<Array<Maybe<ApprovalNode>>>;
  authorization?: Maybe<Array<Maybe<ApprovalNode>>>;
  financeRelease?: Maybe<Array<Maybe<ApprovalNode>>>;
  reject?: Maybe<Array<Maybe<ApprovalNode>>>;
};

export type FinalizeTargetPopulationMutation = {
  __typename?: 'FinalizeTargetPopulationMutation';
  targetPopulation?: Maybe<TargetPopulationNode>;
};

export enum FinancialServiceProviderCommunicationChannel {
  Api = 'API',
  Sftp = 'SFTP',
  Xlsx = 'XLSX'
}

export type FinancialServiceProviderNode = Node & {
  __typename?: 'FinancialServiceProviderNode';
  allowedBusinessAreas: UserBusinessAreaNodeConnection;
  communicationChannel: FinancialServiceProviderCommunicationChannel;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  dataTransferConfiguration?: Maybe<Scalars['JSONString']['output']>;
  deliveryMechanisms: Array<Scalars['String']['output']>;
  deliveryMechanismsPerPaymentPlan: DeliveryMechanismNodeConnection;
  distributionLimit?: Maybe<Scalars['Float']['output']>;
  financialserviceproviderxlsxreportSet: FinancialServiceProviderXlsxReportNodeConnection;
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isPaymentGateway?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  paymentGatewayId?: Maybe<Scalars['String']['output']>;
  paymentSet: PaymentNodeConnection;
  updatedAt: Scalars['DateTime']['output'];
  visionVendorNumber: Scalars['String']['output'];
  xlsxTemplates: FinancialServiceProviderXlsxTemplateNodeConnection;
};


export type FinancialServiceProviderNodeAllowedBusinessAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type FinancialServiceProviderNodeDeliveryMechanismsPerPaymentPlanArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type FinancialServiceProviderNodeFinancialserviceproviderxlsxreportSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type FinancialServiceProviderNodePaymentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type FinancialServiceProviderNodeXlsxTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type FinancialServiceProviderNodeConnection = {
  __typename?: 'FinancialServiceProviderNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<FinancialServiceProviderNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type FinancialServiceProviderNodeEdge = {
  __typename?: 'FinancialServiceProviderNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<FinancialServiceProviderNode>;
};

export type FinancialServiceProviderXlsxReportNode = Node & {
  __typename?: 'FinancialServiceProviderXlsxReportNode';
  createdAt: Scalars['DateTime']['output'];
  financialServiceProvider: FinancialServiceProviderNode;
  id: Scalars['ID']['output'];
  reportUrl?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type FinancialServiceProviderXlsxReportNodeConnection = {
  __typename?: 'FinancialServiceProviderXlsxReportNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<FinancialServiceProviderXlsxReportNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type FinancialServiceProviderXlsxReportNodeEdge = {
  __typename?: 'FinancialServiceProviderXlsxReportNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<FinancialServiceProviderXlsxReportNode>;
};

export type FinancialServiceProviderXlsxTemplateNode = Node & {
  __typename?: 'FinancialServiceProviderXlsxTemplateNode';
  columns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  coreFields: Array<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  financialServiceProviders: FinancialServiceProviderNodeConnection;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};


export type FinancialServiceProviderXlsxTemplateNodeFinancialServiceProvidersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type FinancialServiceProviderXlsxTemplateNodeConnection = {
  __typename?: 'FinancialServiceProviderXlsxTemplateNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<FinancialServiceProviderXlsxTemplateNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type FinancialServiceProviderXlsxTemplateNodeEdge = {
  __typename?: 'FinancialServiceProviderXlsxTemplateNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<FinancialServiceProviderXlsxTemplateNode>;
};

export type FinishPaymentVerificationPlan = {
  __typename?: 'FinishPaymentVerificationPlan';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type FspChoice = {
  __typename?: 'FspChoice';
  configurations?: Maybe<Array<Maybe<FspConfiguration>>>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type FspChoices = {
  __typename?: 'FspChoices';
  deliveryMechanism?: Maybe<Scalars['String']['output']>;
  fsps?: Maybe<Array<Maybe<FspChoice>>>;
};

export type FspConfiguration = {
  __typename?: 'FspConfiguration';
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  label?: Maybe<Scalars['String']['output']>;
};

export type FullListArguments = {
  excludedAdminAreas?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type GenericPaymentNode = {
  __typename?: 'GenericPaymentNode';
  currency?: Maybe<Scalars['String']['output']>;
  deliveredQuantity?: Maybe<Scalars['Float']['output']>;
  deliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  household?: Maybe<HouseholdNode>;
  id?: Maybe<Scalars['String']['output']>;
  objType?: Maybe<Scalars['String']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
};

export type GenericPaymentPlanNode = {
  __typename?: 'GenericPaymentPlanNode';
  availablePaymentRecordsCount?: Maybe<Scalars['Int']['output']>;
  bankReconciliationError?: Maybe<Scalars['Int']['output']>;
  bankReconciliationSuccess?: Maybe<Scalars['Int']['output']>;
  canCreatePaymentVerificationPlan?: Maybe<Scalars['Boolean']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  deliveryType?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  objType?: Maybe<Scalars['String']['output']>;
  paymentVerificationSummary?: Maybe<PaymentVerificationSummaryNode>;
  status?: Maybe<Scalars['String']['output']>;
  statusDate?: Maybe<Scalars['DateTime']['output']>;
  totalDeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantity?: Maybe<Scalars['Float']['output']>;
  totalNumberOfHouseholds?: Maybe<Scalars['Int']['output']>;
  totalUndeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  verificationPlans?: Maybe<PaymentVerificationPlanNodeConnection>;
};


export type GenericPaymentPlanNodeVerificationPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
};

export type GetAccountabilityCommunicationMessageSampleSizeInput = {
  fullListArguments?: InputMaybe<AccountabilityFullListArguments>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  randomSamplingArguments?: InputMaybe<AccountabilityRandomSamplingArguments>;
  registrationDataImport?: InputMaybe<Scalars['ID']['input']>;
  samplingType: SamplingChoices;
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
};

export type GetCashplanVerificationSampleSizeInput = {
  businessAreaSlug: Scalars['String']['input'];
  cashOrPaymentPlanId?: InputMaybe<Scalars['ID']['input']>;
  fullListArguments?: InputMaybe<FullListArguments>;
  paymentVerificationPlanId?: InputMaybe<Scalars['ID']['input']>;
  randomSamplingArguments?: InputMaybe<RandomSamplingArguments>;
  rapidProArguments?: InputMaybe<RapidProArguments>;
  sampling: Scalars['String']['input'];
  verificationChannel: Scalars['String']['input'];
};

export type GetCashplanVerificationSampleSizeObject = {
  __typename?: 'GetCashplanVerificationSampleSizeObject';
  paymentRecordCount?: Maybe<Scalars['Int']['output']>;
  sampleSize?: Maybe<Scalars['Int']['output']>;
};

export type GetCommunicationMessageSampleSizeNode = {
  __typename?: 'GetCommunicationMessageSampleSizeNode';
  numberOfRecipients?: Maybe<Scalars['Int']['output']>;
  sampleSize?: Maybe<Scalars['Int']['output']>;
};

export type GrievanceComplaintTicketExtras = {
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
  paymentRecord?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type GrievanceDocumentInput = {
  file: Scalars['Upload']['input'];
  name: Scalars['String']['input'];
};

export type GrievanceDocumentNode = Node & {
  __typename?: 'GrievanceDocumentNode';
  contentType: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  fileName?: Maybe<Scalars['String']['output']>;
  filePath?: Maybe<Scalars['String']['output']>;
  fileSize?: Maybe<Scalars['Int']['output']>;
  grievanceTicket?: Maybe<GrievanceTicketNode>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type GrievanceDocumentNodeConnection = {
  __typename?: 'GrievanceDocumentNodeConnection';
  edges: Array<Maybe<GrievanceDocumentNodeEdge>>;
  pageInfo: PageInfo;
};

export type GrievanceDocumentNodeEdge = {
  __typename?: 'GrievanceDocumentNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<GrievanceDocumentNode>;
};

export type GrievanceDocumentUpdateInput = {
  file?: InputMaybe<Scalars['Upload']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type GrievanceStatusChangeMutation = {
  __typename?: 'GrievanceStatusChangeMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type GrievanceTicketNode = Node & {
  __typename?: 'GrievanceTicketNode';
  addIndividualTicketDetails?: Maybe<TicketAddIndividualDetailsNode>;
  admin?: Maybe<Scalars['String']['output']>;
  admin2?: Maybe<AreaNode>;
  adminUrl?: Maybe<Scalars['String']['output']>;
  area: Scalars['String']['output'];
  assignedTo?: Maybe<UserNode>;
  businessArea: UserBusinessAreaNode;
  category: Scalars['Int']['output'];
  comments?: Maybe<Scalars['String']['output']>;
  complaintTicketDetails?: Maybe<TicketComplaintDetailsNode>;
  consent: Scalars['Boolean']['output'];
  copiedFrom?: Maybe<GrievanceTicketNode>;
  copiedTo: GrievanceTicketNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  deleteHouseholdTicketDetails?: Maybe<TicketDeleteHouseholdDetailsNode>;
  deleteIndividualTicketDetails?: Maybe<TicketDeleteIndividualDetailsNode>;
  description: Scalars['String']['output'];
  documentation?: Maybe<Array<Maybe<GrievanceDocumentNode>>>;
  existingTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
  extras: Scalars['JSONString']['output'];
  feedback?: Maybe<FeedbackNode>;
  household?: Maybe<HouseholdNode>;
  householdDataUpdateTicketDetails?: Maybe<TicketHouseholdDataUpdateDetailsNode>;
  householdUnicefId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  ignored: Scalars['Boolean']['output'];
  individual?: Maybe<IndividualNode>;
  individualDataUpdateTicketDetails?: Maybe<TicketIndividualDataUpdateDetailsNode>;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  issueType?: Maybe<Scalars['Int']['output']>;
  language: Scalars['String']['output'];
  lastNotificationSent?: Maybe<Scalars['DateTime']['output']>;
  linkedTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
  migratedAt?: Maybe<Scalars['DateTime']['output']>;
  needsAdjudicationTicketDetails?: Maybe<TicketNeedsAdjudicationDetailsNode>;
  negativeFeedbackTicketDetails?: Maybe<TicketNegativeFeedbackDetailsNode>;
  partner?: Maybe<PartnerType>;
  paymentRecord?: Maybe<PaymentRecordAndPaymentNode>;
  paymentVerificationTicketDetails?: Maybe<TicketPaymentVerificationDetailsNode>;
  positiveFeedbackTicketDetails?: Maybe<TicketPositiveFeedbackDetailsNode>;
  priority?: Maybe<Scalars['Int']['output']>;
  programs?: Maybe<Array<Maybe<ProgramNode>>>;
  referralTicketDetails?: Maybe<TicketReferralDetailsNode>;
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  relatedTickets?: Maybe<Array<Maybe<GrievanceTicketNode>>>;
  sensitiveTicketDetails?: Maybe<TicketSensitiveDetailsNode>;
  status: Scalars['Int']['output'];
  supportDocuments: GrievanceDocumentNodeConnection;
  systemFlaggingTicketDetails?: Maybe<TicketSystemFlaggingDetailsNode>;
  ticketNotes: TicketNoteNodeConnection;
  totalDays?: Maybe<Scalars['String']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  urgency?: Maybe<Scalars['Int']['output']>;
  userModified?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['BigInt']['output'];
};


export type GrievanceTicketNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type GrievanceTicketNodeSupportDocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type GrievanceTicketNodeTicketNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type GrievanceTicketNodeConnection = {
  __typename?: 'GrievanceTicketNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<GrievanceTicketNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type GrievanceTicketNodeEdge = {
  __typename?: 'GrievanceTicketNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<GrievanceTicketNode>;
};

export type GroupAttributeNode = {
  __typename?: 'GroupAttributeNode';
  flexAttributes?: Maybe<Array<Maybe<FieldAttributeNode>>>;
  id: Scalars['UUID']['output'];
  label: Scalars['JSONString']['output'];
  labelEn?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
};


export type GroupAttributeNodeFlexAttributesArgs = {
  flexField?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum HouseholdCollectIndividualData {
  A = 'A_',
  A_0 = 'A_0',
  A_1 = 'A_1',
  A_2 = 'A_2',
  A_3 = 'A_3'
}

export enum HouseholdCollectType {
  Single = 'SINGLE',
  Standard = 'STANDARD'
}

export type HouseholdDataChangeApproveMutation = {
  __typename?: 'HouseholdDataChangeApproveMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type HouseholdDataUpdateIssueTypeExtras = {
  household: Scalars['ID']['input'];
  householdData: HouseholdUpdateDataObjectType;
};

export type HouseholdDeleteIssueTypeExtras = {
  household: Scalars['ID']['input'];
};

export type HouseholdNode = Node & {
  __typename?: 'HouseholdNode';
  activeIndividualsCount?: Maybe<Scalars['Int']['output']>;
  addIndividualTicketDetails: TicketAddIndividualDetailsNodeConnection;
  address: Scalars['String']['output'];
  admin1?: Maybe<AreaNode>;
  admin2?: Maybe<AreaNode>;
  admin3?: Maybe<AreaNode>;
  admin4?: Maybe<AreaNode>;
  adminArea?: Maybe<AreaNode>;
  adminAreaTitle?: Maybe<Scalars['String']['output']>;
  adminUrl?: Maybe<Scalars['String']['output']>;
  businessArea: UserBusinessAreaNode;
  childHoh?: Maybe<Scalars['Boolean']['output']>;
  childrenCount?: Maybe<Scalars['Int']['output']>;
  childrenDisabledCount?: Maybe<Scalars['Int']['output']>;
  collectIndividualData: HouseholdCollectIndividualData;
  collectType: HouseholdCollectType;
  complaintTicketDetails: TicketComplaintDetailsNodeConnection;
  consent?: Maybe<Scalars['Boolean']['output']>;
  consentSharing?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  consentSign: Scalars['String']['output'];
  copiedFrom?: Maybe<HouseholdNode>;
  copiedTo: HouseholdNodeConnection;
  country?: Maybe<Scalars['String']['output']>;
  countryOrigin?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  deleteHouseholdTicketDetails: TicketDeleteHouseholdDetailsNodeConnection;
  deliveredQuantities?: Maybe<Array<Maybe<DeliveredQuantityNode>>>;
  detailId?: Maybe<Scalars['String']['output']>;
  deviceid: Scalars['String']['output'];
  familyId?: Maybe<Scalars['String']['output']>;
  fchildHoh?: Maybe<Scalars['Boolean']['output']>;
  feedbacks: FeedbackNodeConnection;
  femaleAgeGroup05Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup05DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup60Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup60DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup611Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup611DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1217Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1217DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1859Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1859DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleChildrenCount?: Maybe<Scalars['Int']['output']>;
  femaleChildrenDisabledCount?: Maybe<Scalars['Int']['output']>;
  firstRegistrationDate: Scalars['DateTime']['output'];
  flexFields?: Maybe<Scalars['FlexFieldsScalar']['output']>;
  geopoint?: Maybe<Scalars['GeoJSON']['output']>;
  hasDuplicates?: Maybe<Scalars['Boolean']['output']>;
  headOfHousehold: IndividualNode;
  householdDataUpdateTicketDetails: TicketHouseholdDataUpdateDetailsNodeConnection;
  id: Scalars['ID']['output'];
  individuals?: Maybe<IndividualNodeConnection>;
  individualsAndRoles: Array<IndividualRoleInHouseholdNode>;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  isRecalculatedGroupAges: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  koboAssetId: Scalars['String']['output'];
  lastRegistrationDate: Scalars['DateTime']['output'];
  lastSyncAt?: Maybe<Scalars['DateTime']['output']>;
  maleAgeGroup05Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup05DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup60Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup60DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup611Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup611DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1217Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1217DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1859Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1859DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleChildrenCount?: Maybe<Scalars['Int']['output']>;
  maleChildrenDisabledCount?: Maybe<Scalars['Int']['output']>;
  messages: CommunicationMessageNodeConnection;
  migratedAt?: Maybe<Scalars['DateTime']['output']>;
  nameEnumerator: Scalars['String']['output'];
  negativeFeedbackTicketDetails: TicketNegativeFeedbackDetailsNodeConnection;
  orgEnumerator: HouseholdOrgEnumerator;
  orgNameEnumerator: Scalars['String']['output'];
  originUnicefId?: Maybe<Scalars['String']['output']>;
  paymentSet: PaymentNodeConnection;
  paymentrecordSet: PaymentRecordNodeConnection;
  positiveFeedbackTicketDetails: TicketPositiveFeedbackDetailsNodeConnection;
  pregnantCount?: Maybe<Scalars['Int']['output']>;
  program?: Maybe<ProgramNode>;
  programs: ProgramNodeConnection;
  referralTicketDetails: TicketReferralDetailsNodeConnection;
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  registrationId?: Maybe<Scalars['Int']['output']>;
  registrationMethod: HouseholdRegistrationMethod;
  removedDate?: Maybe<Scalars['DateTime']['output']>;
  representatives: IndividualNodeConnection;
  residenceStatus?: Maybe<Scalars['String']['output']>;
  returnee?: Maybe<Scalars['Boolean']['output']>;
  rowId?: Maybe<Scalars['Int']['output']>;
  sanctionListConfirmedMatch?: Maybe<Scalars['Boolean']['output']>;
  sanctionListPossibleMatch?: Maybe<Scalars['Boolean']['output']>;
  selection?: Maybe<HouseholdSelectionNode>;
  selections: Array<HouseholdSelectionNode>;
  sensitiveTicketDetails: TicketSensitiveDetailsNodeConnection;
  size?: Maybe<Scalars['Int']['output']>;
  start?: Maybe<Scalars['DateTime']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  surveys: SurveyNodeConnection;
  targetPopulations: TargetPopulationNodeConnection;
  totalCashReceived?: Maybe<Scalars['Decimal']['output']>;
  totalCashReceivedUsd?: Maybe<Scalars['Decimal']['output']>;
  unhcrId: Scalars['String']['output'];
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  userFields: Scalars['JSONString']['output'];
  version: Scalars['BigInt']['output'];
  village: Scalars['String']['output'];
  withdrawn: Scalars['Boolean']['output'];
  withdrawnDate?: Maybe<Scalars['DateTime']['output']>;
  zipCode?: Maybe<Scalars['String']['output']>;
};


export type HouseholdNodeAddIndividualTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeComplaintTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeDeleteHouseholdTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeFeedbacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeHouseholdDataUpdateTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeIndividualsArgs = {
  admin2?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  age?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  excludedId?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  flags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  fullName_Endswith?: InputMaybe<Scalars['String']['input']>;
  fullName_Startswith?: InputMaybe<Scalars['String']['input']>;
  household_AdminArea?: InputMaybe<Scalars['ID']['input']>;
  household_Id?: InputMaybe<Scalars['UUID']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  programs?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
};


export type HouseholdNodeMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeNegativeFeedbackTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodePaymentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodePaymentrecordSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodePositiveFeedbackTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeReferralTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeRepresentativesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeSensitiveTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeSurveysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type HouseholdNodeTargetPopulationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type HouseholdNodeConnection = {
  __typename?: 'HouseholdNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<HouseholdNodeEdge>>;
  individualsCount?: Maybe<Scalars['Int']['output']>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type HouseholdNodeEdge = {
  __typename?: 'HouseholdNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<HouseholdNode>;
};

export enum HouseholdOrgEnumerator {
  A = 'A_',
  Partner = 'PARTNER',
  Unicef = 'UNICEF'
}

export enum HouseholdRegistrationMethod {
  A = 'A_',
  Community = 'COMMUNITY',
  HhRegistration = 'HH_REGISTRATION'
}

export type HouseholdSelectionNode = {
  __typename?: 'HouseholdSelectionNode';
  createdAt: Scalars['DateTime']['output'];
  household: HouseholdNode;
  id: Scalars['UUID']['output'];
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  targetPopulation: TargetPopulationNode;
  updatedAt: Scalars['DateTime']['output'];
  vulnerabilityScore?: Maybe<Scalars['Float']['output']>;
};

export type HouseholdUpdateDataObjectType = {
  address?: InputMaybe<Scalars['String']['input']>;
  adminAreaTitle?: InputMaybe<Scalars['String']['input']>;
  childHoh?: InputMaybe<Scalars['Boolean']['input']>;
  collectIndividualData?: InputMaybe<Scalars['String']['input']>;
  consent?: InputMaybe<Scalars['Boolean']['input']>;
  consentSharing?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  country?: InputMaybe<Scalars['String']['input']>;
  countryOrigin?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  end?: InputMaybe<Scalars['DateTime']['input']>;
  fchildHoh?: InputMaybe<Scalars['Boolean']['input']>;
  femaleAgeGroup05Count?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup05DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup60Count?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup60DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup611Count?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup611DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup1217Count?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup1217DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup1859Count?: InputMaybe<Scalars['Int']['input']>;
  femaleAgeGroup1859DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  flexFields?: InputMaybe<Scalars['Arg']['input']>;
  maleAgeGroup05Count?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup05DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup60Count?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup60DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup611Count?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup611DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup1217Count?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup1217DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup1859Count?: InputMaybe<Scalars['Int']['input']>;
  maleAgeGroup1859DisabledCount?: InputMaybe<Scalars['Int']['input']>;
  nameEnumerator?: InputMaybe<Scalars['String']['input']>;
  orgEnumerator?: InputMaybe<Scalars['String']['input']>;
  orgNameEnumerator?: InputMaybe<Scalars['String']['input']>;
  pregnantCount?: InputMaybe<Scalars['Int']['input']>;
  registrationMethod?: InputMaybe<Scalars['String']['input']>;
  residenceStatus?: InputMaybe<Scalars['String']['input']>;
  returnee?: InputMaybe<Scalars['Boolean']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  unhcrId?: InputMaybe<Scalars['String']['input']>;
  village?: InputMaybe<Scalars['String']['input']>;
};

export enum ImportDataDataType {
  Flex = 'FLEX',
  Json = 'JSON',
  Xlsx = 'XLSX'
}

export type ImportDataNode = Node & {
  __typename?: 'ImportDataNode';
  businessAreaSlug: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdById?: Maybe<Scalars['UUID']['output']>;
  dataType: ImportDataDataType;
  error: Scalars['String']['output'];
  file?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  koboimportdata?: Maybe<KoboImportDataNode>;
  numberOfHouseholds?: Maybe<Scalars['Int']['output']>;
  numberOfIndividuals?: Maybe<Scalars['Int']['output']>;
  registrationDataImport?: Maybe<RegistrationDataImportDatahubNode>;
  status: ImportDataStatus;
  updatedAt: Scalars['DateTime']['output'];
  validationErrors: Scalars['String']['output'];
  xlsxValidationErrors?: Maybe<Array<Maybe<XlsxRowErrorNode>>>;
};

export enum ImportDataStatus {
  Error = 'ERROR',
  Finished = 'FINISHED',
  Pending = 'PENDING',
  Running = 'RUNNING',
  ValidationError = 'VALIDATION_ERROR'
}

export type ImportXlsxPaymentPlanPaymentListMutation = {
  __typename?: 'ImportXLSXPaymentPlanPaymentListMutation';
  errors?: Maybe<Array<Maybe<XlsxErrorNode>>>;
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ImportXlsxPaymentPlanPaymentListPerFspMutation = {
  __typename?: 'ImportXLSXPaymentPlanPaymentListPerFSPMutation';
  errors?: Maybe<Array<Maybe<XlsxErrorNode>>>;
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type ImportXlsxPaymentVerificationPlanFile = {
  __typename?: 'ImportXlsxPaymentVerificationPlanFile';
  errors?: Maybe<Array<Maybe<XlsxErrorNode>>>;
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type ImportedDocumentNode = Node & {
  __typename?: 'ImportedDocumentNode';
  country?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  docDate?: Maybe<Scalars['Date']['output']>;
  documentNumber: Scalars['String']['output'];
  expiryDate?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  individual: ImportedIndividualNode;
  issuanceDate?: Maybe<Scalars['Date']['output']>;
  photo?: Maybe<Scalars['String']['output']>;
  type: ImportedDocumentTypeNode;
  updatedAt: Scalars['DateTime']['output'];
};

export type ImportedDocumentNodeConnection = {
  __typename?: 'ImportedDocumentNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ImportedDocumentNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ImportedDocumentNodeEdge = {
  __typename?: 'ImportedDocumentNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ImportedDocumentNode>;
};

export type ImportedDocumentTypeNode = {
  __typename?: 'ImportedDocumentTypeNode';
  createdAt: Scalars['DateTime']['output'];
  documents: ImportedDocumentNodeConnection;
  id: Scalars['UUID']['output'];
  isIdentityDocument: Scalars['Boolean']['output'];
  key: Scalars['String']['output'];
  label: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};


export type ImportedDocumentTypeNodeDocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export enum ImportedHouseholdCollectIndividualData {
  A = 'A_',
  A_0 = 'A_0',
  A_1 = 'A_1',
  A_2 = 'A_2'
}

export enum ImportedHouseholdCollectType {
  Single = 'SINGLE',
  Standard = 'STANDARD'
}

export enum ImportedHouseholdConsentSharing {
  A = 'A_',
  GovernmentPartner = 'GOVERNMENT_PARTNER',
  HumanitarianPartner = 'HUMANITARIAN_PARTNER',
  PrivatePartner = 'PRIVATE_PARTNER',
  Unicef = 'UNICEF'
}

export enum ImportedHouseholdCurrency {
  Aed = 'AED',
  Afn = 'AFN',
  All = 'ALL',
  Amd = 'AMD',
  Ang = 'ANG',
  Aoa = 'AOA',
  Ars = 'ARS',
  Aud = 'AUD',
  Awg = 'AWG',
  Azn = 'AZN',
  A = 'A_',
  Bam = 'BAM',
  Bbd = 'BBD',
  Bdt = 'BDT',
  Bgn = 'BGN',
  Bhd = 'BHD',
  Bif = 'BIF',
  Bmd = 'BMD',
  Bnd = 'BND',
  Bob = 'BOB',
  Bov = 'BOV',
  Brl = 'BRL',
  Bsd = 'BSD',
  Btn = 'BTN',
  Bwp = 'BWP',
  Byn = 'BYN',
  Bzd = 'BZD',
  Cad = 'CAD',
  Cdf = 'CDF',
  Chf = 'CHF',
  Clp = 'CLP',
  Cny = 'CNY',
  Cop = 'COP',
  Crc = 'CRC',
  Cuc = 'CUC',
  Cup = 'CUP',
  Cve = 'CVE',
  Czk = 'CZK',
  Djf = 'DJF',
  Dkk = 'DKK',
  Dop = 'DOP',
  Dzd = 'DZD',
  Egp = 'EGP',
  Ern = 'ERN',
  Etb = 'ETB',
  Eur = 'EUR',
  Fjd = 'FJD',
  Fkp = 'FKP',
  Gbp = 'GBP',
  Gel = 'GEL',
  Ghs = 'GHS',
  Gip = 'GIP',
  Gmd = 'GMD',
  Gnf = 'GNF',
  Gtq = 'GTQ',
  Gyd = 'GYD',
  Hkd = 'HKD',
  Hnl = 'HNL',
  Hrk = 'HRK',
  Htg = 'HTG',
  Huf = 'HUF',
  Idr = 'IDR',
  Ils = 'ILS',
  Inr = 'INR',
  Iqd = 'IQD',
  Irr = 'IRR',
  Isk = 'ISK',
  Jmd = 'JMD',
  Jod = 'JOD',
  Jpy = 'JPY',
  Kes = 'KES',
  Kgs = 'KGS',
  Khr = 'KHR',
  Kmf = 'KMF',
  Kpw = 'KPW',
  Krw = 'KRW',
  Kwd = 'KWD',
  Kyd = 'KYD',
  Kzt = 'KZT',
  Lak = 'LAK',
  Lbp = 'LBP',
  Lkr = 'LKR',
  Lrd = 'LRD',
  Lsl = 'LSL',
  Lyd = 'LYD',
  Mad = 'MAD',
  Mdl = 'MDL',
  Mga = 'MGA',
  Mkd = 'MKD',
  Mmk = 'MMK',
  Mnt = 'MNT',
  Mop = 'MOP',
  Mru = 'MRU',
  Mur = 'MUR',
  Mvr = 'MVR',
  Mwk = 'MWK',
  Mxn = 'MXN',
  Myr = 'MYR',
  Mzn = 'MZN',
  Nad = 'NAD',
  Ngn = 'NGN',
  Nio = 'NIO',
  Nok = 'NOK',
  Npr = 'NPR',
  Nzd = 'NZD',
  Omr = 'OMR',
  Pab = 'PAB',
  Pen = 'PEN',
  Pgk = 'PGK',
  Php = 'PHP',
  Pkr = 'PKR',
  Pln = 'PLN',
  Pyg = 'PYG',
  Qar = 'QAR',
  Ron = 'RON',
  Rsd = 'RSD',
  Rub = 'RUB',
  Rwf = 'RWF',
  Sar = 'SAR',
  Sbd = 'SBD',
  Scr = 'SCR',
  Sdg = 'SDG',
  Sek = 'SEK',
  Sgd = 'SGD',
  Shp = 'SHP',
  Sll = 'SLL',
  Sos = 'SOS',
  Srd = 'SRD',
  Ssp = 'SSP',
  Stn = 'STN',
  Svc = 'SVC',
  Syp = 'SYP',
  Szl = 'SZL',
  Thb = 'THB',
  Tjs = 'TJS',
  Tmt = 'TMT',
  Tnd = 'TND',
  Top = 'TOP',
  Try = 'TRY',
  Ttd = 'TTD',
  Twd = 'TWD',
  Tzs = 'TZS',
  Uah = 'UAH',
  Ugx = 'UGX',
  Usd = 'USD',
  Uyu = 'UYU',
  Uyw = 'UYW',
  Uzs = 'UZS',
  Ves = 'VES',
  Vnd = 'VND',
  Vuv = 'VUV',
  Wst = 'WST',
  Xaf = 'XAF',
  Xag = 'XAG',
  Xau = 'XAU',
  Xcd = 'XCD',
  Xof = 'XOF',
  Xpf = 'XPF',
  Yer = 'YER',
  Zar = 'ZAR',
  Zmw = 'ZMW',
  Zwl = 'ZWL'
}

export type ImportedHouseholdNode = Node & {
  __typename?: 'ImportedHouseholdNode';
  address: Scalars['String']['output'];
  admin1: Scalars['String']['output'];
  admin1Title: Scalars['String']['output'];
  admin2: Scalars['String']['output'];
  admin2Title: Scalars['String']['output'];
  admin3: Scalars['String']['output'];
  admin3Title: Scalars['String']['output'];
  admin4: Scalars['String']['output'];
  admin4Title: Scalars['String']['output'];
  adminArea: Scalars['String']['output'];
  adminAreaTitle: Scalars['String']['output'];
  childHoh?: Maybe<Scalars['Boolean']['output']>;
  collectIndividualData: ImportedHouseholdCollectIndividualData;
  collectType: ImportedHouseholdCollectType;
  consent?: Maybe<Scalars['Boolean']['output']>;
  consentSharing: ImportedHouseholdConsentSharing;
  consentSign: Scalars['String']['output'];
  country?: Maybe<Scalars['String']['output']>;
  countryOrigin?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  currency: ImportedHouseholdCurrency;
  detailId?: Maybe<Scalars['String']['output']>;
  deviceid: Scalars['String']['output'];
  enumeratorRecId?: Maybe<Scalars['Int']['output']>;
  fchildHoh?: Maybe<Scalars['Boolean']['output']>;
  femaleAgeGroup05Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup05DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup60Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup60DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup611Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup611DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1217Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1217DisabledCount?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1859Count?: Maybe<Scalars['Int']['output']>;
  femaleAgeGroup1859DisabledCount?: Maybe<Scalars['Int']['output']>;
  firstRegistrationDate: Scalars['DateTime']['output'];
  flexFields?: Maybe<Scalars['Arg']['output']>;
  geopoint?: Maybe<Scalars['GeoJSON']['output']>;
  hasDuplicates?: Maybe<Scalars['Boolean']['output']>;
  headOfHousehold?: Maybe<ImportedIndividualNode>;
  id: Scalars['ID']['output'];
  importId?: Maybe<Scalars['String']['output']>;
  individuals: ImportedIndividualNodeConnection;
  koboAssetId: Scalars['String']['output'];
  koboSubmissionTime?: Maybe<Scalars['DateTime']['output']>;
  koboSubmissionUuid?: Maybe<Scalars['UUID']['output']>;
  lastRegistrationDate: Scalars['DateTime']['output'];
  maleAgeGroup05Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup05DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup60Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup60DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup611Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup611DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1217Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1217DisabledCount?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1859Count?: Maybe<Scalars['Int']['output']>;
  maleAgeGroup1859DisabledCount?: Maybe<Scalars['Int']['output']>;
  misUnicefId?: Maybe<Scalars['String']['output']>;
  nameEnumerator: Scalars['String']['output'];
  orgEnumerator?: Maybe<ImportedHouseholdOrgEnumerator>;
  orgNameEnumerator: Scalars['String']['output'];
  pregnantCount?: Maybe<Scalars['Int']['output']>;
  programId?: Maybe<Scalars['UUID']['output']>;
  registrationDataImport: RegistrationDataImportDatahubNode;
  registrationMethod: ImportedHouseholdRegistrationMethod;
  residenceStatus: ImportedHouseholdResidenceStatus;
  returnee?: Maybe<Scalars['Boolean']['output']>;
  rowId?: Maybe<Scalars['Int']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  start?: Maybe<Scalars['DateTime']['output']>;
  unhcrId: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  village: Scalars['String']['output'];
  zipCode?: Maybe<Scalars['String']['output']>;
};


export type ImportedHouseholdNodeIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type ImportedHouseholdNodeConnection = {
  __typename?: 'ImportedHouseholdNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ImportedHouseholdNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ImportedHouseholdNodeEdge = {
  __typename?: 'ImportedHouseholdNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ImportedHouseholdNode>;
};

export enum ImportedHouseholdOrgEnumerator {
  A = 'A_',
  Partner = 'PARTNER',
  Unicef = 'UNICEF'
}

export enum ImportedHouseholdRegistrationMethod {
  A = 'A_',
  Community = 'COMMUNITY',
  HhRegistration = 'HH_REGISTRATION'
}

export enum ImportedHouseholdResidenceStatus {
  A = 'A_',
  Host = 'HOST',
  Idp = 'IDP',
  NonHost = 'NON_HOST',
  OthersOfConcern = 'OTHERS_OF_CONCERN',
  Refugee = 'REFUGEE',
  Returnee = 'RETURNEE'
}

export enum ImportedIndividualDeduplicationBatchStatus {
  DuplicateInBatch = 'DUPLICATE_IN_BATCH',
  NotProcessed = 'NOT_PROCESSED',
  SimilarInBatch = 'SIMILAR_IN_BATCH',
  UniqueInBatch = 'UNIQUE_IN_BATCH'
}

export enum ImportedIndividualDeduplicationGoldenRecordStatus {
  Duplicate = 'DUPLICATE',
  NeedsAdjudication = 'NEEDS_ADJUDICATION',
  NotProcessed = 'NOT_PROCESSED',
  Postpone = 'POSTPONE',
  Unique = 'UNIQUE'
}

export enum ImportedIndividualDisability {
  Disabled = 'DISABLED',
  NotDisabled = 'NOT_DISABLED'
}

export type ImportedIndividualIdentityNode = Node & {
  __typename?: 'ImportedIndividualIdentityNode';
  country?: Maybe<Scalars['String']['output']>;
  documentNumber: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  individual: ImportedIndividualNode;
  partner?: Maybe<Scalars['String']['output']>;
};

export type ImportedIndividualIdentityNodeConnection = {
  __typename?: 'ImportedIndividualIdentityNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ImportedIndividualIdentityNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ImportedIndividualIdentityNodeEdge = {
  __typename?: 'ImportedIndividualIdentityNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ImportedIndividualIdentityNode>;
};

export enum ImportedIndividualMaritalStatus {
  A = 'A_',
  Divorced = 'DIVORCED',
  Married = 'MARRIED',
  Separated = 'SEPARATED',
  Single = 'SINGLE',
  Widowed = 'WIDOWED'
}

export type ImportedIndividualNode = Node & {
  __typename?: 'ImportedIndividualNode';
  age?: Maybe<Scalars['Int']['output']>;
  ageAtRegistration?: Maybe<Scalars['Int']['output']>;
  birthDate: Scalars['Date']['output'];
  commsDisability: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  deduplicationBatchResults?: Maybe<Array<Maybe<DeduplicationResultNode>>>;
  deduplicationBatchStatus?: Maybe<ImportedIndividualDeduplicationBatchStatus>;
  deduplicationGoldenRecordResults?: Maybe<Array<Maybe<DeduplicationResultNode>>>;
  deduplicationGoldenRecordStatus?: Maybe<ImportedIndividualDeduplicationGoldenRecordStatus>;
  detailId?: Maybe<Scalars['String']['output']>;
  disability: ImportedIndividualDisability;
  disabilityCertificatePicture?: Maybe<Scalars['String']['output']>;
  documents: ImportedDocumentNodeConnection;
  email?: Maybe<Scalars['String']['output']>;
  estimatedBirthDate?: Maybe<Scalars['Boolean']['output']>;
  familyName: Scalars['String']['output'];
  firstRegistrationDate: Scalars['Date']['output'];
  flexFields?: Maybe<Scalars['FlexFieldsScalar']['output']>;
  fullName: Scalars['String']['output'];
  givenName: Scalars['String']['output'];
  hearingDisability: Scalars['String']['output'];
  household?: Maybe<ImportedHouseholdNode>;
  id: Scalars['ID']['output'];
  identities: ImportedIndividualIdentityNodeConnection;
  importId?: Maybe<Scalars['String']['output']>;
  importedhousehold?: Maybe<ImportedHouseholdNode>;
  individualId: Scalars['String']['output'];
  koboAssetId: Scalars['String']['output'];
  lastRegistrationDate: Scalars['Date']['output'];
  maritalStatus: ImportedIndividualMaritalStatus;
  memoryDisability: Scalars['String']['output'];
  middleName: Scalars['String']['output'];
  misUnicefId?: Maybe<Scalars['String']['output']>;
  observedDisability?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  paymentDeliveryPhoneNo: Scalars['String']['output'];
  phoneNo: Scalars['String']['output'];
  phoneNoAlternative: Scalars['String']['output'];
  phoneNoAlternativeValid?: Maybe<Scalars['Boolean']['output']>;
  phoneNoValid?: Maybe<Scalars['Boolean']['output']>;
  photo: Scalars['String']['output'];
  physicalDisability: Scalars['String']['output'];
  preferredLanguage?: Maybe<Scalars['String']['output']>;
  pregnant?: Maybe<Scalars['Boolean']['output']>;
  programId?: Maybe<Scalars['UUID']['output']>;
  registrationDataImport: RegistrationDataImportDatahubNode;
  relationship?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['String']['output']>;
  rowId?: Maybe<Scalars['Int']['output']>;
  seeingDisability: Scalars['String']['output'];
  selfcareDisability: Scalars['String']['output'];
  sex: ImportedIndividualSex;
  updatedAt: Scalars['DateTime']['output'];
  whoAnswersAltPhone: Scalars['String']['output'];
  whoAnswersPhone: Scalars['String']['output'];
  workStatus: Scalars['String']['output'];
};


export type ImportedIndividualNodeDocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ImportedIndividualNodeIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type ImportedIndividualNodeConnection = {
  __typename?: 'ImportedIndividualNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ImportedIndividualNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ImportedIndividualNodeEdge = {
  __typename?: 'ImportedIndividualNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ImportedIndividualNode>;
};

export enum ImportedIndividualSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

export type IndividualDataChangeApproveMutation = {
  __typename?: 'IndividualDataChangeApproveMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type IndividualDataUpdateIssueTypeExtras = {
  individual: Scalars['ID']['input'];
  individualData: IndividualUpdateDataObjectType;
};

export enum IndividualDeduplicationBatchStatus {
  DuplicateInBatch = 'DUPLICATE_IN_BATCH',
  NotProcessed = 'NOT_PROCESSED',
  SimilarInBatch = 'SIMILAR_IN_BATCH',
  UniqueInBatch = 'UNIQUE_IN_BATCH'
}

export enum IndividualDeduplicationGoldenRecordStatus {
  Duplicate = 'DUPLICATE',
  NeedsAdjudication = 'NEEDS_ADJUDICATION',
  NotProcessed = 'NOT_PROCESSED',
  Postpone = 'POSTPONE',
  Unique = 'UNIQUE'
}

export type IndividualDeleteIssueTypeExtras = {
  individual: Scalars['ID']['input'];
};

export enum IndividualDisability {
  Disabled = 'DISABLED',
  NotDisabled = 'NOT_DISABLED'
}

export type IndividualDocumentObjectType = {
  country: Scalars['String']['input'];
  key: Scalars['String']['input'];
  number: Scalars['String']['input'];
  photo?: InputMaybe<Scalars['Arg']['input']>;
  photoraw?: InputMaybe<Scalars['Arg']['input']>;
};

export type IndividualIdentityNode = Node & {
  __typename?: 'IndividualIdentityNode';
  copiedFrom?: Maybe<IndividualIdentityNode>;
  copiedTo: IndividualIdentityNodeConnection;
  country?: Maybe<Scalars['String']['output']>;
  countryIso3?: Maybe<Scalars['String']['output']>;
  created: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  individual: IndividualNode;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  modified: Scalars['DateTime']['output'];
  number: Scalars['String']['output'];
  partner?: Maybe<Scalars['String']['output']>;
};


export type IndividualIdentityNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type IndividualIdentityNodeConnection = {
  __typename?: 'IndividualIdentityNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<IndividualIdentityNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type IndividualIdentityNodeEdge = {
  __typename?: 'IndividualIdentityNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<IndividualIdentityNode>;
};

export type IndividualIdentityObjectType = {
  country: Scalars['String']['input'];
  number: Scalars['String']['input'];
  partner: Scalars['String']['input'];
};

export enum IndividualMaritalStatus {
  A = 'A_',
  Divorced = 'DIVORCED',
  Married = 'MARRIED',
  Separated = 'SEPARATED',
  Single = 'SINGLE',
  Widowed = 'WIDOWED'
}

export type IndividualNode = Node & {
  __typename?: 'IndividualNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  administrationOfRutf?: Maybe<Scalars['Boolean']['output']>;
  age?: Maybe<Scalars['Int']['output']>;
  ageAtRegistration?: Maybe<Scalars['Int']['output']>;
  bankAccountInfo?: Maybe<BankAccountInfoNode>;
  birthDate: Scalars['Date']['output'];
  businessArea: UserBusinessAreaNode;
  childHoh: Scalars['Boolean']['output'];
  collectorPayments: PaymentNodeConnection;
  commsDisability: Scalars['String']['output'];
  complaintTicketDetails: TicketComplaintDetailsNodeConnection;
  copiedFrom?: Maybe<IndividualNode>;
  copiedTo: IndividualNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  deduplicationBatchResults?: Maybe<Array<Maybe<DeduplicationResultNode>>>;
  deduplicationBatchStatus: IndividualDeduplicationBatchStatus;
  deduplicationGoldenRecordResults?: Maybe<Array<Maybe<DeduplicationResultNode>>>;
  deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus;
  deleteIndividualTicketDetails: TicketDeleteIndividualDetailsNodeConnection;
  detailId?: Maybe<Scalars['String']['output']>;
  disability: IndividualDisability;
  disabilityCertificatePicture?: Maybe<Scalars['String']['output']>;
  documents: DocumentNodeConnection;
  duplicate: Scalars['Boolean']['output'];
  duplicateDate?: Maybe<Scalars['DateTime']['output']>;
  email: Scalars['String']['output'];
  enrolledInNutritionProgramme?: Maybe<Scalars['Boolean']['output']>;
  estimatedBirthDate?: Maybe<Scalars['Boolean']['output']>;
  familyName: Scalars['String']['output'];
  fchildHoh: Scalars['Boolean']['output'];
  feedbacks: FeedbackNodeConnection;
  firstRegistrationDate: Scalars['Date']['output'];
  flexFields?: Maybe<Scalars['FlexFieldsScalar']['output']>;
  fullName: Scalars['String']['output'];
  givenName: Scalars['String']['output'];
  headingHousehold?: Maybe<HouseholdNode>;
  hearingDisability: Scalars['String']['output'];
  household?: Maybe<HouseholdNode>;
  householdsAndRoles: Array<IndividualRoleInHouseholdNode>;
  id: Scalars['ID']['output'];
  identities: IndividualIdentityNodeConnection;
  importedIndividualId?: Maybe<Scalars['UUID']['output']>;
  individualDataUpdateTicketDetails: TicketIndividualDataUpdateDetailsNodeConnection;
  individualId: Scalars['String']['output'];
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  koboAssetId: Scalars['String']['output'];
  lastRegistrationDate: Scalars['Date']['output'];
  lastSyncAt?: Maybe<Scalars['DateTime']['output']>;
  maritalStatus: IndividualMaritalStatus;
  memoryDisability: Scalars['String']['output'];
  middleName: Scalars['String']['output'];
  migratedAt?: Maybe<Scalars['DateTime']['output']>;
  negativeFeedbackTicketDetails: TicketNegativeFeedbackDetailsNodeConnection;
  observedDisability?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  originUnicefId?: Maybe<Scalars['String']['output']>;
  paymentChannels?: Maybe<Array<Maybe<BankAccountInfoNode>>>;
  paymentDeliveryPhoneNo?: Maybe<Scalars['String']['output']>;
  paymentSet: PaymentNodeConnection;
  paymentrecordSet: PaymentRecordNodeConnection;
  phoneNo: Scalars['String']['output'];
  phoneNoAlternative: Scalars['String']['output'];
  phoneNoAlternativeValid?: Maybe<Scalars['Boolean']['output']>;
  phoneNoValid?: Maybe<Scalars['Boolean']['output']>;
  photo?: Maybe<Scalars['String']['output']>;
  physicalDisability: Scalars['String']['output'];
  positiveFeedbackTicketDetails: TicketPositiveFeedbackDetailsNodeConnection;
  preferredLanguage?: Maybe<Scalars['String']['output']>;
  pregnant?: Maybe<Scalars['Boolean']['output']>;
  program?: Maybe<ProgramNode>;
  referralTicketDetails: TicketReferralDetailsNodeConnection;
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  registrationId?: Maybe<Scalars['Int']['output']>;
  relationship?: Maybe<IndividualRelationship>;
  relationshipConfirmed: Scalars['Boolean']['output'];
  removedDate?: Maybe<Scalars['DateTime']['output']>;
  representedHouseholds: HouseholdNodeConnection;
  role?: Maybe<Scalars['String']['output']>;
  rowId?: Maybe<Scalars['Int']['output']>;
  sanctionListConfirmedMatch: Scalars['Boolean']['output'];
  sanctionListLastCheck?: Maybe<Scalars['DateTime']['output']>;
  sanctionListPossibleMatch: Scalars['Boolean']['output'];
  seeingDisability: Scalars['String']['output'];
  selfcareDisability: Scalars['String']['output'];
  sensitiveTicketDetails: TicketSensitiveDetailsNodeConnection;
  sex: IndividualSex;
  status?: Maybe<Scalars['String']['output']>;
  ticketDuplicates: TicketNeedsAdjudicationDetailsNodeConnection;
  ticketGoldenRecords: TicketNeedsAdjudicationDetailsNodeConnection;
  ticketSelected: TicketNeedsAdjudicationDetailsNodeConnection;
  ticketsystemflaggingdetailsSet: TicketSystemFlaggingDetailsNodeConnection;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  userFields: Scalars['JSONString']['output'];
  version: Scalars['BigInt']['output'];
  whoAnswersAltPhone: Scalars['String']['output'];
  whoAnswersPhone: Scalars['String']['output'];
  withdrawn: Scalars['Boolean']['output'];
  withdrawnDate?: Maybe<Scalars['DateTime']['output']>;
  workStatus: Scalars['String']['output'];
};


export type IndividualNodeCollectorPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeComplaintTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeCopiedToArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeDeleteIndividualTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeDocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeFeedbacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeIndividualDataUpdateTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeNegativeFeedbackTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodePaymentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodePaymentrecordSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodePositiveFeedbackTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeReferralTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeRepresentedHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeSensitiveTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeTicketDuplicatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeTicketGoldenRecordsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeTicketSelectedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type IndividualNodeTicketsystemflaggingdetailsSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type IndividualNodeConnection = {
  __typename?: 'IndividualNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<IndividualNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type IndividualNodeEdge = {
  __typename?: 'IndividualNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<IndividualNode>;
};

export enum IndividualRelationship {
  AuntUncle = 'AUNT_UNCLE',
  BrotherSister = 'BROTHER_SISTER',
  Cousin = 'COUSIN',
  DaughterinlawSoninlaw = 'DAUGHTERINLAW_SONINLAW',
  FosterChild = 'FOSTER_CHILD',
  FreeUnion = 'FREE_UNION',
  GranddaugherGrandson = 'GRANDDAUGHER_GRANDSON',
  GrandmotherGrandfather = 'GRANDMOTHER_GRANDFATHER',
  Head = 'HEAD',
  MotherinlawFatherinlaw = 'MOTHERINLAW_FATHERINLAW',
  MotherFather = 'MOTHER_FATHER',
  NephewNiece = 'NEPHEW_NIECE',
  NonBeneficiary = 'NON_BENEFICIARY',
  Other = 'OTHER',
  SisterinlawBrotherinlaw = 'SISTERINLAW_BROTHERINLAW',
  SonDaughter = 'SON_DAUGHTER',
  Unknown = 'UNKNOWN',
  WifeHusband = 'WIFE_HUSBAND'
}

export type IndividualRoleInHouseholdNode = {
  __typename?: 'IndividualRoleInHouseholdNode';
  copiedFrom?: Maybe<IndividualRoleInHouseholdNode>;
  copiedTo: Array<IndividualRoleInHouseholdNode>;
  createdAt: Scalars['DateTime']['output'];
  household: HouseholdNode;
  id: Scalars['UUID']['output'];
  individual: IndividualNode;
  isMigrationHandled: Scalars['Boolean']['output'];
  isOriginal: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  lastSyncAt?: Maybe<Scalars['DateTime']['output']>;
  migratedAt?: Maybe<Scalars['DateTime']['output']>;
  role?: Maybe<IndividualRoleInHouseholdRole>;
  updatedAt: Scalars['DateTime']['output'];
};

export enum IndividualRoleInHouseholdRole {
  Alternate = 'ALTERNATE',
  NoRole = 'NO_ROLE',
  Primary = 'PRIMARY'
}

export enum IndividualSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

export type IndividualUpdateDataObjectType = {
  administrationOfRutf?: InputMaybe<Scalars['Boolean']['input']>;
  birthDate?: InputMaybe<Scalars['Date']['input']>;
  commsDisability?: InputMaybe<Scalars['String']['input']>;
  disability?: InputMaybe<Scalars['String']['input']>;
  documents?: InputMaybe<Array<InputMaybe<IndividualDocumentObjectType>>>;
  documentsToEdit?: InputMaybe<Array<InputMaybe<EditIndividualDocumentObjectType>>>;
  documentsToRemove?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  email?: InputMaybe<Scalars['String']['input']>;
  enrolledInNutritionProgramme?: InputMaybe<Scalars['Boolean']['input']>;
  estimatedBirthDate?: InputMaybe<Scalars['Boolean']['input']>;
  familyName?: InputMaybe<Scalars['String']['input']>;
  flexFields?: InputMaybe<Scalars['Arg']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  givenName?: InputMaybe<Scalars['String']['input']>;
  hearingDisability?: InputMaybe<Scalars['String']['input']>;
  identities?: InputMaybe<Array<InputMaybe<IndividualIdentityObjectType>>>;
  identitiesToEdit?: InputMaybe<Array<InputMaybe<EditIndividualIdentityObjectType>>>;
  identitiesToRemove?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  maritalStatus?: InputMaybe<Scalars['String']['input']>;
  memoryDisability?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  observedDisability?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  paymentChannels?: InputMaybe<Array<InputMaybe<BankTransferObjectType>>>;
  paymentChannelsToEdit?: InputMaybe<Array<InputMaybe<EditBankTransferObjectType>>>;
  paymentChannelsToRemove?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  paymentDeliveryPhoneNo?: InputMaybe<Scalars['String']['input']>;
  phoneNo?: InputMaybe<Scalars['String']['input']>;
  phoneNoAlternative?: InputMaybe<Scalars['String']['input']>;
  physicalDisability?: InputMaybe<Scalars['String']['input']>;
  preferredLanguage?: InputMaybe<Scalars['String']['input']>;
  pregnant?: InputMaybe<Scalars['Boolean']['input']>;
  relationship?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['String']['input']>;
  seeingDisability?: InputMaybe<Scalars['String']['input']>;
  selfcareDisability?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  whoAnswersAltPhone?: InputMaybe<Scalars['String']['input']>;
  whoAnswersPhone?: InputMaybe<Scalars['String']['input']>;
  workStatus?: InputMaybe<Scalars['String']['input']>;
};

export type InvalidPaymentVerificationPlan = {
  __typename?: 'InvalidPaymentVerificationPlan';
  paymentPlan?: Maybe<GenericPaymentPlanNode>;
};

export type IssueTypeExtrasInput = {
  addIndividualIssueTypeExtras?: InputMaybe<AddIndividualIssueTypeExtras>;
  householdDataUpdateIssueTypeExtras?: InputMaybe<HouseholdDataUpdateIssueTypeExtras>;
  householdDeleteIssueTypeExtras?: InputMaybe<HouseholdDeleteIssueTypeExtras>;
  individualDataUpdateIssueTypeExtras?: InputMaybe<IndividualDataUpdateIssueTypeExtras>;
  individualDeleteIssueTypeExtras?: InputMaybe<IndividualDeleteIssueTypeExtras>;
};

export type IssueTypesObject = {
  __typename?: 'IssueTypesObject';
  category?: Maybe<Scalars['String']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  subCategories?: Maybe<Array<Maybe<ChoiceObject>>>;
};

export type KoboAssetObject = {
  __typename?: 'KoboAssetObject';
  assetType?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  dateModified?: Maybe<Scalars['DateTime']['output']>;
  deploymentActive?: Maybe<Scalars['Boolean']['output']>;
  hasDeployment?: Maybe<Scalars['Boolean']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  sector?: Maybe<Scalars['String']['output']>;
  xlsLink?: Maybe<Scalars['String']['output']>;
};

export type KoboAssetObjectConnection = {
  __typename?: 'KoboAssetObjectConnection';
  edges: Array<Maybe<KoboAssetObjectEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type KoboAssetObjectEdge = {
  __typename?: 'KoboAssetObjectEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<KoboAssetObject>;
};

export type KoboErrorNode = {
  __typename?: 'KoboErrorNode';
  header?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
};

export type KoboImportDataNode = Node & {
  __typename?: 'KoboImportDataNode';
  businessAreaSlug: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdById?: Maybe<Scalars['UUID']['output']>;
  dataType: ImportDataDataType;
  error: Scalars['String']['output'];
  file?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  importdataPtr: ImportDataNode;
  koboAssetId: Scalars['String']['output'];
  koboValidationErrors?: Maybe<Array<Maybe<KoboErrorNode>>>;
  numberOfHouseholds?: Maybe<Scalars['Int']['output']>;
  numberOfIndividuals?: Maybe<Scalars['Int']['output']>;
  onlyActiveSubmissions: Scalars['Boolean']['output'];
  status: ImportDataStatus;
  updatedAt: Scalars['DateTime']['output'];
  validationErrors: Scalars['String']['output'];
};

export type LabelNode = {
  __typename?: 'LabelNode';
  label?: Maybe<Scalars['String']['output']>;
  language?: Maybe<Scalars['String']['output']>;
};

export type LanguageObject = {
  __typename?: 'LanguageObject';
  code?: Maybe<Scalars['String']['output']>;
  english?: Maybe<Scalars['String']['output']>;
};

export type LanguageObjectConnection = {
  __typename?: 'LanguageObjectConnection';
  edges: Array<Maybe<LanguageObjectEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type LanguageObjectEdge = {
  __typename?: 'LanguageObjectEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<LanguageObject>;
};

export type LockTargetPopulationMutation = {
  __typename?: 'LockTargetPopulationMutation';
  targetPopulation?: Maybe<TargetPopulationNode>;
};

export enum LogEntryAction {
  Create = 'CREATE',
  Delete = 'DELETE',
  SoftDelete = 'SOFT_DELETE',
  Update = 'UPDATE'
}

export type LogEntryNode = Node & {
  __typename?: 'LogEntryNode';
  action: LogEntryAction;
  businessArea?: Maybe<UserBusinessAreaNode>;
  changes?: Maybe<Scalars['Arg']['output']>;
  contentType?: Maybe<ContentTypeObjectType>;
  id: Scalars['ID']['output'];
  isUserGenerated?: Maybe<Scalars['Boolean']['output']>;
  objectId?: Maybe<Scalars['UUID']['output']>;
  objectRepr: Scalars['String']['output'];
  programs: ProgramNodeConnection;
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<UserNode>;
};


export type LogEntryNodeProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type LogEntryNodeConnection = {
  __typename?: 'LogEntryNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<LogEntryNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type LogEntryNodeEdge = {
  __typename?: 'LogEntryNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<LogEntryNode>;
};

export type MarkPaymentAsFailedMutation = {
  __typename?: 'MarkPaymentAsFailedMutation';
  payment?: Maybe<PaymentNode>;
};

export type MarkPaymentRecordAsFailedMutation = {
  __typename?: 'MarkPaymentRecordAsFailedMutation';
  paymentRecord?: Maybe<PaymentRecordNode>;
};

export type MergeRegistrationDataImportMutation = {
  __typename?: 'MergeRegistrationDataImportMutation';
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
};

export enum MessageSamplingType {
  FullList = 'FULL_LIST',
  Random = 'RANDOM'
}

export type Mutations = {
  __typename?: 'Mutations';
  actionPaymentPlanMutation?: Maybe<ActionPaymentPlanMutation>;
  activatePaymentVerificationPlan?: Maybe<ActivatePaymentVerificationPlan>;
  approveAddIndividual?: Maybe<SimpleApproveMutation>;
  approveDeleteHousehold?: Maybe<DeleteHouseholdApproveMutation>;
  approveDeleteIndividual?: Maybe<SimpleApproveMutation>;
  approveHouseholdDataChange?: Maybe<HouseholdDataChangeApproveMutation>;
  approveIndividualDataChange?: Maybe<IndividualDataChangeApproveMutation>;
  approveNeedsAdjudication?: Maybe<NeedsAdjudicationApproveMutation>;
  approvePaymentDetails?: Maybe<PaymentDetailsApproveMutation>;
  approveSystemFlagging?: Maybe<SimpleApproveMutation>;
  assignFspToDeliveryMechanism?: Maybe<AssignFspToDeliveryMechanismMutation>;
  bulkGrievanceAddNote?: Maybe<BulkGrievanceAddNoteMutation>;
  bulkUpdateGrievanceAssignee?: Maybe<BulkUpdateGrievanceTicketsAssigneesMutation>;
  bulkUpdateGrievancePriority?: Maybe<BulkUpdateGrievanceTicketsPriorityMutation>;
  bulkUpdateGrievanceUrgency?: Maybe<BulkUpdateGrievanceTicketsUrgencyMutation>;
  checkAgainstSanctionList?: Maybe<CheckAgainstSanctionListMutation>;
  chooseDeliveryMechanismsForPaymentPlan?: Maybe<ChooseDeliveryMechanismsForPaymentPlanMutation>;
  copyProgram?: Maybe<CopyProgram>;
  copyTargetPopulation?: Maybe<CopyTargetPopulationMutationPayload>;
  createAccountabilityCommunicationMessage?: Maybe<CreateCommunicationMessageMutation>;
  createDashboardReport?: Maybe<CreateDashboardReport>;
  createFeedback?: Maybe<CreateFeedbackMutation>;
  createFeedbackMessage?: Maybe<CreateFeedbackMessageMutation>;
  createFollowUpPaymentPlan?: Maybe<CreateFollowUpPaymentPlanMutation>;
  createGrievanceTicket?: Maybe<CreateGrievanceTicketMutation>;
  createPaymentPlan?: Maybe<CreatePaymentPlanMutation>;
  createPaymentVerificationPlan?: Maybe<CreateVerificationPlanMutation>;
  createProgram?: Maybe<CreateProgram>;
  createReport?: Maybe<CreateReport>;
  createSurvey?: Maybe<CreateSurveyMutation>;
  createTargetPopulation?: Maybe<CreateTargetPopulationMutation>;
  createTicketNote?: Maybe<CreateTicketNoteMutation>;
  deletePaymentPlan?: Maybe<DeletePaymentPlanMutation>;
  deletePaymentVerificationPlan?: Maybe<DeletePaymentVerificationPlan>;
  deleteProgram?: Maybe<DeleteProgram>;
  deleteRegistrationDataImport?: Maybe<DeleteRegistrationDataImport>;
  deleteTargetPopulation?: Maybe<DeleteTargetPopulationMutationPayload>;
  discardPaymentVerificationPlan?: Maybe<DiscardPaymentVerificationPlan>;
  editPaymentVerificationPlan?: Maybe<EditPaymentVerificationMutation>;
  eraseRegistrationDataImport?: Maybe<EraseRegistrationDataImportMutation>;
  excludeHouseholds?: Maybe<ExcludeHouseholdsMutation>;
  exportPdfPaymentPlanSummary?: Maybe<ExportPdfPaymentPlanSummaryMutation>;
  exportSurveySample?: Maybe<ExportSurveySampleMutationMutation>;
  exportXlsxPaymentPlanPaymentList?: Maybe<ExportXlsxPaymentPlanPaymentListMutation>;
  exportXlsxPaymentPlanPaymentListPerFsp?: Maybe<ExportXlsxPaymentPlanPaymentListPerFspMutation>;
  exportXlsxPaymentVerificationPlanFile?: Maybe<ExportXlsxPaymentVerificationPlanFile>;
  finalizeTargetPopulation?: Maybe<FinalizeTargetPopulationMutation>;
  finishPaymentVerificationPlan?: Maybe<FinishPaymentVerificationPlan>;
  grievanceStatusChange?: Maybe<GrievanceStatusChangeMutation>;
  importXlsxPaymentPlanPaymentList?: Maybe<ImportXlsxPaymentPlanPaymentListMutation>;
  importXlsxPaymentPlanPaymentListPerFsp?: Maybe<ImportXlsxPaymentPlanPaymentListPerFspMutation>;
  importXlsxPaymentVerificationPlanFile?: Maybe<ImportXlsxPaymentVerificationPlanFile>;
  invalidPaymentVerificationPlan?: Maybe<InvalidPaymentVerificationPlan>;
  lockTargetPopulation?: Maybe<LockTargetPopulationMutation>;
  markPaymentAsFailed?: Maybe<MarkPaymentAsFailedMutation>;
  markPaymentRecordAsFailed?: Maybe<MarkPaymentRecordAsFailedMutation>;
  mergeRegistrationDataImport?: Maybe<MergeRegistrationDataImportMutation>;
  reassignRole?: Maybe<ReassignRoleMutation>;
  refuseRegistrationDataImport?: Maybe<RefuseRegistrationDataImportMutation>;
  registrationKoboImport?: Maybe<RegistrationKoboImportMutation>;
  registrationXlsxImport?: Maybe<RegistrationXlsxImportMutation>;
  rerunDedupe?: Maybe<RegistrationDeduplicationMutation>;
  restartCreateReport?: Maybe<RestartCreateReport>;
  revertMarkPaymentAsFailed?: Maybe<RevertMarkPaymentAsFailedMutation>;
  revertMarkPaymentRecordAsFailed?: Maybe<RevertMarkPaymentRecordAsFailedMutation>;
  saveKoboImportDataAsync?: Maybe<SaveKoboProjectImportDataAsync>;
  setSteficonRuleOnPaymentPlanPaymentList?: Maybe<SetSteficonRuleOnPaymentPlanPaymentListMutation>;
  setSteficonRuleOnTargetPopulation?: Maybe<SetSteficonRuleOnTargetPopulationMutationPayload>;
  splitPaymentPlan?: Maybe<SplitPaymentPlanMutation>;
  targetPopulationRebuild?: Maybe<RebuildTargetPopulationMutation>;
  unlockTargetPopulation?: Maybe<UnlockTargetPopulationMutation>;
  updateFeedback?: Maybe<UpdateFeedbackMutation>;
  updateGrievanceTicket?: Maybe<UpdateGrievanceTicketMutation>;
  updatePaymentPlan?: Maybe<UpdatePaymentPlanMutation>;
  updatePaymentVerificationReceivedAndReceivedAmount?: Maybe<UpdatePaymentVerificationReceivedAndReceivedAmount>;
  updatePaymentVerificationStatusAndReceivedAmount?: Maybe<UpdatePaymentVerificationStatusAndReceivedAmount>;
  updateProgram?: Maybe<UpdateProgram>;
  updateTargetPopulation?: Maybe<UpdateTargetPopulationMutation>;
  uploadImportDataXlsxFileAsync?: Maybe<UploadImportDataXlsxFileAsync>;
};


export type MutationsActionPaymentPlanMutationArgs = {
  input: ActionPaymentPlanInput;
};


export type MutationsActivatePaymentVerificationPlanArgs = {
  paymentVerificationPlanId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveAddIndividualArgs = {
  approveStatus: Scalars['Boolean']['input'];
  grievanceTicketId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveDeleteHouseholdArgs = {
  approveStatus: Scalars['Boolean']['input'];
  grievanceTicketId: Scalars['ID']['input'];
  reasonHhId?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveDeleteIndividualArgs = {
  approveStatus: Scalars['Boolean']['input'];
  grievanceTicketId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveHouseholdDataChangeArgs = {
  flexFieldsApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  grievanceTicketId: Scalars['ID']['input'];
  householdApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveIndividualDataChangeArgs = {
  approvedDocumentsToCreate?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedDocumentsToEdit?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedDocumentsToRemove?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedIdentitiesToCreate?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedIdentitiesToEdit?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedIdentitiesToRemove?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedPaymentChannelsToCreate?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedPaymentChannelsToEdit?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  approvedPaymentChannelsToRemove?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  flexFieldsApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  grievanceTicketId: Scalars['ID']['input'];
  individualApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveNeedsAdjudicationArgs = {
  grievanceTicketId: Scalars['ID']['input'];
  selectedIndividualId?: InputMaybe<Scalars['ID']['input']>;
  selectedIndividualIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApprovePaymentDetailsArgs = {
  approveStatus: Scalars['Boolean']['input'];
  grievanceTicketId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsApproveSystemFlaggingArgs = {
  approveStatus: Scalars['Boolean']['input'];
  grievanceTicketId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsAssignFspToDeliveryMechanismArgs = {
  input: AssignFspToDeliveryMechanismInput;
};


export type MutationsBulkGrievanceAddNoteArgs = {
  businessAreaSlug: Scalars['String']['input'];
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>>;
  note: Scalars['String']['input'];
};


export type MutationsBulkUpdateGrievanceAssigneeArgs = {
  assignedTo: Scalars['String']['input'];
  businessAreaSlug: Scalars['String']['input'];
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type MutationsBulkUpdateGrievancePriorityArgs = {
  businessAreaSlug: Scalars['String']['input'];
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>>;
  priority: Scalars['Int']['input'];
};


export type MutationsBulkUpdateGrievanceUrgencyArgs = {
  businessAreaSlug: Scalars['String']['input'];
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>>;
  urgency: Scalars['Int']['input'];
};


export type MutationsCheckAgainstSanctionListArgs = {
  file: Scalars['Upload']['input'];
};


export type MutationsChooseDeliveryMechanismsForPaymentPlanArgs = {
  input: ChooseDeliveryMechanismsForPaymentPlanInput;
};


export type MutationsCopyProgramArgs = {
  programData: CopyProgramInput;
};


export type MutationsCopyTargetPopulationArgs = {
  input: CopyTargetPopulationMutationInput;
};


export type MutationsCreateAccountabilityCommunicationMessageArgs = {
  input: CreateAccountabilityCommunicationMessageInput;
};


export type MutationsCreateDashboardReportArgs = {
  reportData: CreateDashboardReportInput;
};


export type MutationsCreateFeedbackArgs = {
  input: CreateFeedbackInput;
};


export type MutationsCreateFeedbackMessageArgs = {
  input: CreateFeedbackMessageInput;
};


export type MutationsCreateFollowUpPaymentPlanArgs = {
  dispersionEndDate: Scalars['Date']['input'];
  dispersionStartDate: Scalars['Date']['input'];
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsCreateGrievanceTicketArgs = {
  input: CreateGrievanceTicketInput;
};


export type MutationsCreatePaymentPlanArgs = {
  input: CreatePaymentPlanInput;
};


export type MutationsCreatePaymentVerificationPlanArgs = {
  input: CreatePaymentVerificationInput;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsCreateProgramArgs = {
  programData: CreateProgramInput;
};


export type MutationsCreateReportArgs = {
  reportData: CreateReportInput;
};


export type MutationsCreateSurveyArgs = {
  input: CreateSurveyInput;
};


export type MutationsCreateTargetPopulationArgs = {
  input: CreateTargetPopulationInput;
};


export type MutationsCreateTicketNoteArgs = {
  noteInput: CreateTicketNoteInput;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsDeletePaymentPlanArgs = {
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsDeletePaymentVerificationPlanArgs = {
  paymentVerificationPlanId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsDeleteProgramArgs = {
  programId: Scalars['String']['input'];
};


export type MutationsDeleteRegistrationDataImportArgs = {
  registrationDataImportId: Scalars['String']['input'];
};


export type MutationsDeleteTargetPopulationArgs = {
  input: DeleteTargetPopulationMutationInput;
};


export type MutationsDiscardPaymentVerificationPlanArgs = {
  paymentVerificationPlanId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsEditPaymentVerificationPlanArgs = {
  input: EditPaymentVerificationInput;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsEraseRegistrationDataImportArgs = {
  id: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsExcludeHouseholdsArgs = {
  excludedHouseholdsIds: Array<InputMaybe<Scalars['String']['input']>>;
  exclusionReason?: InputMaybe<Scalars['String']['input']>;
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsExportPdfPaymentPlanSummaryArgs = {
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsExportSurveySampleArgs = {
  surveyId: Scalars['ID']['input'];
};


export type MutationsExportXlsxPaymentPlanPaymentListArgs = {
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsExportXlsxPaymentPlanPaymentListPerFspArgs = {
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsExportXlsxPaymentVerificationPlanFileArgs = {
  paymentVerificationPlanId: Scalars['ID']['input'];
};


export type MutationsFinalizeTargetPopulationArgs = {
  id: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsFinishPaymentVerificationPlanArgs = {
  paymentVerificationPlanId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsGrievanceStatusChangeArgs = {
  grievanceTicketId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsImportXlsxPaymentPlanPaymentListArgs = {
  file: Scalars['Upload']['input'];
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsImportXlsxPaymentPlanPaymentListPerFspArgs = {
  file: Scalars['Upload']['input'];
  paymentPlanId: Scalars['ID']['input'];
};


export type MutationsImportXlsxPaymentVerificationPlanFileArgs = {
  file: Scalars['Upload']['input'];
  paymentVerificationPlanId: Scalars['ID']['input'];
};


export type MutationsInvalidPaymentVerificationPlanArgs = {
  paymentVerificationPlanId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsLockTargetPopulationArgs = {
  id: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsMarkPaymentAsFailedArgs = {
  paymentId: Scalars['ID']['input'];
};


export type MutationsMarkPaymentRecordAsFailedArgs = {
  paymentRecordId: Scalars['ID']['input'];
};


export type MutationsMergeRegistrationDataImportArgs = {
  id: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsReassignRoleArgs = {
  grievanceTicketId: Scalars['ID']['input'];
  householdId: Scalars['ID']['input'];
  householdVersion?: InputMaybe<Scalars['BigInt']['input']>;
  individualId: Scalars['ID']['input'];
  individualVersion?: InputMaybe<Scalars['BigInt']['input']>;
  newIndividualId?: InputMaybe<Scalars['ID']['input']>;
  role: Scalars['String']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsRefuseRegistrationDataImportArgs = {
  id: Scalars['ID']['input'];
  refuseReason?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsRegistrationKoboImportArgs = {
  registrationDataImportData: RegistrationKoboImportMutationInput;
};


export type MutationsRegistrationXlsxImportArgs = {
  registrationDataImportData: RegistrationXlsxImportMutationInput;
};


export type MutationsRerunDedupeArgs = {
  registrationDataImportDatahubId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsRestartCreateReportArgs = {
  reportData: RestartCreateReportInput;
};


export type MutationsRevertMarkPaymentAsFailedArgs = {
  deliveredQuantity: Scalars['Decimal']['input'];
  deliveryDate: Scalars['Date']['input'];
  paymentId: Scalars['ID']['input'];
};


export type MutationsRevertMarkPaymentRecordAsFailedArgs = {
  deliveredQuantity: Scalars['Decimal']['input'];
  deliveryDate: Scalars['Date']['input'];
  paymentRecordId: Scalars['ID']['input'];
};


export type MutationsSaveKoboImportDataAsyncArgs = {
  businessAreaSlug: Scalars['String']['input'];
  onlyActiveSubmissions: Scalars['Boolean']['input'];
  uid: Scalars['Upload']['input'];
};


export type MutationsSetSteficonRuleOnPaymentPlanPaymentListArgs = {
  paymentPlanId: Scalars['ID']['input'];
  steficonRuleId: Scalars['ID']['input'];
};


export type MutationsSetSteficonRuleOnTargetPopulationArgs = {
  input: SetSteficonRuleOnTargetPopulationMutationInput;
};


export type MutationsSplitPaymentPlanArgs = {
  paymentPlanId: Scalars['ID']['input'];
  paymentsNo?: InputMaybe<Scalars['Int']['input']>;
  splitType: Scalars['String']['input'];
};


export type MutationsTargetPopulationRebuildArgs = {
  id: Scalars['ID']['input'];
};


export type MutationsUnlockTargetPopulationArgs = {
  id: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsUpdateFeedbackArgs = {
  input: UpdateFeedbackInput;
};


export type MutationsUpdateGrievanceTicketArgs = {
  input: UpdateGrievanceTicketInput;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsUpdatePaymentPlanArgs = {
  input: UpdatePaymentPlanInput;
};


export type MutationsUpdatePaymentVerificationReceivedAndReceivedAmountArgs = {
  paymentVerificationId: Scalars['ID']['input'];
  received: Scalars['Boolean']['input'];
  receivedAmount: Scalars['Decimal']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsUpdatePaymentVerificationStatusAndReceivedAmountArgs = {
  paymentVerificationId: Scalars['ID']['input'];
  receivedAmount: Scalars['Decimal']['input'];
  status?: InputMaybe<PaymentVerificationStatusForUpdate>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsUpdateProgramArgs = {
  programData?: InputMaybe<UpdateProgramInput>;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsUpdateTargetPopulationArgs = {
  input: UpdateTargetPopulationInput;
  version?: InputMaybe<Scalars['BigInt']['input']>;
};


export type MutationsUploadImportDataXlsxFileAsyncArgs = {
  businessAreaSlug: Scalars['String']['input'];
  file: Scalars['Upload']['input'];
};

export type NeedsAdjudicationApproveMutation = {
  __typename?: 'NeedsAdjudicationApproveMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type NegativeFeedbackTicketExtras = {
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
};

export type Node = {
  id: Scalars['ID']['output'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PageInfoNode = {
  __typename?: 'PageInfoNode';
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
  hasPreviousPage?: Maybe<Scalars['Boolean']['output']>;
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PaginatedCashPlanAndPaymentPlanNode = {
  __typename?: 'PaginatedCashPlanAndPaymentPlanNode';
  edges?: Maybe<Array<Maybe<CashPlanAndPaymentPlanEdges>>>;
  pageInfo?: Maybe<PageInfoNode>;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaginatedPaymentRecordsAndPaymentsNode = {
  __typename?: 'PaginatedPaymentRecordsAndPaymentsNode';
  edges?: Maybe<Array<Maybe<PaymentRecordsAndPaymentsEdges>>>;
  pageInfo?: Maybe<PageInfoNode>;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PartnerNodeForProgram = {
  __typename?: 'PartnerNodeForProgram';
  adminAreas?: Maybe<Array<Maybe<AreaGroupNode>>>;
  allowedBusinessAreas: UserBusinessAreaNodeConnection;
  areaAccess?: Maybe<Scalars['String']['output']>;
  grievanceticketSet: GrievanceTicketNodeConnection;
  id?: Maybe<Scalars['ID']['output']>;
  individualIdentities: IndividualIdentityNodeConnection;
  isUn: Scalars['Boolean']['output'];
  level: Scalars['Int']['output'];
  lft: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  parent?: Maybe<PartnerNodeForProgram>;
  partnerSet: Array<PartnerNodeForProgram>;
  permissions: Scalars['JSONString']['output'];
  rght: Scalars['Int']['output'];
  treeId: Scalars['Int']['output'];
  userSet: UserNodeConnection;
};


export type PartnerNodeForProgramAllowedBusinessAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PartnerNodeForProgramGrievanceticketSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PartnerNodeForProgramIndividualIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PartnerNodeForProgramUserSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PartnerProgramInput = {
  adminAreas?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  areaAccess?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

export type PartnerType = {
  __typename?: 'PartnerType';
  allowedBusinessAreas: UserBusinessAreaNodeConnection;
  grievanceticketSet: GrievanceTicketNodeConnection;
  id: Scalars['ID']['output'];
  individualIdentities: IndividualIdentityNodeConnection;
  isUn: Scalars['Boolean']['output'];
  level: Scalars['Int']['output'];
  lft: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  parent?: Maybe<PartnerNodeForProgram>;
  partnerSet: Array<PartnerNodeForProgram>;
  permissions: Scalars['JSONString']['output'];
  rght: Scalars['Int']['output'];
  treeId: Scalars['Int']['output'];
  userSet: UserNodeConnection;
};


export type PartnerTypeAllowedBusinessAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PartnerTypeGrievanceticketSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PartnerTypeIndividualIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PartnerTypeUserSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentConflictDataNode = {
  __typename?: 'PaymentConflictDataNode';
  paymentId?: Maybe<Scalars['String']['output']>;
  paymentPlanEndDate?: Maybe<Scalars['String']['output']>;
  paymentPlanId?: Maybe<Scalars['String']['output']>;
  paymentPlanStartDate?: Maybe<Scalars['String']['output']>;
  paymentPlanStatus?: Maybe<Scalars['String']['output']>;
  paymentPlanUnicefId?: Maybe<Scalars['String']['output']>;
  paymentUnicefId?: Maybe<Scalars['String']['output']>;
};

export enum PaymentDeliveryType {
  CardlessCashWithdrawal = 'CARDLESS_CASH_WITHDRAWAL',
  Cash = 'CASH',
  CashByFsp = 'CASH_BY_FSP',
  CashOverTheCounter = 'CASH_OVER_THE_COUNTER',
  Cheque = 'CHEQUE',
  DepositToCard = 'DEPOSIT_TO_CARD',
  MobileMoney = 'MOBILE_MONEY',
  PrePaidCard = 'PRE_PAID_CARD',
  Referral = 'REFERRAL',
  Transfer = 'TRANSFER',
  TransferToAccount = 'TRANSFER_TO_ACCOUNT',
  Voucher = 'VOUCHER'
}

export type PaymentDetailsApproveMutation = {
  __typename?: 'PaymentDetailsApproveMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type PaymentHouseholdSnapshotNode = Node & {
  __typename?: 'PaymentHouseholdSnapshotNode';
  createdAt: Scalars['DateTime']['output'];
  householdId: Scalars['UUID']['output'];
  id: Scalars['ID']['output'];
  payment: PaymentNode;
  snapshotData: Scalars['JSONString']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PaymentNode = Node & {
  __typename?: 'PaymentNode';
  additionalCollectorName?: Maybe<Scalars['String']['output']>;
  additionalDocumentNumber?: Maybe<Scalars['String']['output']>;
  additionalDocumentType?: Maybe<Scalars['String']['output']>;
  adminUrl?: Maybe<Scalars['String']['output']>;
  businessArea: UserBusinessAreaNode;
  collector: IndividualNode;
  conflicted: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  currency: Scalars['String']['output'];
  debitCardIssuer?: Maybe<Scalars['String']['output']>;
  debitCardNumber?: Maybe<Scalars['String']['output']>;
  deliveredQuantity?: Maybe<Scalars['Float']['output']>;
  deliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  deliveryDate?: Maybe<Scalars['DateTime']['output']>;
  deliveryType?: Maybe<PaymentDeliveryType>;
  distributionModality?: Maybe<Scalars['String']['output']>;
  entitlementDate?: Maybe<Scalars['DateTime']['output']>;
  entitlementQuantity?: Maybe<Scalars['Float']['output']>;
  entitlementQuantityUsd?: Maybe<Scalars['Float']['output']>;
  excluded: Scalars['Boolean']['output'];
  financialServiceProvider?: Maybe<FinancialServiceProviderNode>;
  followUps: PaymentNodeConnection;
  fullName?: Maybe<Scalars['String']['output']>;
  headOfHousehold?: Maybe<IndividualNode>;
  household: HouseholdNode;
  householdSnapshot?: Maybe<PaymentHouseholdSnapshotNode>;
  id: Scalars['ID']['output'];
  isFollowUp: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  orderNumber?: Maybe<Scalars['Int']['output']>;
  parent: PaymentPlanNode;
  paymentPlanHardConflicted?: Maybe<Scalars['Boolean']['output']>;
  paymentPlanHardConflictedData?: Maybe<Array<Maybe<PaymentConflictDataNode>>>;
  paymentPlanSoftConflicted?: Maybe<Scalars['Boolean']['output']>;
  paymentPlanSoftConflictedData?: Maybe<Array<Maybe<PaymentConflictDataNode>>>;
  program?: Maybe<ProgramNode>;
  reasonForUnsuccessfulPayment?: Maybe<Scalars['String']['output']>;
  serviceProvider?: Maybe<FinancialServiceProviderNode>;
  signatureHash: Scalars['String']['output'];
  snapshotCollectorBankAccountNumber?: Maybe<Scalars['String']['output']>;
  snapshotCollectorBankName?: Maybe<Scalars['String']['output']>;
  snapshotCollectorDebitCardNumber?: Maybe<Scalars['String']['output']>;
  snapshotCollectorDeliveryPhoneNo?: Maybe<Scalars['String']['output']>;
  snapshotCollectorFullName?: Maybe<Scalars['String']['output']>;
  sourcePayment?: Maybe<PaymentNode>;
  status: PaymentStatus;
  statusDate: Scalars['DateTime']['output'];
  targetPopulation?: Maybe<TargetPopulationNode>;
  tokenNumber?: Maybe<Scalars['Int']['output']>;
  totalPersonsCovered?: Maybe<Scalars['Int']['output']>;
  transactionReferenceId?: Maybe<Scalars['String']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  verification?: Maybe<PaymentVerificationNode>;
};


export type PaymentNodeFollowUpsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentNodeConnection = {
  __typename?: 'PaymentNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentNodeEdge = {
  __typename?: 'PaymentNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentNode>;
};

export enum PaymentPlanBackgroundActionStatus {
  ExcludeBeneficiaries = 'EXCLUDE_BENEFICIARIES',
  ExcludeBeneficiariesError = 'EXCLUDE_BENEFICIARIES_ERROR',
  RuleEngineError = 'RULE_ENGINE_ERROR',
  RuleEngineRun = 'RULE_ENGINE_RUN',
  SendToPaymentGateway = 'SEND_TO_PAYMENT_GATEWAY',
  SendToPaymentGatewayError = 'SEND_TO_PAYMENT_GATEWAY_ERROR',
  XlsxExporting = 'XLSX_EXPORTING',
  XlsxExportError = 'XLSX_EXPORT_ERROR',
  XlsxImportingEntitlements = 'XLSX_IMPORTING_ENTITLEMENTS',
  XlsxImportingReconciliation = 'XLSX_IMPORTING_RECONCILIATION',
  XlsxImportError = 'XLSX_IMPORT_ERROR'
}

export enum PaymentPlanCurrency {
  Aed = 'AED',
  Afn = 'AFN',
  All = 'ALL',
  Amd = 'AMD',
  Ang = 'ANG',
  Aoa = 'AOA',
  Ars = 'ARS',
  Aud = 'AUD',
  Awg = 'AWG',
  Azn = 'AZN',
  A = 'A_',
  Bam = 'BAM',
  Bbd = 'BBD',
  Bdt = 'BDT',
  Bgn = 'BGN',
  Bhd = 'BHD',
  Bif = 'BIF',
  Bmd = 'BMD',
  Bnd = 'BND',
  Bob = 'BOB',
  Bov = 'BOV',
  Brl = 'BRL',
  Bsd = 'BSD',
  Btn = 'BTN',
  Bwp = 'BWP',
  Byn = 'BYN',
  Bzd = 'BZD',
  Cad = 'CAD',
  Cdf = 'CDF',
  Chf = 'CHF',
  Clp = 'CLP',
  Cny = 'CNY',
  Cop = 'COP',
  Crc = 'CRC',
  Cuc = 'CUC',
  Cup = 'CUP',
  Cve = 'CVE',
  Czk = 'CZK',
  Djf = 'DJF',
  Dkk = 'DKK',
  Dop = 'DOP',
  Dzd = 'DZD',
  Egp = 'EGP',
  Ern = 'ERN',
  Etb = 'ETB',
  Eur = 'EUR',
  Fjd = 'FJD',
  Fkp = 'FKP',
  Gbp = 'GBP',
  Gel = 'GEL',
  Ghs = 'GHS',
  Gip = 'GIP',
  Gmd = 'GMD',
  Gnf = 'GNF',
  Gtq = 'GTQ',
  Gyd = 'GYD',
  Hkd = 'HKD',
  Hnl = 'HNL',
  Hrk = 'HRK',
  Htg = 'HTG',
  Huf = 'HUF',
  Idr = 'IDR',
  Ils = 'ILS',
  Inr = 'INR',
  Iqd = 'IQD',
  Irr = 'IRR',
  Isk = 'ISK',
  Jmd = 'JMD',
  Jod = 'JOD',
  Jpy = 'JPY',
  Kes = 'KES',
  Kgs = 'KGS',
  Khr = 'KHR',
  Kmf = 'KMF',
  Kpw = 'KPW',
  Krw = 'KRW',
  Kwd = 'KWD',
  Kyd = 'KYD',
  Kzt = 'KZT',
  Lak = 'LAK',
  Lbp = 'LBP',
  Lkr = 'LKR',
  Lrd = 'LRD',
  Lsl = 'LSL',
  Lyd = 'LYD',
  Mad = 'MAD',
  Mdl = 'MDL',
  Mga = 'MGA',
  Mkd = 'MKD',
  Mmk = 'MMK',
  Mnt = 'MNT',
  Mop = 'MOP',
  Mru = 'MRU',
  Mur = 'MUR',
  Mvr = 'MVR',
  Mwk = 'MWK',
  Mxn = 'MXN',
  Myr = 'MYR',
  Mzn = 'MZN',
  Nad = 'NAD',
  Ngn = 'NGN',
  Nio = 'NIO',
  Nok = 'NOK',
  Npr = 'NPR',
  Nzd = 'NZD',
  Omr = 'OMR',
  Pab = 'PAB',
  Pen = 'PEN',
  Pgk = 'PGK',
  Php = 'PHP',
  Pkr = 'PKR',
  Pln = 'PLN',
  Pyg = 'PYG',
  Qar = 'QAR',
  Ron = 'RON',
  Rsd = 'RSD',
  Rub = 'RUB',
  Rwf = 'RWF',
  Sar = 'SAR',
  Sbd = 'SBD',
  Scr = 'SCR',
  Sdg = 'SDG',
  Sek = 'SEK',
  Sgd = 'SGD',
  Shp = 'SHP',
  Sll = 'SLL',
  Sos = 'SOS',
  Srd = 'SRD',
  Ssp = 'SSP',
  Stn = 'STN',
  Svc = 'SVC',
  Syp = 'SYP',
  Szl = 'SZL',
  Thb = 'THB',
  Tjs = 'TJS',
  Tmt = 'TMT',
  Tnd = 'TND',
  Top = 'TOP',
  Try = 'TRY',
  Ttd = 'TTD',
  Twd = 'TWD',
  Tzs = 'TZS',
  Uah = 'UAH',
  Ugx = 'UGX',
  Usd = 'USD',
  Uyu = 'UYU',
  Uyw = 'UYW',
  Uzs = 'UZS',
  Ves = 'VES',
  Vnd = 'VND',
  Vuv = 'VUV',
  Wst = 'WST',
  Xaf = 'XAF',
  Xag = 'XAG',
  Xau = 'XAU',
  Xcd = 'XCD',
  Xof = 'XOF',
  Xpf = 'XPF',
  Yer = 'YER',
  Zar = 'ZAR',
  Zmw = 'ZMW',
  Zwl = 'ZWL'
}

export type PaymentPlanNode = Node & {
  __typename?: 'PaymentPlanNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  approvalProcess: ApprovalProcessNodeConnection;
  availablePaymentRecordsCount?: Maybe<Scalars['Int']['output']>;
  backgroundActionStatus?: Maybe<PaymentPlanBackgroundActionStatus>;
  bankReconciliationError?: Maybe<Scalars['Int']['output']>;
  bankReconciliationSuccess?: Maybe<Scalars['Int']['output']>;
  businessArea: UserBusinessAreaNode;
  canCreateFollowUp?: Maybe<Scalars['Boolean']['output']>;
  canCreatePaymentVerificationPlan?: Maybe<Scalars['Boolean']['output']>;
  canSendToPaymentGateway?: Maybe<Scalars['Boolean']['output']>;
  canSplit?: Maybe<Scalars['Boolean']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy: UserNode;
  currency: PaymentPlanCurrency;
  currencyName?: Maybe<Scalars['String']['output']>;
  deliveryMechanisms?: Maybe<Array<Maybe<DeliveryMechanismNode>>>;
  dispersionEndDate?: Maybe<Scalars['Date']['output']>;
  dispersionStartDate?: Maybe<Scalars['Date']['output']>;
  endDate?: Maybe<Scalars['Date']['output']>;
  exchangeRate?: Maybe<Scalars['Float']['output']>;
  excludeHouseholdError: Scalars['String']['output'];
  excludedHouseholds?: Maybe<Array<Maybe<HouseholdNode>>>;
  exclusionReason: Scalars['String']['output'];
  femaleAdultsCount: Scalars['Int']['output'];
  femaleChildrenCount: Scalars['Int']['output'];
  followUps: PaymentPlanNodeConnection;
  hasFspDeliveryMechanismXlsxTemplate?: Maybe<Scalars['Boolean']['output']>;
  hasPaymentListExportFile?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  importedFileDate?: Maybe<Scalars['DateTime']['output']>;
  importedFileName?: Maybe<Scalars['String']['output']>;
  isFollowUp: Scalars['Boolean']['output'];
  isRemoved: Scalars['Boolean']['output'];
  maleAdultsCount: Scalars['Int']['output'];
  maleChildrenCount: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  paymentItems: PaymentNodeConnection;
  paymentVerificationSummary?: Maybe<PaymentVerificationSummaryNode>;
  paymentsConflictsCount?: Maybe<Scalars['Int']['output']>;
  program: ProgramNode;
  reconciliationSummary?: Maybe<ReconciliationSummaryNode>;
  sourcePaymentPlan?: Maybe<PaymentPlanNode>;
  splitChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  startDate?: Maybe<Scalars['Date']['output']>;
  status: PaymentPlanStatus;
  statusDate: Scalars['DateTime']['output'];
  steficonAppliedDate?: Maybe<Scalars['DateTime']['output']>;
  steficonRule?: Maybe<RuleCommitNode>;
  targetPopulation: TargetPopulationNode;
  totalDeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  totalDeliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantity?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantityRevised?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantityRevisedUsd?: Maybe<Scalars['Float']['output']>;
  totalEntitledQuantityUsd?: Maybe<Scalars['Float']['output']>;
  totalHouseholdsCount: Scalars['Int']['output'];
  totalIndividualsCount: Scalars['Int']['output'];
  totalUndeliveredQuantity?: Maybe<Scalars['Float']['output']>;
  totalUndeliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  totalWithdrawnHouseholdsCount?: Maybe<Scalars['Int']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
  unsuccessfulPaymentsCount?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  verificationPlans?: Maybe<PaymentVerificationPlanNodeConnection>;
  version: Scalars['BigInt']['output'];
  volumeByDeliveryMechanism?: Maybe<Array<Maybe<VolumeByDeliveryMechanismNode>>>;
};


export type PaymentPlanNodeApprovalProcessArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PaymentPlanNodeFollowUpsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PaymentPlanNodePaymentItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PaymentPlanNodeVerificationPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
};

export type PaymentPlanNodeConnection = {
  __typename?: 'PaymentPlanNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentPlanNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentPlanNodeEdge = {
  __typename?: 'PaymentPlanNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentPlanNode>;
};

export enum PaymentPlanStatus {
  Accepted = 'ACCEPTED',
  Finished = 'FINISHED',
  InApproval = 'IN_APPROVAL',
  InAuthorization = 'IN_AUTHORIZATION',
  InReview = 'IN_REVIEW',
  Locked = 'LOCKED',
  LockedFsp = 'LOCKED_FSP',
  Open = 'OPEN',
  Preparing = 'PREPARING'
}

export type PaymentRecordAndPaymentNode = {
  __typename?: 'PaymentRecordAndPaymentNode';
  caId?: Maybe<Scalars['String']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  deliveredQuantity?: Maybe<Scalars['Float']['output']>;
  deliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  deliveryDate?: Maybe<Scalars['String']['output']>;
  entitlementQuantity?: Maybe<Scalars['Float']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  objType?: Maybe<Scalars['String']['output']>;
  parent?: Maybe<CashPlanAndPaymentPlanNode>;
  status?: Maybe<Scalars['String']['output']>;
  verification?: Maybe<PaymentVerificationNode>;
};

export enum PaymentRecordDeliveryType {
  CardlessCashWithdrawal = 'CARDLESS_CASH_WITHDRAWAL',
  Cash = 'CASH',
  CashByFsp = 'CASH_BY_FSP',
  CashOverTheCounter = 'CASH_OVER_THE_COUNTER',
  Cheque = 'CHEQUE',
  DepositToCard = 'DEPOSIT_TO_CARD',
  MobileMoney = 'MOBILE_MONEY',
  PrePaidCard = 'PRE_PAID_CARD',
  Referral = 'REFERRAL',
  Transfer = 'TRANSFER',
  TransferToAccount = 'TRANSFER_TO_ACCOUNT',
  Voucher = 'VOUCHER'
}

export enum PaymentRecordEntitlementCardStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

export type PaymentRecordNode = Node & {
  __typename?: 'PaymentRecordNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  businessArea: UserBusinessAreaNode;
  caHashId?: Maybe<Scalars['UUID']['output']>;
  caId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  currency: Scalars['String']['output'];
  deliveredQuantity?: Maybe<Scalars['Float']['output']>;
  deliveredQuantityUsd?: Maybe<Scalars['Float']['output']>;
  deliveryDate?: Maybe<Scalars['DateTime']['output']>;
  deliveryType?: Maybe<PaymentRecordDeliveryType>;
  distributionModality: Scalars['String']['output'];
  entitlementCardIssueDate?: Maybe<Scalars['Date']['output']>;
  entitlementCardNumber?: Maybe<Scalars['String']['output']>;
  entitlementCardStatus?: Maybe<PaymentRecordEntitlementCardStatus>;
  entitlementQuantity?: Maybe<Scalars['Float']['output']>;
  entitlementQuantityUsd?: Maybe<Scalars['Float']['output']>;
  fullName: Scalars['String']['output'];
  headOfHousehold?: Maybe<IndividualNode>;
  household: HouseholdNode;
  id: Scalars['ID']['output'];
  parent?: Maybe<CashPlanNode>;
  registrationCaId?: Maybe<Scalars['String']['output']>;
  serviceProvider: ServiceProviderNode;
  status: PaymentRecordStatus;
  statusDate: Scalars['DateTime']['output'];
  targetPopulation: TargetPopulationNode;
  targetPopulationCashAssistId: Scalars['String']['output'];
  totalPersonsCovered: Scalars['Int']['output'];
  transactionReferenceId?: Maybe<Scalars['String']['output']>;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  verification?: Maybe<PaymentVerificationNode>;
  version: Scalars['BigInt']['output'];
  visionId?: Maybe<Scalars['String']['output']>;
};

export type PaymentRecordNodeConnection = {
  __typename?: 'PaymentRecordNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentRecordNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentRecordNodeEdge = {
  __typename?: 'PaymentRecordNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentRecordNode>;
};

export enum PaymentRecordStatus {
  DistributionSuccessful = 'DISTRIBUTION_SUCCESSFUL',
  ForceFailed = 'FORCE_FAILED',
  NotDistributed = 'NOT_DISTRIBUTED',
  PartiallyDistributed = 'PARTIALLY_DISTRIBUTED',
  Pending = 'PENDING',
  TransactionErroneous = 'TRANSACTION_ERRONEOUS',
  TransactionSuccessful = 'TRANSACTION_SUCCESSFUL'
}

export type PaymentRecordsAndPaymentsEdges = {
  __typename?: 'PaymentRecordsAndPaymentsEdges';
  cursor?: Maybe<Scalars['String']['output']>;
  node?: Maybe<PaymentRecordAndPaymentNode>;
};

export enum PaymentStatus {
  DistributionSuccessful = 'DISTRIBUTION_SUCCESSFUL',
  ForceFailed = 'FORCE_FAILED',
  NotDistributed = 'NOT_DISTRIBUTED',
  PartiallyDistributed = 'PARTIALLY_DISTRIBUTED',
  Pending = 'PENDING',
  TransactionErroneous = 'TRANSACTION_ERRONEOUS',
  TransactionSuccessful = 'TRANSACTION_SUCCESSFUL'
}

export type PaymentVerificationLogEntryNode = Node & {
  __typename?: 'PaymentVerificationLogEntryNode';
  action: LogEntryAction;
  businessArea?: Maybe<UserBusinessAreaNode>;
  changes?: Maybe<Scalars['Arg']['output']>;
  contentObject?: Maybe<PaymentVerificationPlanNode>;
  contentType?: Maybe<ContentTypeObjectType>;
  id: Scalars['ID']['output'];
  isUserGenerated?: Maybe<Scalars['Boolean']['output']>;
  objectId?: Maybe<Scalars['UUID']['output']>;
  objectRepr: Scalars['String']['output'];
  programs: ProgramNodeConnection;
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  user?: Maybe<UserNode>;
};


export type PaymentVerificationLogEntryNodeProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentVerificationLogEntryNodeConnection = {
  __typename?: 'PaymentVerificationLogEntryNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentVerificationLogEntryNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentVerificationLogEntryNodeEdge = {
  __typename?: 'PaymentVerificationLogEntryNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentVerificationLogEntryNode>;
};

export type PaymentVerificationNode = Node & {
  __typename?: 'PaymentVerificationNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isManuallyEditable?: Maybe<Scalars['Boolean']['output']>;
  payment?: Maybe<GenericPaymentNode>;
  paymentContentType: ContentTypeObjectType;
  paymentObjectId: Scalars['UUID']['output'];
  paymentVerificationPlan: PaymentVerificationPlanNode;
  receivedAmount?: Maybe<Scalars['Float']['output']>;
  sentToRapidPro: Scalars['Boolean']['output'];
  status: PaymentVerificationStatus;
  statusDate?: Maybe<Scalars['DateTime']['output']>;
  ticketDetail: TicketPaymentVerificationDetailsNodeConnection;
  ticketDetails: TicketPaymentVerificationDetailsNodeConnection;
  updatedAt: Scalars['DateTime']['output'];
  version: Scalars['BigInt']['output'];
};


export type PaymentVerificationNodeTicketDetailArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type PaymentVerificationNodeTicketDetailsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentVerificationNodeConnection = {
  __typename?: 'PaymentVerificationNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentVerificationNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentVerificationNodeEdge = {
  __typename?: 'PaymentVerificationNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentVerificationNode>;
};

export type PaymentVerificationPlanNode = Node & {
  __typename?: 'PaymentVerificationPlanNode';
  activationDate?: Maybe<Scalars['DateTime']['output']>;
  adminUrl?: Maybe<Scalars['String']['output']>;
  ageFilter?: Maybe<AgeFilterObject>;
  completionDate?: Maybe<Scalars['DateTime']['output']>;
  confidenceInterval?: Maybe<Scalars['Float']['output']>;
  createdAt: Scalars['DateTime']['output'];
  error?: Maybe<Scalars['String']['output']>;
  excludedAdminAreasFilter?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  hasXlsxFile?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  marginOfError?: Maybe<Scalars['Float']['output']>;
  notReceivedCount?: Maybe<Scalars['Int']['output']>;
  paymentPlan?: Maybe<PaymentPlanNode>;
  paymentPlanContentType: ContentTypeObjectType;
  paymentPlanObjectId: Scalars['UUID']['output'];
  paymentRecordVerifications: PaymentVerificationNodeConnection;
  rapidProFlowId: Scalars['String']['output'];
  rapidProFlowStartUuids: Array<Scalars['String']['output']>;
  receivedCount?: Maybe<Scalars['Int']['output']>;
  receivedWithProblemsCount?: Maybe<Scalars['Int']['output']>;
  respondedCount?: Maybe<Scalars['Int']['output']>;
  sampleSize?: Maybe<Scalars['Int']['output']>;
  sampling: PaymentVerificationPlanSampling;
  sexFilter?: Maybe<Scalars['String']['output']>;
  status: PaymentVerificationPlanStatus;
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  verificationChannel: PaymentVerificationPlanVerificationChannel;
  version: Scalars['BigInt']['output'];
  xlsxFileExporting: Scalars['Boolean']['output'];
  xlsxFileImported: Scalars['Boolean']['output'];
  xlsxFileWasDownloaded?: Maybe<Scalars['Boolean']['output']>;
};


export type PaymentVerificationPlanNodePaymentRecordVerificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentVerificationPlanNodeConnection = {
  __typename?: 'PaymentVerificationPlanNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentVerificationPlanNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentVerificationPlanNodeEdge = {
  __typename?: 'PaymentVerificationPlanNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentVerificationPlanNode>;
};

export enum PaymentVerificationPlanSampling {
  FullList = 'FULL_LIST',
  Random = 'RANDOM'
}

export enum PaymentVerificationPlanStatus {
  Active = 'ACTIVE',
  Finished = 'FINISHED',
  Invalid = 'INVALID',
  Pending = 'PENDING',
  RapidProError = 'RAPID_PRO_ERROR'
}

export enum PaymentVerificationPlanVerificationChannel {
  Manual = 'MANUAL',
  Rapidpro = 'RAPIDPRO',
  Xlsx = 'XLSX'
}

export enum PaymentVerificationStatus {
  NotReceived = 'NOT_RECEIVED',
  Pending = 'PENDING',
  Received = 'RECEIVED',
  ReceivedWithIssues = 'RECEIVED_WITH_ISSUES'
}

export enum PaymentVerificationStatusForUpdate {
  NotReceived = 'NOT_RECEIVED',
  Pending = 'PENDING',
  Received = 'RECEIVED',
  ReceivedWithIssues = 'RECEIVED_WITH_ISSUES'
}

export type PaymentVerificationSummaryNode = Node & {
  __typename?: 'PaymentVerificationSummaryNode';
  activationDate?: Maybe<Scalars['DateTime']['output']>;
  completionDate?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  paymentPlanContentType: ContentTypeObjectType;
  paymentPlanObjectId: Scalars['UUID']['output'];
  status: PaymentVerificationSummaryStatus;
  updatedAt: Scalars['DateTime']['output'];
};

export type PaymentVerificationSummaryNodeConnection = {
  __typename?: 'PaymentVerificationSummaryNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<PaymentVerificationSummaryNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type PaymentVerificationSummaryNodeEdge = {
  __typename?: 'PaymentVerificationSummaryNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<PaymentVerificationSummaryNode>;
};

export enum PaymentVerificationSummaryStatus {
  Active = 'ACTIVE',
  Finished = 'FINISHED',
  Pending = 'PENDING'
}

export type PositiveFeedbackTicketExtras = {
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
};

export enum ProgramFrequencyOfPayments {
  OneOff = 'ONE_OFF',
  Regular = 'REGULAR'
}

export type ProgramNode = Node & {
  __typename?: 'ProgramNode';
  activityLogs: PaymentVerificationLogEntryNodeConnection;
  adminAreas: AreaNodeConnection;
  adminUrl?: Maybe<Scalars['String']['output']>;
  administrativeAreasOfImplementation: Scalars['String']['output'];
  budget?: Maybe<Scalars['Decimal']['output']>;
  businessArea: UserBusinessAreaNode;
  caHashId?: Maybe<Scalars['String']['output']>;
  caId?: Maybe<Scalars['String']['output']>;
  cashPlus: Scalars['Boolean']['output'];
  cashplanSet: CashPlanNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  dataCollectingType?: Maybe<DataCollectingTypeNode>;
  description: Scalars['String']['output'];
  endDate: Scalars['Date']['output'];
  feedbackSet: FeedbackNodeConnection;
  frequencyOfPayments: ProgramFrequencyOfPayments;
  grievanceTickets: GrievanceTicketNodeConnection;
  householdCount: Scalars['Int']['output'];
  householdSet: HouseholdNodeConnection;
  households: HouseholdNodeConnection;
  id: Scalars['ID']['output'];
  individualCount: Scalars['Int']['output'];
  individuals: IndividualNodeConnection;
  isRemoved: Scalars['Boolean']['output'];
  isSocialWorkerProgram?: Maybe<Scalars['Boolean']['output']>;
  isVisible: Scalars['Boolean']['output'];
  lastSyncAt?: Maybe<Scalars['DateTime']['output']>;
  messages: CommunicationMessageNodeConnection;
  name: Scalars['String']['output'];
  partners?: Maybe<Array<Maybe<PartnerNodeForProgram>>>;
  paymentSet: PaymentNodeConnection;
  paymentplanSet: PaymentPlanNodeConnection;
  populationGoal: Scalars['Int']['output'];
  programmeCode?: Maybe<Scalars['String']['output']>;
  registrationImports: RegistrationDataImportNodeConnection;
  reports: ReportNodeConnection;
  scope?: Maybe<ProgramScope>;
  sector: ProgramSector;
  startDate: Scalars['Date']['output'];
  status: ProgramStatus;
  surveys: SurveyNodeConnection;
  targetpopulationSet: TargetPopulationNodeConnection;
  totalDeliveredQuantity?: Maybe<Scalars['Decimal']['output']>;
  totalEntitledQuantity?: Maybe<Scalars['Decimal']['output']>;
  totalNumberOfHouseholds?: Maybe<Scalars['Int']['output']>;
  totalNumberOfHouseholdsWithTpInProgram?: Maybe<Scalars['Int']['output']>;
  totalUndeliveredQuantity?: Maybe<Scalars['Decimal']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  version: Scalars['BigInt']['output'];
};


export type ProgramNodeActivityLogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeAdminAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeCashplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeFeedbackSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeGrievanceTicketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeHouseholdSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodePaymentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodePaymentplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeRegistrationImportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeSurveysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ProgramNodeTargetpopulationSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProgramNodeConnection = {
  __typename?: 'ProgramNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ProgramNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ProgramNodeEdge = {
  __typename?: 'ProgramNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ProgramNode>;
};

export enum ProgramScope {
  ForPartners = 'FOR_PARTNERS',
  Unicef = 'UNICEF'
}

export enum ProgramSector {
  ChildProtection = 'CHILD_PROTECTION',
  Education = 'EDUCATION',
  Health = 'HEALTH',
  MultiPurpose = 'MULTI_PURPOSE',
  Nutrition = 'NUTRITION',
  SocialPolicy = 'SOCIAL_POLICY',
  Wash = 'WASH'
}

export enum ProgramStatus {
  Active = 'ACTIVE',
  Draft = 'DRAFT',
  Finished = 'FINISHED'
}

export type Query = {
  __typename?: 'Query';
  _debug?: Maybe<DjangoDebug>;
  accountabilityCommunicationMessage?: Maybe<CommunicationMessageNode>;
  accountabilityCommunicationMessageSampleSize?: Maybe<GetCommunicationMessageSampleSizeNode>;
  accountabilitySampleSize?: Maybe<AccountabilitySampleSizeNode>;
  adminArea?: Maybe<AreaNode>;
  allAccountabilityCommunicationMessageRecipients?: Maybe<CommunicationMessageRecipientMapNodeConnection>;
  allAccountabilityCommunicationMessages?: Maybe<CommunicationMessageNodeConnection>;
  allActivePrograms?: Maybe<ProgramNodeConnection>;
  allActiveTargetPopulations?: Maybe<TargetPopulationNodeConnection>;
  allAddIndividualsFieldsAttributes?: Maybe<Array<Maybe<FieldAttributeNode>>>;
  allAdminAreas?: Maybe<AreaNodeConnection>;
  allAreasTree?: Maybe<Array<Maybe<AreaTreeNode>>>;
  allBusinessAreas?: Maybe<BusinessAreaNodeConnection>;
  allCashPlans?: Maybe<CashPlanNodeConnection>;
  allCashPlansAndPaymentPlans?: Maybe<PaginatedCashPlanAndPaymentPlanNode>;
  allDeliveryMechanisms?: Maybe<Array<Maybe<ChoiceObject>>>;
  allEditHouseholdFieldsAttributes?: Maybe<Array<Maybe<FieldAttributeNode>>>;
  allFeedbacks?: Maybe<FeedbackNodeConnection>;
  allFieldsAttributes?: Maybe<Array<Maybe<FieldAttributeNode>>>;
  allFinancialServiceProviderXlsxReports?: Maybe<FinancialServiceProviderXlsxReportNodeConnection>;
  allFinancialServiceProviderXlsxTemplates?: Maybe<FinancialServiceProviderXlsxTemplateNodeConnection>;
  allFinancialServiceProviders?: Maybe<FinancialServiceProviderNodeConnection>;
  allGrievanceTicket?: Maybe<GrievanceTicketNodeConnection>;
  allGroupsWithFields?: Maybe<Array<Maybe<GroupAttributeNode>>>;
  allHouseholds?: Maybe<HouseholdNodeConnection>;
  allHouseholdsFlexFieldsAttributes?: Maybe<Array<Maybe<FieldAttributeNode>>>;
  allImportedHouseholds?: Maybe<ImportedHouseholdNodeConnection>;
  allImportedIndividuals?: Maybe<ImportedIndividualNodeConnection>;
  allIndividuals?: Maybe<IndividualNodeConnection>;
  allIndividualsFlexFieldsAttributes?: Maybe<Array<Maybe<FieldAttributeNode>>>;
  allKoboProjects?: Maybe<KoboAssetObjectConnection>;
  allLanguages?: Maybe<LanguageObjectConnection>;
  allLogEntries?: Maybe<LogEntryNodeConnection>;
  allMergedHouseholds?: Maybe<HouseholdNodeConnection>;
  allMergedIndividuals?: Maybe<IndividualNodeConnection>;
  allPaymentPlans?: Maybe<PaymentPlanNodeConnection>;
  allPaymentRecords?: Maybe<PaymentRecordNodeConnection>;
  allPaymentRecordsAndPayments?: Maybe<PaginatedPaymentRecordsAndPaymentsNode>;
  allPaymentVerificationLogEntries?: Maybe<PaymentVerificationLogEntryNodeConnection>;
  allPaymentVerificationPlan?: Maybe<PaymentVerificationPlanNodeConnection>;
  allPaymentVerifications?: Maybe<PaymentVerificationNodeConnection>;
  allPayments?: Maybe<PaymentNodeConnection>;
  allPrograms?: Maybe<ProgramNodeConnection>;
  allRapidProFlows?: Maybe<Array<Maybe<RapidProFlow>>>;
  allRegistrationDataImports?: Maybe<RegistrationDataImportNodeConnection>;
  allRegistrationDataImportsDatahub?: Maybe<RegistrationDataImportDatahubNodeConnection>;
  allReports?: Maybe<ReportNodeConnection>;
  allSanctionListIndividuals?: Maybe<SanctionListIndividualNodeConnection>;
  allSteficonRules?: Maybe<SteficonRuleNodeConnection>;
  allSurveys?: Maybe<SurveyNodeConnection>;
  allTargetPopulation?: Maybe<TargetPopulationNodeConnection>;
  allTicketNotes?: Maybe<TicketNoteNodeConnection>;
  allUsers?: Maybe<UserNodeConnection>;
  availableFspsForDeliveryMechanisms?: Maybe<Array<Maybe<FspChoices>>>;
  businessArea?: Maybe<BusinessAreaNode>;
  cashAssistUrlPrefix?: Maybe<Scalars['String']['output']>;
  cashPlan?: Maybe<CashPlanNode>;
  cashPlanStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  cashPlanVerificationSamplingChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  cashPlanVerificationStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  cashPlanVerificationVerificationChannelChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  chartGrievances?: Maybe<ChartGrievanceTicketsNode>;
  chartIndividualsReachedByAgeAndGender?: Maybe<ChartDatasetNode>;
  chartIndividualsWithDisabilityReachedByAge?: Maybe<ChartDetailedDatasetsNode>;
  chartPayment?: Maybe<ChartDatasetNode>;
  chartPaymentVerification?: Maybe<ChartPaymentVerification>;
  chartProgrammesBySector?: Maybe<ChartDetailedDatasetsNode>;
  chartTotalTransferredByMonth?: Maybe<ChartDetailedDatasetsNode>;
  chartTotalTransferredCashByCountry?: Maybe<ChartDetailedDatasetsNode>;
  chartVolumeByDeliveryMechanism?: Maybe<ChartDatasetNode>;
  countriesChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  crossAreaFilterAvailable?: Maybe<Scalars['Boolean']['output']>;
  currencyChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  dashboardReportTypesChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  dashboardYearsChoices?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  dataCollectingType?: Maybe<DataCollectingTypeNode>;
  dataCollectingTypeChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  dataCollectionTypeChoices?: Maybe<Array<Maybe<DataCollectingTypeChoiceObject>>>;
  deduplicationBatchStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  deduplicationGoldenRecordStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  documentTypeChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  existingGrievanceTickets?: Maybe<GrievanceTicketNodeConnection>;
  feedback?: Maybe<FeedbackNode>;
  feedbackIssueTypeChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  financialServiceProvider?: Maybe<FinancialServiceProviderNode>;
  financialServiceProviderXlsxReport?: Maybe<FinancialServiceProviderXlsxReportNode>;
  financialServiceProviderXlsxTemplate?: Maybe<FinancialServiceProviderXlsxTemplateNode>;
  flagChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  grievanceTicket?: Maybe<GrievanceTicketNode>;
  grievanceTicketCategoryChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  grievanceTicketIssueTypeChoices?: Maybe<Array<Maybe<IssueTypesObject>>>;
  grievanceTicketManualCategoryChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  grievanceTicketPriorityChoices?: Maybe<Array<Maybe<ChoiceObjectInt>>>;
  grievanceTicketSearchTypesChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  grievanceTicketStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  grievanceTicketSystemCategoryChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  grievanceTicketUrgencyChoices?: Maybe<Array<Maybe<ChoiceObjectInt>>>;
  hasAvailableUsersToExport?: Maybe<Scalars['Boolean']['output']>;
  household?: Maybe<HouseholdNode>;
  householdSearchTypesChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  identityTypeChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  importData?: Maybe<ImportDataNode>;
  importedHousehold?: Maybe<ImportedHouseholdNode>;
  importedIndividual?: Maybe<ImportedIndividualNode>;
  individual?: Maybe<IndividualNode>;
  individualSearchTypesChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  koboImportData?: Maybe<KoboImportDataNode>;
  koboProject?: Maybe<KoboAssetObject>;
  logEntryActionChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  maritalStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  me?: Maybe<UserNode>;
  observedDisabilityChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  partnerForGrievanceChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  payment?: Maybe<PaymentNode>;
  paymentPlan?: Maybe<PaymentPlanNode>;
  paymentPlanBackgroundActionStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  paymentPlanStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  paymentRecord?: Maybe<PaymentRecordNode>;
  paymentRecordDeliveryTypeChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  paymentRecordEntitlementCardStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  paymentRecordStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  paymentRecordVerification?: Maybe<PaymentVerificationNode>;
  paymentVerificationPlan?: Maybe<PaymentVerificationPlanNode>;
  paymentVerificationStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  program?: Maybe<ProgramNode>;
  programFrequencyOfPaymentsChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  programScopeChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  programSectorChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  programStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  recipients?: Maybe<RecipientNodeConnection>;
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  registrationDataImportDatahub?: Maybe<RegistrationDataImportDatahubNode>;
  registrationDataStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  relationshipChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  report?: Maybe<ReportNode>;
  reportStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  reportTypesChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  residenceStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  roleChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  sampleSize?: Maybe<GetCashplanVerificationSampleSizeObject>;
  sanctionListIndividual?: Maybe<SanctionListIndividualNode>;
  sectionChildReached?: Maybe<SectionTotalNode>;
  sectionHouseholdsReached?: Maybe<SectionTotalNode>;
  sectionIndividualsReached?: Maybe<SectionTotalNode>;
  sectionTotalTransferred?: Maybe<SectionTotalNode>;
  severityOfDisabilityChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  sexChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  survey?: Maybe<SurveyNode>;
  surveyAvailableFlows?: Maybe<Array<Maybe<RapidProFlowNode>>>;
  surveyCategoryChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  tableTotalCashTransferredByAdministrativeArea?: Maybe<TableTotalCashTransferred>;
  targetPopulation?: Maybe<TargetPopulationNode>;
  targetPopulationHouseholds?: Maybe<HouseholdNodeConnection>;
  targetPopulationStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  ticketsByCategory?: Maybe<ChartDatasetNode>;
  ticketsByLocationAndCategory?: Maybe<ChartDetailedDatasetsNode>;
  ticketsByStatus?: Maybe<ChartDatasetNode>;
  ticketsByType?: Maybe<TicketByType>;
  userPartnerChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  userRolesChoices?: Maybe<Array<Maybe<RoleChoiceObject>>>;
  userStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
  workStatusChoices?: Maybe<Array<Maybe<ChoiceObject>>>;
};


export type QueryAccountabilityCommunicationMessageArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAccountabilityCommunicationMessageSampleSizeArgs = {
  input?: InputMaybe<GetAccountabilityCommunicationMessageSampleSizeInput>;
};


export type QueryAccountabilitySampleSizeArgs = {
  input?: InputMaybe<AccountabilitySampleSizeInput>;
};


export type QueryAdminAreaArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAllAccountabilityCommunicationMessageRecipientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  messageId: Scalars['String']['input'];
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  phoneNo?: InputMaybe<Scalars['String']['input']>;
  recipientId?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllAccountabilityCommunicationMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  numberOfRecipients?: InputMaybe<Scalars['Int']['input']>;
  numberOfRecipients_Gte?: InputMaybe<Scalars['Int']['input']>;
  numberOfRecipients_Lte?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  samplingType?: InputMaybe<Scalars['String']['input']>;
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllActiveProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  dataCollectingType?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  numberOfHouseholds?: InputMaybe<Scalars['String']['input']>;
  numberOfHouseholdsWithTpInProgram?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sector?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryAllActiveTargetPopulationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type QueryAllAdminAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_Istartswith?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  parentId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllAreasTreeArgs = {
  businessArea: Scalars['String']['input'];
};


export type QueryAllBusinessAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllCashPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assistanceThrough?: InputMaybe<Scalars['String']['input']>;
  assistanceThrough_Startswith?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  deliveryType?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  endDate_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  endDate_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  serviceProvider_FullName?: InputMaybe<Scalars['String']['input']>;
  serviceProvider_FullName_Startswith?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  startDate_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  startDate_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  verificationStatus?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryAllCashPlansAndPaymentPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  deliveryType?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  endDateLte?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isPaymentVerificationPage?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  serviceProvider?: InputMaybe<Scalars['String']['input']>;
  startDateGte?: InputMaybe<Scalars['String']['input']>;
  verificationStatus?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryAllFeedbacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  feedbackId?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isActiveProgram?: InputMaybe<Scalars['String']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllFieldsAttributesArgs = {
  businessAreaSlug?: InputMaybe<Scalars['String']['input']>;
  flexField?: InputMaybe<Scalars['Boolean']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllFinancialServiceProviderXlsxReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllFinancialServiceProviderXlsxTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllFinancialServiceProvidersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  communicationChannel?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  deliveryMechanisms?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  distributionLimit?: InputMaybe<Scalars['Float']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  visionVendorNumber?: InputMaybe<Scalars['String']['input']>;
  xlsxTemplates?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


export type QueryAllGrievanceTicketArgs = {
  admin2?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  area?: InputMaybe<Scalars['String']['input']>;
  area_Startswith?: InputMaybe<Scalars['String']['input']>;
  assignedTo?: InputMaybe<Scalars['ID']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  cashPlan?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fsp?: InputMaybe<Scalars['String']['input']>;
  grievanceStatus?: InputMaybe<Scalars['String']['input']>;
  grievanceType?: InputMaybe<Scalars['String']['input']>;
  household?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  id_Startswith?: InputMaybe<Scalars['UUID']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
  isCrossArea?: InputMaybe<Scalars['Boolean']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  preferredLanguage?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  registrationDataImport?: InputMaybe<Scalars['ID']['input']>;
  scoreMax?: InputMaybe<Scalars['String']['input']>;
  scoreMin?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  totalDays?: InputMaybe<Scalars['Int']['input']>;
  urgency?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllHouseholdsArgs = {
  address?: InputMaybe<Scalars['String']['input']>;
  address_Startswith?: InputMaybe<Scalars['String']['input']>;
  admin2?: InputMaybe<Scalars['ID']['input']>;
  adminArea?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  countryOrigin?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  headOfHousehold_FullName?: InputMaybe<Scalars['String']['input']>;
  headOfHousehold_FullName_Startswith?: InputMaybe<Scalars['String']['input']>;
  headOfHousehold_PhoneNoValid?: InputMaybe<Scalars['Boolean']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  residenceStatus?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['String']['input']>;
  size_Gte?: InputMaybe<Scalars['Int']['input']>;
  size_Lte?: InputMaybe<Scalars['Int']['input']>;
  size_Range?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  targetPopulations?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAllImportedHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllImportedIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  duplicatesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllIndividualsArgs = {
  admin2?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  after?: InputMaybe<Scalars['String']['input']>;
  age?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  excludedId?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  flags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  fullName_Endswith?: InputMaybe<Scalars['String']['input']>;
  fullName_Startswith?: InputMaybe<Scalars['String']['input']>;
  household_AdminArea?: InputMaybe<Scalars['ID']['input']>;
  household_Id?: InputMaybe<Scalars['UUID']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  programs?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAllKoboProjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyDeployed?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryAllLanguagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAllLogEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  module?: InputMaybe<Scalars['String']['input']>;
  objectId?: InputMaybe<Scalars['UUID']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllMergedHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllMergedIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  duplicatesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllPaymentPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  dispersionEndDate?: InputMaybe<Scalars['Date']['input']>;
  dispersionStartDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  isFollowUp?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sourcePaymentPlanId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  totalEntitledQuantityFrom?: InputMaybe<Scalars['Float']['input']>;
  totalEntitledQuantityTo?: InputMaybe<Scalars['Float']['input']>;
};


export type QueryAllPaymentRecordsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<Scalars['ID']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllPaymentRecordsAndPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllPaymentVerificationLogEntriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  module?: InputMaybe<Scalars['String']['input']>;
  objectId?: InputMaybe<Scalars['UUID']['input']>;
  objectType?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllPaymentVerificationPlanArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllPaymentVerificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanId?: InputMaybe<Scalars['String']['input']>;
  paymentVerificationPlan?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  verificationChannel?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanId: Scalars['String']['input'];
  programId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllProgramsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  dataCollectingType?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  numberOfHouseholds?: InputMaybe<Scalars['String']['input']>;
  numberOfHouseholdsWithTpInProgram?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sector?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryAllRapidProFlowsArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryAllRegistrationDataImportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  importDate?: InputMaybe<Scalars['Date']['input']>;
  importDateRange?: InputMaybe<Scalars['String']['input']>;
  importedBy_Id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  name_Startswith?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAllRegistrationDataImportsDatahubArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryAllReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  reportType?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryAllSanctionListIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  fullName_Startswith?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  referenceNumber?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAllSteficonRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  deprecated?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  type: Scalars['String']['input'];
};


export type QueryAllSurveysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryAllTargetPopulationArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type QueryAllTicketNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  ticket: Scalars['UUID']['input'];
};


export type QueryAllUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  isFeedbackCreator?: InputMaybe<Scalars['Boolean']['input']>;
  isMessageCreator?: InputMaybe<Scalars['Boolean']['input']>;
  isSurveyCreator?: InputMaybe<Scalars['Boolean']['input']>;
  isTicketCreator?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  partner?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  search?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryAvailableFspsForDeliveryMechanismsArgs = {
  input?: InputMaybe<AvailableFspsForDeliveryMechanismsInput>;
};


export type QueryBusinessAreaArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryCashPlanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryChartGrievancesArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  year: Scalars['Int']['input'];
};


export type QueryChartIndividualsReachedByAgeAndGenderArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryChartIndividualsWithDisabilityReachedByAgeArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryChartPaymentArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryChartPaymentVerificationArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryChartProgrammesBySectorArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryChartTotalTransferredByMonthArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryChartTotalTransferredCashByCountryArgs = {
  year: Scalars['Int']['input'];
};


export type QueryChartVolumeByDeliveryMechanismArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryDashboardReportTypesChoicesArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryDashboardYearsChoicesArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryDataCollectingTypeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryExistingGrievanceTicketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  category?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentRecord?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  permissions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryFeedbackArgs = {
  id: Scalars['ID']['input'];
};


export type QueryFinancialServiceProviderArgs = {
  id: Scalars['ID']['input'];
};


export type QueryFinancialServiceProviderXlsxReportArgs = {
  id: Scalars['ID']['input'];
};


export type QueryFinancialServiceProviderXlsxTemplateArgs = {
  id: Scalars['ID']['input'];
};


export type QueryGrievanceTicketArgs = {
  id: Scalars['ID']['input'];
};


export type QueryHasAvailableUsersToExportArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryHouseholdArgs = {
  id: Scalars['ID']['input'];
};


export type QueryImportDataArgs = {
  id: Scalars['ID']['input'];
};


export type QueryImportedHouseholdArgs = {
  id: Scalars['ID']['input'];
};


export type QueryImportedIndividualArgs = {
  id: Scalars['ID']['input'];
};


export type QueryIndividualArgs = {
  id: Scalars['ID']['input'];
};


export type QueryKoboImportDataArgs = {
  id: Scalars['ID']['input'];
};


export type QueryKoboProjectArgs = {
  businessAreaSlug: Scalars['String']['input'];
  uid: Scalars['String']['input'];
};


export type QueryPartnerForGrievanceChoicesArgs = {
  householdId?: InputMaybe<Scalars['ID']['input']>;
  individualId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryPaymentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPaymentPlanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPaymentRecordArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPaymentRecordVerificationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPaymentVerificationPlanArgs = {
  id: Scalars['ID']['input'];
};


export type QueryProgramArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRecipientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  survey: Scalars['String']['input'];
};


export type QueryRegistrationDataImportArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRegistrationDataImportDatahubArgs = {
  id: Scalars['ID']['input'];
};


export type QueryReportArgs = {
  id: Scalars['ID']['input'];
};


export type QuerySampleSizeArgs = {
  input?: InputMaybe<GetCashplanVerificationSampleSizeInput>;
};


export type QuerySanctionListIndividualArgs = {
  id: Scalars['ID']['input'];
};


export type QuerySectionChildReachedArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QuerySectionHouseholdsReachedArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QuerySectionIndividualsReachedArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QuerySectionTotalTransferredArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QuerySurveyArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTableTotalCashTransferredByAdministrativeAreaArgs = {
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  businessAreaSlug: Scalars['String']['input'];
  order?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  year: Scalars['Int']['input'];
};


export type QueryTargetPopulationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTargetPopulationHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  targetPopulation: Scalars['ID']['input'];
};


export type QueryTicketsByCategoryArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryTicketsByLocationAndCategoryArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryTicketsByStatusArgs = {
  businessAreaSlug: Scalars['String']['input'];
};


export type QueryTicketsByTypeArgs = {
  businessAreaSlug: Scalars['String']['input'];
};

export type RandomSamplingArguments = {
  age?: InputMaybe<AgeInput>;
  confidenceInterval: Scalars['Float']['input'];
  excludedAdminAreas?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  marginOfError: Scalars['Float']['input'];
  sex?: InputMaybe<Scalars['String']['input']>;
};

export type RapidProArguments = {
  flowId: Scalars['String']['input'];
};

export type RapidProFlow = {
  __typename?: 'RapidProFlow';
  archived?: Maybe<Scalars['Boolean']['output']>;
  createdOn?: Maybe<Scalars['DateTime']['output']>;
  expires?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  labels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  modifiedOn?: Maybe<Scalars['DateTime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  results?: Maybe<Array<Maybe<RapidProFlowResult>>>;
  runs?: Maybe<Array<Maybe<RapidProFlowRun>>>;
  type?: Maybe<Scalars['String']['output']>;
};

export type RapidProFlowNode = {
  __typename?: 'RapidProFlowNode';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

export type RapidProFlowResult = {
  __typename?: 'RapidProFlowResult';
  categories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  key?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nodeUuids?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type RapidProFlowRun = {
  __typename?: 'RapidProFlowRun';
  active?: Maybe<Scalars['Int']['output']>;
  completed?: Maybe<Scalars['Int']['output']>;
  expired?: Maybe<Scalars['Int']['output']>;
  interrupted?: Maybe<Scalars['Int']['output']>;
};

export type ReassignRoleMutation = {
  __typename?: 'ReassignRoleMutation';
  household?: Maybe<HouseholdNode>;
  individual?: Maybe<IndividualNode>;
};

export type RebuildTargetPopulationMutation = {
  __typename?: 'RebuildTargetPopulationMutation';
  targetPopulation?: Maybe<TargetPopulationNode>;
};

export type RecipientNode = Node & {
  __typename?: 'RecipientNode';
  headOfHousehold: IndividualNode;
  id: Scalars['ID']['output'];
  size?: Maybe<Scalars['Int']['output']>;
};

export type RecipientNodeConnection = {
  __typename?: 'RecipientNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<RecipientNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type RecipientNodeEdge = {
  __typename?: 'RecipientNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<RecipientNode>;
};

export type ReconciliationSummaryNode = {
  __typename?: 'ReconciliationSummaryNode';
  deliveredFully?: Maybe<Scalars['Int']['output']>;
  deliveredPartially?: Maybe<Scalars['Int']['output']>;
  forceFailed?: Maybe<Scalars['Int']['output']>;
  notDelivered?: Maybe<Scalars['Int']['output']>;
  numberOfPayments?: Maybe<Scalars['Int']['output']>;
  pending?: Maybe<Scalars['Int']['output']>;
  reconciled?: Maybe<Scalars['Int']['output']>;
  unsuccessful?: Maybe<Scalars['Int']['output']>;
};

export type ReferralTicketExtras = {
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
};

export type RefuseRegistrationDataImportMutation = {
  __typename?: 'RefuseRegistrationDataImportMutation';
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
};

export enum RegistrationDataImportDataSource {
  Api = 'API',
  Edopomoga = 'EDOPOMOGA',
  FlexRegistration = 'FLEX_REGISTRATION',
  Kobo = 'KOBO',
  Xls = 'XLS'
}

export enum RegistrationDataImportDatahubImportDone {
  Done = 'DONE',
  Loading = 'LOADING',
  NotStarted = 'NOT_STARTED',
  Started = 'STARTED'
}

export type RegistrationDataImportDatahubNode = Node & {
  __typename?: 'RegistrationDataImportDatahubNode';
  businessAreaSlug: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  hctId?: Maybe<Scalars['UUID']['output']>;
  households: ImportedHouseholdNodeConnection;
  id: Scalars['ID']['output'];
  importData?: Maybe<ImportDataNode>;
  importDate: Scalars['DateTime']['output'];
  importDone: RegistrationDataImportDatahubImportDone;
  individuals: ImportedIndividualNodeConnection;
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};


export type RegistrationDataImportDatahubNodeHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type RegistrationDataImportDatahubNodeIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type RegistrationDataImportDatahubNodeConnection = {
  __typename?: 'RegistrationDataImportDatahubNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<RegistrationDataImportDatahubNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type RegistrationDataImportDatahubNodeEdge = {
  __typename?: 'RegistrationDataImportDatahubNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<RegistrationDataImportDatahubNode>;
};

export type RegistrationDataImportNode = Node & {
  __typename?: 'RegistrationDataImportNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  batchDuplicates: Scalars['Int']['output'];
  batchDuplicatesCountAndPercentage?: Maybe<CountAndPercentageNode>;
  batchPossibleDuplicates: Scalars['Int']['output'];
  batchPossibleDuplicatesCountAndPercentage?: Maybe<CountAndPercentageNode>;
  batchUnique: Scalars['Int']['output'];
  batchUniqueCountAndPercentage?: Maybe<CountAndPercentageNode>;
  businessArea?: Maybe<UserBusinessAreaNode>;
  createdAt: Scalars['DateTime']['output'];
  dataSource: RegistrationDataImportDataSource;
  datahubId?: Maybe<Scalars['UUID']['output']>;
  erased: Scalars['Boolean']['output'];
  errorMessage: Scalars['String']['output'];
  excluded: Scalars['Boolean']['output'];
  goldenRecordDuplicates: Scalars['Int']['output'];
  goldenRecordDuplicatesCountAndPercentage?: Maybe<CountAndPercentageNode>;
  goldenRecordPossibleDuplicates: Scalars['Int']['output'];
  goldenRecordPossibleDuplicatesCountAndPercentage?: Maybe<CountAndPercentageNode>;
  goldenRecordUnique: Scalars['Int']['output'];
  goldenRecordUniqueCountAndPercentage?: Maybe<CountAndPercentageNode>;
  grievanceticketSet: GrievanceTicketNodeConnection;
  households: HouseholdNodeConnection;
  id: Scalars['ID']['output'];
  importDate: Scalars['DateTime']['output'];
  importedBy?: Maybe<UserNode>;
  individuals: IndividualNodeConnection;
  messages: CommunicationMessageNodeConnection;
  name: Scalars['String']['output'];
  numberOfHouseholds: Scalars['Int']['output'];
  numberOfIndividuals: Scalars['Int']['output'];
  program?: Maybe<ProgramNode>;
  pullPictures: Scalars['Boolean']['output'];
  refuseReason?: Maybe<Scalars['String']['output']>;
  screenBeneficiary: Scalars['Boolean']['output'];
  sentryId?: Maybe<Scalars['String']['output']>;
  status: RegistrationDataImportStatus;
  totalHouseholdsCountWithValidPhoneNo?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  version: Scalars['BigInt']['output'];
};


export type RegistrationDataImportNodeGrievanceticketSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type RegistrationDataImportNodeHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type RegistrationDataImportNodeIndividualsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type RegistrationDataImportNodeMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type RegistrationDataImportNodeConnection = {
  __typename?: 'RegistrationDataImportNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<RegistrationDataImportNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type RegistrationDataImportNodeEdge = {
  __typename?: 'RegistrationDataImportNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<RegistrationDataImportNode>;
};

export enum RegistrationDataImportStatus {
  Deduplication = 'DEDUPLICATION',
  DeduplicationFailed = 'DEDUPLICATION_FAILED',
  Importing = 'IMPORTING',
  ImportError = 'IMPORT_ERROR',
  ImportScheduled = 'IMPORT_SCHEDULED',
  InReview = 'IN_REVIEW',
  Loading = 'LOADING',
  Merged = 'MERGED',
  MergeError = 'MERGE_ERROR',
  MergeScheduled = 'MERGE_SCHEDULED',
  Merging = 'MERGING',
  Refused = 'REFUSED'
}

export type RegistrationDeduplicationMutation = {
  __typename?: 'RegistrationDeduplicationMutation';
  ok?: Maybe<Scalars['Boolean']['output']>;
};

export type RegistrationKoboImportMutation = {
  __typename?: 'RegistrationKoboImportMutation';
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type RegistrationKoboImportMutationInput = {
  businessAreaSlug?: InputMaybe<Scalars['String']['input']>;
  importDataId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pullPictures?: InputMaybe<Scalars['Boolean']['input']>;
  screenBeneficiary?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RegistrationXlsxImportMutation = {
  __typename?: 'RegistrationXlsxImportMutation';
  registrationDataImport?: Maybe<RegistrationDataImportNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type RegistrationXlsxImportMutationInput = {
  businessAreaSlug?: InputMaybe<Scalars['String']['input']>;
  importDataId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  screenBeneficiary?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReportNode = Node & {
  __typename?: 'ReportNode';
  adminArea: AreaNodeConnection;
  adminArea1?: Maybe<AreaNodeConnection>;
  adminArea2?: Maybe<AreaNodeConnection>;
  businessArea: UserBusinessAreaNode;
  createdAt: Scalars['DateTime']['output'];
  createdBy: UserNode;
  dateFrom: Scalars['Date']['output'];
  dateTo: Scalars['Date']['output'];
  file?: Maybe<Scalars['String']['output']>;
  fileUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  numberOfRecords?: Maybe<Scalars['Int']['output']>;
  program?: Maybe<ProgramNode>;
  reportType: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  updatedAt: Scalars['DateTime']['output'];
};


export type ReportNodeAdminAreaArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ReportNodeAdminArea1Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ReportNodeAdminArea2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type ReportNodeConnection = {
  __typename?: 'ReportNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ReportNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ReportNodeEdge = {
  __typename?: 'ReportNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ReportNode>;
};

export type RestartCreateReport = {
  __typename?: 'RestartCreateReport';
  report?: Maybe<ReportNode>;
};

export type RestartCreateReportInput = {
  businessAreaSlug: Scalars['String']['input'];
  reportId: Scalars['ID']['input'];
};

export type RevertMarkPaymentAsFailedMutation = {
  __typename?: 'RevertMarkPaymentAsFailedMutation';
  payment?: Maybe<PaymentNode>;
};

export type RevertMarkPaymentRecordAsFailedMutation = {
  __typename?: 'RevertMarkPaymentRecordAsFailedMutation';
  paymentRecord?: Maybe<PaymentRecordNode>;
};

export type RoleChoiceObject = {
  __typename?: 'RoleChoiceObject';
  name?: Maybe<Scalars['String']['output']>;
  subsystem?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type RoleNode = {
  __typename?: 'RoleNode';
  createdAt: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  permissions?: Maybe<Array<Scalars['String']['output']>>;
  subsystem: RoleSubsystem;
  updatedAt: Scalars['DateTime']['output'];
  userRoles: Array<UserRoleNode>;
};

export enum RoleSubsystem {
  Api = 'API',
  Ca = 'CA',
  Hope = 'HOPE',
  Kobo = 'KOBO'
}

export enum RuleCommitLanguage {
  Python = 'PYTHON'
}

export type RuleCommitNode = Node & {
  __typename?: 'RuleCommitNode';
  affectedFields: Array<Scalars['String']['output']>;
  after: Scalars['JSONString']['output'];
  before: Scalars['JSONString']['output'];
  definition: Scalars['String']['output'];
  deprecated: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  isRelease: Scalars['Boolean']['output'];
  language: RuleCommitLanguage;
  paymentPlans: PaymentPlanNodeConnection;
  rule?: Maybe<SteficonRuleNode>;
  targetPopulations: TargetPopulationNodeConnection;
  timestamp: Scalars['DateTime']['output'];
  updatedBy?: Maybe<UserNode>;
};


export type RuleCommitNodePaymentPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type RuleCommitNodeTargetPopulationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};

export type RuleCommitNodeConnection = {
  __typename?: 'RuleCommitNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<RuleCommitNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type RuleCommitNodeEdge = {
  __typename?: 'RuleCommitNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<RuleCommitNode>;
};

export enum RuleLanguage {
  Python = 'PYTHON'
}

export enum RuleSecurity {
  A_0 = 'A_0',
  A_2 = 'A_2',
  A_4 = 'A_4'
}

export enum RuleType {
  PaymentPlan = 'PAYMENT_PLAN',
  Targeting = 'TARGETING'
}

export enum SamplingChoices {
  FullList = 'FULL_LIST',
  Random = 'RANDOM'
}

export type SanctionListIndividualAliasNameNode = Node & {
  __typename?: 'SanctionListIndividualAliasNameNode';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type SanctionListIndividualAliasNameNodeConnection = {
  __typename?: 'SanctionListIndividualAliasNameNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SanctionListIndividualAliasNameNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SanctionListIndividualAliasNameNodeEdge = {
  __typename?: 'SanctionListIndividualAliasNameNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SanctionListIndividualAliasNameNode>;
};

export type SanctionListIndividualCountriesNode = Node & {
  __typename?: 'SanctionListIndividualCountriesNode';
  country?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type SanctionListIndividualCountriesNodeConnection = {
  __typename?: 'SanctionListIndividualCountriesNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SanctionListIndividualCountriesNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SanctionListIndividualCountriesNodeEdge = {
  __typename?: 'SanctionListIndividualCountriesNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SanctionListIndividualCountriesNode>;
};

export type SanctionListIndividualDateOfBirthNode = Node & {
  __typename?: 'SanctionListIndividualDateOfBirthNode';
  createdAt: Scalars['DateTime']['output'];
  date: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type SanctionListIndividualDateOfBirthNodeConnection = {
  __typename?: 'SanctionListIndividualDateOfBirthNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SanctionListIndividualDateOfBirthNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SanctionListIndividualDateOfBirthNodeEdge = {
  __typename?: 'SanctionListIndividualDateOfBirthNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SanctionListIndividualDateOfBirthNode>;
};

export type SanctionListIndividualDocumentNode = Node & {
  __typename?: 'SanctionListIndividualDocumentNode';
  createdAt: Scalars['DateTime']['output'];
  dateOfIssue?: Maybe<Scalars['String']['output']>;
  documentNumber: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  issuingCountry?: Maybe<Scalars['String']['output']>;
  note: Scalars['String']['output'];
  typeOfDocument: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type SanctionListIndividualDocumentNodeConnection = {
  __typename?: 'SanctionListIndividualDocumentNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SanctionListIndividualDocumentNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SanctionListIndividualDocumentNodeEdge = {
  __typename?: 'SanctionListIndividualDocumentNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SanctionListIndividualDocumentNode>;
};

export type SanctionListIndividualNationalitiesNode = Node & {
  __typename?: 'SanctionListIndividualNationalitiesNode';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  nationality?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type SanctionListIndividualNationalitiesNodeConnection = {
  __typename?: 'SanctionListIndividualNationalitiesNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SanctionListIndividualNationalitiesNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SanctionListIndividualNationalitiesNodeEdge = {
  __typename?: 'SanctionListIndividualNationalitiesNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SanctionListIndividualNationalitiesNode>;
};

export type SanctionListIndividualNode = Node & {
  __typename?: 'SanctionListIndividualNode';
  active: Scalars['Boolean']['output'];
  addressNote: Scalars['String']['output'];
  aliasNames: SanctionListIndividualAliasNameNodeConnection;
  city: Scalars['String']['output'];
  comments: Scalars['String']['output'];
  countries: SanctionListIndividualCountriesNodeConnection;
  countryOfBirth?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  dataId: Scalars['Int']['output'];
  datesOfBirth: SanctionListIndividualDateOfBirthNodeConnection;
  designation: Scalars['String']['output'];
  documents: SanctionListIndividualDocumentNodeConnection;
  firstName: Scalars['String']['output'];
  fourthName: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  listType: Scalars['String']['output'];
  listedOn: Scalars['DateTime']['output'];
  nameOriginalScript: Scalars['String']['output'];
  nationalities: SanctionListIndividualNationalitiesNodeConnection;
  referenceNumber: Scalars['String']['output'];
  secondName: Scalars['String']['output'];
  stateProvince: Scalars['String']['output'];
  street: Scalars['String']['output'];
  thirdName: Scalars['String']['output'];
  unListType: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  versionNum: Scalars['Int']['output'];
};


export type SanctionListIndividualNodeAliasNamesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type SanctionListIndividualNodeCountriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type SanctionListIndividualNodeDatesOfBirthArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type SanctionListIndividualNodeDocumentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type SanctionListIndividualNodeNationalitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type SanctionListIndividualNodeConnection = {
  __typename?: 'SanctionListIndividualNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SanctionListIndividualNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SanctionListIndividualNodeEdge = {
  __typename?: 'SanctionListIndividualNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SanctionListIndividualNode>;
};

export type SaveKoboProjectImportDataAsync = {
  __typename?: 'SaveKoboProjectImportDataAsync';
  importData?: Maybe<KoboImportDataNode>;
};

export type SectionTotalNode = {
  __typename?: 'SectionTotalNode';
  total?: Maybe<Scalars['Float']['output']>;
};

export type SensitiveGrievanceTicketExtras = {
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
  paymentRecord?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

export type ServiceProviderNode = Node & {
  __typename?: 'ServiceProviderNode';
  businessArea: UserBusinessAreaNode;
  caId: Scalars['String']['output'];
  cashPlans: CashPlanNodeConnection;
  country: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  paymentrecordSet: PaymentRecordNodeConnection;
  shortName?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  visionId?: Maybe<Scalars['String']['output']>;
};


export type ServiceProviderNodeCashPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ServiceProviderNodePaymentrecordSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type ServiceProviderNodeConnection = {
  __typename?: 'ServiceProviderNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<ServiceProviderNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type ServiceProviderNodeEdge = {
  __typename?: 'ServiceProviderNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<ServiceProviderNode>;
};

export type SetSteficonRuleOnPaymentPlanPaymentListMutation = {
  __typename?: 'SetSteficonRuleOnPaymentPlanPaymentListMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type SetSteficonRuleOnTargetPopulationMutationInput = {
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  steficonRuleId?: InputMaybe<Scalars['ID']['input']>;
  targetId: Scalars['ID']['input'];
  version?: InputMaybe<Scalars['BigInt']['input']>;
};

export type SetSteficonRuleOnTargetPopulationMutationPayload = {
  __typename?: 'SetSteficonRuleOnTargetPopulationMutationPayload';
  clientMutationId?: Maybe<Scalars['String']['output']>;
  targetPopulation?: Maybe<TargetPopulationNode>;
};

export type SimpleApproveMutation = {
  __typename?: 'SimpleApproveMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type SplitPaymentPlanMutation = {
  __typename?: 'SplitPaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type SteficonRuleNode = Node & {
  __typename?: 'SteficonRuleNode';
  allowedBusinessAreas: UserBusinessAreaNodeConnection;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  definition: Scalars['String']['output'];
  deprecated: Scalars['Boolean']['output'];
  description?: Maybe<Scalars['String']['output']>;
  enabled: Scalars['Boolean']['output'];
  flags: Scalars['JSONString']['output'];
  history: RuleCommitNodeConnection;
  id: Scalars['ID']['output'];
  language: RuleLanguage;
  name: Scalars['String']['output'];
  security: RuleSecurity;
  type: RuleType;
  updatedAt: Scalars['DateTime']['output'];
  updatedBy?: Maybe<UserNode>;
};


export type SteficonRuleNodeAllowedBusinessAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type SteficonRuleNodeHistoryArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type SteficonRuleNodeConnection = {
  __typename?: 'SteficonRuleNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SteficonRuleNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SteficonRuleNodeEdge = {
  __typename?: 'SteficonRuleNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SteficonRuleNode>;
};

export enum SurveyCategory {
  Manual = 'MANUAL',
  RapidPro = 'RAPID_PRO',
  Sms = 'SMS'
}

export type SurveyNode = Node & {
  __typename?: 'SurveyNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  body: Scalars['String']['output'];
  businessArea: UserBusinessAreaNode;
  category: SurveyCategory;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  flowId?: Maybe<Scalars['String']['output']>;
  fullListArguments: Scalars['JSONString']['output'];
  hasValidSampleFile?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  numberOfRecipients: Scalars['Int']['output'];
  program?: Maybe<ProgramNode>;
  randomSamplingArguments: Scalars['JSONString']['output'];
  rapidProUrl?: Maybe<Scalars['String']['output']>;
  recipients: HouseholdNodeConnection;
  sampleFile?: Maybe<Scalars['String']['output']>;
  sampleFileGeneratedAt?: Maybe<Scalars['DateTime']['output']>;
  sampleFilePath?: Maybe<Scalars['String']['output']>;
  sampleSize: Scalars['Int']['output'];
  samplingType: SurveySamplingType;
  successfulRapidProCalls: Array<Scalars['JSONString']['output']>;
  targetPopulation?: Maybe<TargetPopulationNode>;
  title: Scalars['String']['output'];
  unicefId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


export type SurveyNodeRecipientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type SurveyNodeConnection = {
  __typename?: 'SurveyNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<SurveyNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type SurveyNodeEdge = {
  __typename?: 'SurveyNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<SurveyNode>;
};

export enum SurveySamplingType {
  FullList = 'FULL_LIST',
  Random = 'RANDOM'
}

export type TableTotalCashTransferred = {
  __typename?: 'TableTotalCashTransferred';
  data?: Maybe<Array<Maybe<_TableTotalCashTransferredDataNode>>>;
};

export enum TargetPopulationBuildStatus {
  Building = 'BUILDING',
  Failed = 'FAILED',
  Ok = 'OK',
  Pending = 'PENDING'
}

export type TargetPopulationNode = Node & {
  __typename?: 'TargetPopulationNode';
  adminUrl?: Maybe<Scalars['String']['output']>;
  adultFemaleCount?: Maybe<Scalars['Int']['output']>;
  adultMaleCount?: Maybe<Scalars['Int']['output']>;
  buildStatus: TargetPopulationBuildStatus;
  builtAt?: Maybe<Scalars['DateTime']['output']>;
  businessArea?: Maybe<UserBusinessAreaNode>;
  caHashId?: Maybe<Scalars['String']['output']>;
  caId?: Maybe<Scalars['String']['output']>;
  changeDate?: Maybe<Scalars['DateTime']['output']>;
  changedBy?: Maybe<UserNode>;
  childFemaleCount?: Maybe<Scalars['Int']['output']>;
  childMaleCount?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  excludedIds: Scalars['String']['output'];
  exclusionReason: Scalars['String']['output'];
  finalizedAt?: Maybe<Scalars['DateTime']['output']>;
  finalizedBy?: Maybe<UserNode>;
  hasEmptyCriteria?: Maybe<Scalars['Boolean']['output']>;
  householdList?: Maybe<HouseholdNodeConnection>;
  households?: Maybe<HouseholdNodeConnection>;
  id: Scalars['ID']['output'];
  isRemoved: Scalars['Boolean']['output'];
  messages: CommunicationMessageNodeConnection;
  name: Scalars['String']['output'];
  paymentPlans: PaymentPlanNodeConnection;
  paymentRecords: PaymentRecordNodeConnection;
  program?: Maybe<ProgramNode>;
  selections: Array<HouseholdSelectionNode>;
  sentToDatahub: Scalars['Boolean']['output'];
  status: TargetPopulationStatus;
  steficonAppliedDate?: Maybe<Scalars['DateTime']['output']>;
  steficonRule?: Maybe<RuleCommitNode>;
  surveys: SurveyNodeConnection;
  targetingCriteria?: Maybe<TargetingCriteriaNode>;
  totalFamilySize?: Maybe<Scalars['Int']['output']>;
  totalHouseholdsCount?: Maybe<Scalars['Int']['output']>;
  totalHouseholdsCountWithValidPhoneNo?: Maybe<Scalars['Int']['output']>;
  totalIndividualsCount?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  version: Scalars['BigInt']['output'];
  vulnerabilityScoreMax?: Maybe<Scalars['Float']['output']>;
  vulnerabilityScoreMin?: Maybe<Scalars['Float']['output']>;
};


export type TargetPopulationNodeHouseholdListArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
};


export type TargetPopulationNodeHouseholdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
};


export type TargetPopulationNodeMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type TargetPopulationNodePaymentPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type TargetPopulationNodePaymentRecordsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type TargetPopulationNodeSurveysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type TargetPopulationNodeConnection = {
  __typename?: 'TargetPopulationNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TargetPopulationNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TargetPopulationNodeEdge = {
  __typename?: 'TargetPopulationNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TargetPopulationNode>;
};

export enum TargetPopulationStatus {
  Assigned = 'ASSIGNED',
  Locked = 'LOCKED',
  Open = 'OPEN',
  Processing = 'PROCESSING',
  ReadyForCashAssist = 'READY_FOR_CASH_ASSIST',
  ReadyForPaymentModule = 'READY_FOR_PAYMENT_MODULE',
  SendingToCashAssist = 'SENDING_TO_CASH_ASSIST',
  SteficonCompleted = 'STEFICON_COMPLETED',
  SteficonError = 'STEFICON_ERROR',
  SteficonRun = 'STEFICON_RUN',
  SteficonWait = 'STEFICON_WAIT'
}

export type TargetingCriteriaNode = {
  __typename?: 'TargetingCriteriaNode';
  createdAt: Scalars['DateTime']['output'];
  flagExcludeIfActiveAdjudicationTicket: Scalars['Boolean']['output'];
  flagExcludeIfOnSanctionList: Scalars['Boolean']['output'];
  id: Scalars['UUID']['output'];
  rules?: Maybe<Array<Maybe<TargetingCriteriaRuleNode>>>;
  targetPopulation?: Maybe<TargetPopulationNode>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TargetingCriteriaObjectType = {
  flagExcludeIfActiveAdjudicationTicket?: InputMaybe<Scalars['Boolean']['input']>;
  flagExcludeIfOnSanctionList?: InputMaybe<Scalars['Boolean']['input']>;
  rules?: InputMaybe<Array<InputMaybe<TargetingCriteriaRuleObjectType>>>;
};

export enum TargetingCriteriaRuleFilterComparisonMethod {
  Contains = 'CONTAINS',
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  LessThan = 'LESS_THAN',
  NotContains = 'NOT_CONTAINS',
  NotEquals = 'NOT_EQUALS',
  NotInRange = 'NOT_IN_RANGE',
  Range = 'RANGE'
}

export type TargetingCriteriaRuleFilterNode = {
  __typename?: 'TargetingCriteriaRuleFilterNode';
  arguments?: Maybe<Array<Maybe<Scalars['Arg']['output']>>>;
  comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod;
  createdAt: Scalars['DateTime']['output'];
  fieldAttribute?: Maybe<FieldAttributeNode>;
  fieldName: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  isFlexField: Scalars['Boolean']['output'];
  targetingCriteriaRule: TargetingCriteriaRuleNode;
  updatedAt: Scalars['DateTime']['output'];
};

export type TargetingCriteriaRuleFilterObjectType = {
  arguments: Array<InputMaybe<Scalars['Arg']['input']>>;
  comparisonMethod: Scalars['String']['input'];
  fieldName: Scalars['String']['input'];
  isFlexField: Scalars['Boolean']['input'];
};

export type TargetingCriteriaRuleNode = {
  __typename?: 'TargetingCriteriaRuleNode';
  createdAt: Scalars['DateTime']['output'];
  filters?: Maybe<Array<Maybe<TargetingCriteriaRuleFilterNode>>>;
  id: Scalars['UUID']['output'];
  individualsFiltersBlocks?: Maybe<Array<Maybe<TargetingIndividualRuleFilterBlockNode>>>;
  targetingCriteria: TargetingCriteriaNode;
  updatedAt: Scalars['DateTime']['output'];
};

export type TargetingCriteriaRuleObjectType = {
  filters?: InputMaybe<Array<InputMaybe<TargetingCriteriaRuleFilterObjectType>>>;
  individualsFiltersBlocks?: InputMaybe<Array<InputMaybe<TargetingIndividualRuleFilterBlockObjectType>>>;
};

export enum TargetingIndividualBlockRuleFilterComparisonMethod {
  Contains = 'CONTAINS',
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  LessThan = 'LESS_THAN',
  NotContains = 'NOT_CONTAINS',
  NotEquals = 'NOT_EQUALS',
  NotInRange = 'NOT_IN_RANGE',
  Range = 'RANGE'
}

export type TargetingIndividualBlockRuleFilterNode = {
  __typename?: 'TargetingIndividualBlockRuleFilterNode';
  arguments?: Maybe<Array<Maybe<Scalars['Arg']['output']>>>;
  comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod;
  createdAt: Scalars['DateTime']['output'];
  fieldAttribute?: Maybe<FieldAttributeNode>;
  fieldName: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  individualsFiltersBlock: TargetingIndividualRuleFilterBlockNode;
  isFlexField: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type TargetingIndividualRuleFilterBlockNode = {
  __typename?: 'TargetingIndividualRuleFilterBlockNode';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['UUID']['output'];
  individualBlockFilters?: Maybe<Array<Maybe<TargetingIndividualBlockRuleFilterNode>>>;
  targetOnlyHoh: Scalars['Boolean']['output'];
  targetingCriteriaRule: TargetingCriteriaRuleNode;
  updatedAt: Scalars['DateTime']['output'];
};

export type TargetingIndividualRuleFilterBlockObjectType = {
  individualBlockFilters?: InputMaybe<Array<InputMaybe<TargetingCriteriaRuleFilterObjectType>>>;
};

export type TicketAddIndividualDetailsNode = Node & {
  __typename?: 'TicketAddIndividualDetailsNode';
  approveStatus: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individualData?: Maybe<Scalars['Arg']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketAddIndividualDetailsNodeConnection = {
  __typename?: 'TicketAddIndividualDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketAddIndividualDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketAddIndividualDetailsNodeEdge = {
  __typename?: 'TicketAddIndividualDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketAddIndividualDetailsNode>;
};

export type TicketByType = {
  __typename?: 'TicketByType';
  closedSystemGeneratedCount?: Maybe<Scalars['Int']['output']>;
  closedUserGeneratedCount?: Maybe<Scalars['Int']['output']>;
  systemGeneratedAvgResolution?: Maybe<Scalars['Float']['output']>;
  systemGeneratedCount?: Maybe<Scalars['Int']['output']>;
  userGeneratedAvgResolution?: Maybe<Scalars['Float']['output']>;
  userGeneratedCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketComplaintDetailsNode = Node & {
  __typename?: 'TicketComplaintDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  paymentContentType?: Maybe<ContentTypeObjectType>;
  paymentObjectId?: Maybe<Scalars['UUID']['output']>;
  paymentRecord?: Maybe<PaymentRecordAndPaymentNode>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketComplaintDetailsNodeConnection = {
  __typename?: 'TicketComplaintDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketComplaintDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketComplaintDetailsNodeEdge = {
  __typename?: 'TicketComplaintDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketComplaintDetailsNode>;
};

export type TicketDeleteHouseholdDetailsNode = Node & {
  __typename?: 'TicketDeleteHouseholdDetailsNode';
  approveStatus: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  householdData?: Maybe<Scalars['Arg']['output']>;
  id: Scalars['ID']['output'];
  reasonHousehold?: Maybe<HouseholdNode>;
  roleReassignData: Scalars['JSONString']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketDeleteHouseholdDetailsNodeConnection = {
  __typename?: 'TicketDeleteHouseholdDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketDeleteHouseholdDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketDeleteHouseholdDetailsNodeEdge = {
  __typename?: 'TicketDeleteHouseholdDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketDeleteHouseholdDetailsNode>;
};

export type TicketDeleteIndividualDetailsNode = Node & {
  __typename?: 'TicketDeleteIndividualDetailsNode';
  approveStatus: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  individualData?: Maybe<Scalars['Arg']['output']>;
  roleReassignData: Scalars['JSONString']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketDeleteIndividualDetailsNodeConnection = {
  __typename?: 'TicketDeleteIndividualDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketDeleteIndividualDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketDeleteIndividualDetailsNodeEdge = {
  __typename?: 'TicketDeleteIndividualDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketDeleteIndividualDetailsNode>;
};

export type TicketHouseholdDataUpdateDetailsNode = Node & {
  __typename?: 'TicketHouseholdDataUpdateDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  householdData?: Maybe<Scalars['Arg']['output']>;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketHouseholdDataUpdateDetailsNodeConnection = {
  __typename?: 'TicketHouseholdDataUpdateDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketHouseholdDataUpdateDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketHouseholdDataUpdateDetailsNodeEdge = {
  __typename?: 'TicketHouseholdDataUpdateDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketHouseholdDataUpdateDetailsNode>;
};

export type TicketIndividualDataUpdateDetailsNode = Node & {
  __typename?: 'TicketIndividualDataUpdateDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  individualData?: Maybe<Scalars['Arg']['output']>;
  roleReassignData: Scalars['JSONString']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketIndividualDataUpdateDetailsNodeConnection = {
  __typename?: 'TicketIndividualDataUpdateDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketIndividualDataUpdateDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketIndividualDataUpdateDetailsNodeEdge = {
  __typename?: 'TicketIndividualDataUpdateDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketIndividualDataUpdateDetailsNode>;
};

export type TicketNeedsAdjudicationDetailsExtraDataNode = {
  __typename?: 'TicketNeedsAdjudicationDetailsExtraDataNode';
  goldenRecords?: Maybe<Array<Maybe<DeduplicationResultNode>>>;
  possibleDuplicate?: Maybe<Array<Maybe<DeduplicationResultNode>>>;
};

export type TicketNeedsAdjudicationDetailsNode = Node & {
  __typename?: 'TicketNeedsAdjudicationDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  extraData?: Maybe<TicketNeedsAdjudicationDetailsExtraDataNode>;
  goldenRecordsIndividual: IndividualNode;
  hasDuplicatedDocument?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  isCrossArea: Scalars['Boolean']['output'];
  isMultipleDuplicatesVersion: Scalars['Boolean']['output'];
  possibleDuplicate?: Maybe<IndividualNode>;
  possibleDuplicates?: Maybe<Array<Maybe<IndividualNode>>>;
  roleReassignData: Scalars['JSONString']['output'];
  scoreMax: Scalars['Float']['output'];
  scoreMin: Scalars['Float']['output'];
  selectedIndividual?: Maybe<IndividualNode>;
  selectedIndividuals?: Maybe<Array<Maybe<IndividualNode>>>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketNeedsAdjudicationDetailsNodeConnection = {
  __typename?: 'TicketNeedsAdjudicationDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketNeedsAdjudicationDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketNeedsAdjudicationDetailsNodeEdge = {
  __typename?: 'TicketNeedsAdjudicationDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketNeedsAdjudicationDetailsNode>;
};

export type TicketNegativeFeedbackDetailsNode = Node & {
  __typename?: 'TicketNegativeFeedbackDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketNegativeFeedbackDetailsNodeConnection = {
  __typename?: 'TicketNegativeFeedbackDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketNegativeFeedbackDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketNegativeFeedbackDetailsNodeEdge = {
  __typename?: 'TicketNegativeFeedbackDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketNegativeFeedbackDetailsNode>;
};

export type TicketNoteNode = Node & {
  __typename?: 'TicketNoteNode';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<UserNode>;
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketNoteNodeConnection = {
  __typename?: 'TicketNoteNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketNoteNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketNoteNodeEdge = {
  __typename?: 'TicketNoteNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketNoteNode>;
};

export type TicketPaymentVerificationDetailsExtras = {
  newReceivedAmount?: InputMaybe<Scalars['Float']['input']>;
  newStatus?: InputMaybe<Scalars['String']['input']>;
};

export enum TicketPaymentVerificationDetailsNewStatus {
  NotReceived = 'NOT_RECEIVED',
  Pending = 'PENDING',
  Received = 'RECEIVED',
  ReceivedWithIssues = 'RECEIVED_WITH_ISSUES'
}

export type TicketPaymentVerificationDetailsNode = Node & {
  __typename?: 'TicketPaymentVerificationDetailsNode';
  approveStatus: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  hasMultiplePaymentVerifications?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['ID']['output'];
  newReceivedAmount?: Maybe<Scalars['Float']['output']>;
  newStatus?: Maybe<TicketPaymentVerificationDetailsNewStatus>;
  oldReceivedAmount?: Maybe<Scalars['Float']['output']>;
  paymentVerification?: Maybe<PaymentVerificationNode>;
  paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus;
  paymentVerifications: PaymentVerificationNodeConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type TicketPaymentVerificationDetailsNodePaymentVerificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type TicketPaymentVerificationDetailsNodeConnection = {
  __typename?: 'TicketPaymentVerificationDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketPaymentVerificationDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketPaymentVerificationDetailsNodeEdge = {
  __typename?: 'TicketPaymentVerificationDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketPaymentVerificationDetailsNode>;
};

export enum TicketPaymentVerificationDetailsPaymentVerificationStatus {
  NotReceived = 'NOT_RECEIVED',
  Pending = 'PENDING',
  Received = 'RECEIVED',
  ReceivedWithIssues = 'RECEIVED_WITH_ISSUES'
}

export type TicketPositiveFeedbackDetailsNode = Node & {
  __typename?: 'TicketPositiveFeedbackDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketPositiveFeedbackDetailsNodeConnection = {
  __typename?: 'TicketPositiveFeedbackDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketPositiveFeedbackDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketPositiveFeedbackDetailsNodeEdge = {
  __typename?: 'TicketPositiveFeedbackDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketPositiveFeedbackDetailsNode>;
};

export type TicketReferralDetailsNode = Node & {
  __typename?: 'TicketReferralDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketReferralDetailsNodeConnection = {
  __typename?: 'TicketReferralDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketReferralDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketReferralDetailsNodeEdge = {
  __typename?: 'TicketReferralDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketReferralDetailsNode>;
};

export type TicketSensitiveDetailsNode = Node & {
  __typename?: 'TicketSensitiveDetailsNode';
  createdAt: Scalars['DateTime']['output'];
  household?: Maybe<HouseholdNode>;
  id: Scalars['ID']['output'];
  individual?: Maybe<IndividualNode>;
  paymentContentType?: Maybe<ContentTypeObjectType>;
  paymentObjectId?: Maybe<Scalars['UUID']['output']>;
  paymentRecord?: Maybe<PaymentRecordAndPaymentNode>;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketSensitiveDetailsNodeConnection = {
  __typename?: 'TicketSensitiveDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketSensitiveDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketSensitiveDetailsNodeEdge = {
  __typename?: 'TicketSensitiveDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketSensitiveDetailsNode>;
};

export type TicketSystemFlaggingDetailsNode = Node & {
  __typename?: 'TicketSystemFlaggingDetailsNode';
  approveStatus: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  goldenRecordsIndividual: IndividualNode;
  id: Scalars['ID']['output'];
  roleReassignData: Scalars['JSONString']['output'];
  sanctionListIndividual: SanctionListIndividualNode;
  updatedAt: Scalars['DateTime']['output'];
};

export type TicketSystemFlaggingDetailsNodeConnection = {
  __typename?: 'TicketSystemFlaggingDetailsNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<TicketSystemFlaggingDetailsNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type TicketSystemFlaggingDetailsNodeEdge = {
  __typename?: 'TicketSystemFlaggingDetailsNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<TicketSystemFlaggingDetailsNode>;
};

export type UnlockTargetPopulationMutation = {
  __typename?: 'UnlockTargetPopulationMutation';
  targetPopulation?: Maybe<TargetPopulationNode>;
};

export type UpdateAddIndividualIssueTypeExtras = {
  individualData: AddIndividualDataObjectType;
};

export type UpdateFeedbackInput = {
  admin2?: InputMaybe<Scalars['ID']['input']>;
  area?: InputMaybe<Scalars['String']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  consent?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  feedbackId: Scalars['ID']['input'];
  householdLookup?: InputMaybe<Scalars['ID']['input']>;
  individualLookup?: InputMaybe<Scalars['ID']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  language?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
};

export type UpdateFeedbackMutation = {
  __typename?: 'UpdateFeedbackMutation';
  feedback?: Maybe<FeedbackNode>;
};

export type UpdateGrievanceTicketExtrasInput = {
  addIndividualIssueTypeExtras?: InputMaybe<UpdateAddIndividualIssueTypeExtras>;
  category?: InputMaybe<CategoryExtrasInput>;
  householdDataUpdateIssueTypeExtras?: InputMaybe<UpdateHouseholdDataUpdateIssueTypeExtras>;
  individualDataUpdateIssueTypeExtras?: InputMaybe<UpdateIndividualDataUpdateIssueTypeExtras>;
  ticketPaymentVerificationDetailsExtras?: InputMaybe<TicketPaymentVerificationDetailsExtras>;
};

export type UpdateGrievanceTicketInput = {
  admin?: InputMaybe<Scalars['ID']['input']>;
  area?: InputMaybe<Scalars['String']['input']>;
  assignedTo?: InputMaybe<Scalars['ID']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  documentation?: InputMaybe<Array<InputMaybe<GrievanceDocumentInput>>>;
  documentationToDelete?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  documentationToUpdate?: InputMaybe<Array<InputMaybe<GrievanceDocumentUpdateInput>>>;
  extras?: InputMaybe<UpdateGrievanceTicketExtrasInput>;
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
  language?: InputMaybe<Scalars['String']['input']>;
  linkedTickets?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  partner?: InputMaybe<Scalars['Int']['input']>;
  paymentRecord?: InputMaybe<Scalars['ID']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  ticketId: Scalars['ID']['input'];
  urgency?: InputMaybe<Scalars['Int']['input']>;
};

export type UpdateGrievanceTicketMutation = {
  __typename?: 'UpdateGrievanceTicketMutation';
  grievanceTicket?: Maybe<GrievanceTicketNode>;
};

export type UpdateHouseholdDataUpdateIssueTypeExtras = {
  householdData: HouseholdUpdateDataObjectType;
};

export type UpdateIndividualDataUpdateIssueTypeExtras = {
  individualData: IndividualUpdateDataObjectType;
};

export type UpdatePaymentPlanInput = {
  currency?: InputMaybe<Scalars['String']['input']>;
  dispersionEndDate?: InputMaybe<Scalars['Date']['input']>;
  dispersionStartDate?: InputMaybe<Scalars['Date']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  paymentPlanId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['Date']['input']>;
  targetingId?: InputMaybe<Scalars['ID']['input']>;
};

export type UpdatePaymentPlanMutation = {
  __typename?: 'UpdatePaymentPlanMutation';
  paymentPlan?: Maybe<PaymentPlanNode>;
};

export type UpdatePaymentVerificationReceivedAndReceivedAmount = {
  __typename?: 'UpdatePaymentVerificationReceivedAndReceivedAmount';
  paymentVerification?: Maybe<PaymentVerificationNode>;
};

export type UpdatePaymentVerificationStatusAndReceivedAmount = {
  __typename?: 'UpdatePaymentVerificationStatusAndReceivedAmount';
  paymentVerification?: Maybe<PaymentVerificationNode>;
};

export type UpdateProgram = {
  __typename?: 'UpdateProgram';
  program?: Maybe<ProgramNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type UpdateProgramInput = {
  administrativeAreasOfImplementation?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['Decimal']['input']>;
  cashPlus?: InputMaybe<Scalars['Boolean']['input']>;
  dataCollectingTypeCode?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  frequencyOfPayments?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  partners?: InputMaybe<Array<InputMaybe<PartnerProgramInput>>>;
  populationGoal?: InputMaybe<Scalars['Int']['input']>;
  programmeCode?: InputMaybe<Scalars['String']['input']>;
  sector?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateTargetPopulationInput = {
  excludedIds?: InputMaybe<Scalars['String']['input']>;
  exclusionReason?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  programId?: InputMaybe<Scalars['ID']['input']>;
  targetingCriteria?: InputMaybe<TargetingCriteriaObjectType>;
  vulnerabilityScoreMax?: InputMaybe<Scalars['Decimal']['input']>;
  vulnerabilityScoreMin?: InputMaybe<Scalars['Decimal']['input']>;
};

export type UpdateTargetPopulationMutation = {
  __typename?: 'UpdateTargetPopulationMutation';
  targetPopulation?: Maybe<TargetPopulationNode>;
  validationErrors?: Maybe<Scalars['Arg']['output']>;
};

export type UploadImportDataXlsxFileAsync = {
  __typename?: 'UploadImportDataXLSXFileAsync';
  errors?: Maybe<Array<Maybe<XlsxRowErrorNode>>>;
  importData?: Maybe<ImportDataNode>;
};

export type UserBusinessAreaNode = Node & {
  __typename?: 'UserBusinessAreaNode';
  active: Scalars['Boolean']['output'];
  cashplanSet: CashPlanNodeConnection;
  children: UserBusinessAreaNodeConnection;
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  customFields: Scalars['JSONString']['output'];
  dataCollectingTypes: DataCollectingTypeNodeConnection;
  deduplicationBatchDuplicatesAllowed: Scalars['Int']['output'];
  deduplicationBatchDuplicatesPercentage: Scalars['Int']['output'];
  deduplicationDuplicateScore: Scalars['Float']['output'];
  deduplicationGoldenRecordDuplicatesAllowed: Scalars['Int']['output'];
  deduplicationGoldenRecordDuplicatesPercentage: Scalars['Int']['output'];
  deduplicationIgnoreWithdraw: Scalars['Boolean']['output'];
  deduplicationPossibleDuplicateScore: Scalars['Float']['output'];
  enableEmailNotification: Scalars['Boolean']['output'];
  feedbackSet: FeedbackNodeConnection;
  financialserviceproviderSet: FinancialServiceProviderNodeConnection;
  hasDataSharingAgreement: Scalars['Boolean']['output'];
  householdSet: HouseholdNodeConnection;
  id: Scalars['ID']['output'];
  individualSet: IndividualNodeConnection;
  isAccountabilityApplicable?: Maybe<Scalars['Boolean']['output']>;
  isPaymentPlanApplicable: Scalars['Boolean']['output'];
  isSplit: Scalars['Boolean']['output'];
  koboToken?: Maybe<Scalars['String']['output']>;
  koboUrl?: Maybe<Scalars['String']['output']>;
  koboUsername?: Maybe<Scalars['String']['output']>;
  logentrySet: PaymentVerificationLogEntryNodeConnection;
  longName: Scalars['String']['output'];
  messageSet: CommunicationMessageNodeConnection;
  name: Scalars['String']['output'];
  parent?: Maybe<UserBusinessAreaNode>;
  partnerSet: Array<PartnerNodeForProgram>;
  paymentSet: PaymentNodeConnection;
  paymentplanSet: PaymentPlanNodeConnection;
  paymentrecordSet: PaymentRecordNodeConnection;
  permissions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  postponeDeduplication: Scalars['Boolean']['output'];
  programSet: ProgramNodeConnection;
  rapidProHost?: Maybe<Scalars['String']['output']>;
  rapidProMessagesToken?: Maybe<Scalars['String']['output']>;
  rapidProPaymentVerificationToken?: Maybe<Scalars['String']['output']>;
  rapidProSurveyToken?: Maybe<Scalars['String']['output']>;
  regionCode: Scalars['String']['output'];
  regionName: Scalars['String']['output'];
  registrationdataimportSet: RegistrationDataImportNodeConnection;
  reports: ReportNodeConnection;
  ruleSet: SteficonRuleNodeConnection;
  screenBeneficiary: Scalars['Boolean']['output'];
  serviceproviderSet: ServiceProviderNodeConnection;
  slug: Scalars['String']['output'];
  surveySet: SurveyNodeConnection;
  targetpopulationSet: TargetPopulationNodeConnection;
  tickets: GrievanceTicketNodeConnection;
  updatedAt: Scalars['DateTime']['output'];
  userRoles: Array<UserRoleNode>;
};


export type UserBusinessAreaNodeCashplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeDataCollectingTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeFeedbackSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeFinancialserviceproviderSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeHouseholdSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeIndividualSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeLogentrySetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeMessageSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodePaymentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodePaymentplanSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodePaymentrecordSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeProgramSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeRegistrationdataimportSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeRuleSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeServiceproviderSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeSurveySetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserBusinessAreaNodeTargetpopulationSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type UserBusinessAreaNodeTicketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type UserBusinessAreaNodeConnection = {
  __typename?: 'UserBusinessAreaNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<UserBusinessAreaNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type UserBusinessAreaNodeEdge = {
  __typename?: 'UserBusinessAreaNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<UserBusinessAreaNode>;
};

export type UserNode = Node & {
  __typename?: 'UserNode';
  adUuid?: Maybe<Scalars['String']['output']>;
  approvalSet: Array<ApprovalNode>;
  assignedTickets: GrievanceTicketNodeConnection;
  availableForExport: Scalars['Boolean']['output'];
  businessAreas?: Maybe<UserBusinessAreaNodeConnection>;
  changedTargetPopulations: TargetPopulationNodeConnection;
  createdDeliveryMechanisms: DeliveryMechanismNodeConnection;
  createdFinancialServiceProviderXlsxTemplates: FinancialServiceProviderXlsxTemplateNodeConnection;
  createdFinancialServiceProviders: FinancialServiceProviderNodeConnection;
  createdPaymentPlans: PaymentPlanNodeConnection;
  createdTickets: GrievanceTicketNodeConnection;
  customFields: Scalars['JSONString']['output'];
  dateJoined: Scalars['DateTime']['output'];
  doapHash: Scalars['String']['output'];
  documentSet: DocumentNodeConnection;
  email: Scalars['String']['output'];
  feedbackMessages: FeedbackMessageNodeConnection;
  feedbacks: FeedbackNodeConnection;
  finalizedTargetPopulations: TargetPopulationNodeConnection;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  isStaff: Scalars['Boolean']['output'];
  isSuperuser: Scalars['Boolean']['output'];
  jobTitle: Scalars['String']['output'];
  lastDoapSync?: Maybe<Scalars['DateTime']['output']>;
  lastLogin?: Maybe<Scalars['DateTime']['output']>;
  lastModifyDate?: Maybe<Scalars['DateTime']['output']>;
  lastName: Scalars['String']['output'];
  logs: PaymentVerificationLogEntryNodeConnection;
  messages: CommunicationMessageNodeConnection;
  partner?: Maybe<PartnerNodeForProgram>;
  registrationDataImports: RegistrationDataImportNodeConnection;
  reports: ReportNodeConnection;
  sentDeliveryMechanisms: DeliveryMechanismNodeConnection;
  status: UserStatus;
  surveys: SurveyNodeConnection;
  targetPopulations: TargetPopulationNodeConnection;
  ticketNotes: TicketNoteNodeConnection;
  userRoles: Array<UserRoleNode>;
  username: Scalars['String']['output'];
};


export type UserNodeAssignedTicketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeBusinessAreasArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeChangedTargetPopulationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type UserNodeCreatedDeliveryMechanismsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeCreatedFinancialServiceProviderXlsxTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeCreatedFinancialServiceProvidersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeCreatedPaymentPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeCreatedTicketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeDocumentSetArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeFeedbackMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeFeedbacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeFinalizedTargetPopulationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type UserNodeLogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeMessagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeRegistrationDataImportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeReportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeSentDeliveryMechanismsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeSurveysArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type UserNodeTargetPopulationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  createdAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  households?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMax?: InputMaybe<Scalars['Int']['input']>;
  totalIndividualsCountMin?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Gte?: InputMaybe<Scalars['DateTime']['input']>;
  updatedAt_Lte?: InputMaybe<Scalars['DateTime']['input']>;
};


export type UserNodeTicketNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type UserNodeConnection = {
  __typename?: 'UserNodeConnection';
  edgeCount?: Maybe<Scalars['Int']['output']>;
  edges: Array<Maybe<UserNodeEdge>>;
  pageInfo: PageInfo;
  totalCount?: Maybe<Scalars['Int']['output']>;
};

export type UserNodeEdge = {
  __typename?: 'UserNodeEdge';
  cursor: Scalars['String']['output'];
  node?: Maybe<UserNode>;
};

export type UserRoleNode = {
  __typename?: 'UserRoleNode';
  businessArea: UserBusinessAreaNode;
  createdAt: Scalars['DateTime']['output'];
  expiryDate?: Maybe<Scalars['Date']['output']>;
  role: RoleNode;
  updatedAt: Scalars['DateTime']['output'];
};

export enum UserStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE',
  Invited = 'INVITED'
}

export type VolumeByDeliveryMechanismNode = Node & {
  __typename?: 'VolumeByDeliveryMechanismNode';
  deliveryMechanism?: Maybe<DeliveryMechanismNode>;
  id: Scalars['ID']['output'];
  volume?: Maybe<Scalars['Float']['output']>;
  volumeUsd?: Maybe<Scalars['Float']['output']>;
};

export type XlsxErrorNode = {
  __typename?: 'XlsxErrorNode';
  coordinates?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  sheet?: Maybe<Scalars['String']['output']>;
};

export type XlsxRowErrorNode = {
  __typename?: 'XlsxRowErrorNode';
  header?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  rowNumber?: Maybe<Scalars['Int']['output']>;
};

export type _DatasetsNode = {
  __typename?: '_DatasetsNode';
  data?: Maybe<Array<Maybe<Scalars['Float']['output']>>>;
};

export type _DetailedDatasetsNode = {
  __typename?: '_DetailedDatasetsNode';
  data?: Maybe<Array<Maybe<Scalars['Float']['output']>>>;
  label?: Maybe<Scalars['String']['output']>;
};

export type _TableTotalCashTransferredDataNode = {
  __typename?: '_TableTotalCashTransferredDataNode';
  admin2?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  totalCashTransferred?: Maybe<Scalars['Float']['output']>;
  totalHouseholds?: Maybe<Scalars['Int']['output']>;
};

export type GrievanceTicketDetailedFragment = { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, category: number, consent: boolean, createdAt: any, updatedAt: any, description: string, language: string, admin?: string | null, area: string, adminUrl?: string | null, issueType?: number | null, priority?: number | null, urgency?: number | null, comments?: string | null, partner?: { __typename?: 'PartnerType', id: string, name: string } | null, businessArea: { __typename?: 'UserBusinessAreaNode', postponeDeduplication: boolean }, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, pCode?: string | null } | null, assignedTo?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, paymentRecord?: { __typename?: 'PaymentRecordAndPaymentNode', id?: string | null, caId?: string | null, deliveredQuantity?: number | null, entitlementQuantity?: number | null, objType?: string | null, parent?: { __typename?: 'CashPlanAndPaymentPlanNode', id?: string | null, unicefId?: string | null, objType?: string | null } | null, verification?: { __typename?: 'PaymentVerificationNode', id: string } | null } | null, relatedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, linkedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, category: number, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, existingTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, category: number, unicefId?: string | null, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, addIndividualTicketDetails?: { __typename?: 'TicketAddIndividualDetailsNode', id: string, individualData?: any | null, approveStatus: boolean, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null, individualDataUpdateTicketDetails?: { __typename?: 'TicketIndividualDataUpdateDetailsNode', id: string, individualData?: any | null, roleReassignData: any, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null } | null, householdDataUpdateTicketDetails?: { __typename?: 'TicketHouseholdDataUpdateDetailsNode', id: string, householdData?: any | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null } | null, deleteIndividualTicketDetails?: { __typename?: 'TicketDeleteIndividualDetailsNode', id: string, roleReassignData: any, approveStatus: boolean } | null, deleteHouseholdTicketDetails?: { __typename?: 'TicketDeleteHouseholdDetailsNode', id: string, approveStatus: boolean, reasonHousehold?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null, systemFlaggingTicketDetails?: { __typename?: 'TicketSystemFlaggingDetailsNode', id: string, approveStatus: boolean, roleReassignData: any, goldenRecordsIndividual: { __typename?: 'IndividualNode', id: string, fullName: string, birthDate: any, lastRegistrationDate: any, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, documentNumber: string, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> } }, sanctionListIndividual: { __typename?: 'SanctionListIndividualNode', id: string, fullName: string, referenceNumber: string, datesOfBirth: { __typename?: 'SanctionListIndividualDateOfBirthNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDateOfBirthNodeEdge', node?: { __typename?: 'SanctionListIndividualDateOfBirthNode', id: string, date: any } | null } | null> }, documents: { __typename?: 'SanctionListIndividualDocumentNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDocumentNodeEdge', node?: { __typename?: 'SanctionListIndividualDocumentNode', id: string, documentNumber: string, typeOfDocument: string } | null } | null> } } } | null, paymentVerificationTicketDetails?: { __typename?: 'TicketPaymentVerificationDetailsNode', id: string, newStatus?: TicketPaymentVerificationDetailsNewStatus | null, oldReceivedAmount?: number | null, newReceivedAmount?: number | null, approveStatus: boolean, paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus, hasMultiplePaymentVerifications?: boolean | null, paymentVerification?: { __typename?: 'PaymentVerificationNode', id: string, receivedAmount?: number | null } | null, paymentVerifications: { __typename?: 'PaymentVerificationNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationNodeEdge', node?: { __typename?: 'PaymentVerificationNode', id: string } | null } | null> } } | null, needsAdjudicationTicketDetails?: { __typename?: 'TicketNeedsAdjudicationDetailsNode', id: string, hasDuplicatedDocument?: boolean | null, isMultipleDuplicatesVersion: boolean, roleReassignData: any, extraData?: { __typename?: 'TicketNeedsAdjudicationDetailsExtraDataNode', goldenRecords?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null, possibleDuplicate?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null, goldenRecordsIndividual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string, birthDate: any, lastRegistrationDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null }, possibleDuplicate?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, lastRegistrationDate: any, fullName: string, birthDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null, possibleDuplicates?: Array<{ __typename?: 'IndividualNode', id: string, unicefId?: string | null, lastRegistrationDate: any, fullName: string, birthDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null> | null, selectedIndividual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, activeIndividualsCount?: number | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, adminUrl?: string | null, createdAt: any, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unhcrId: string, adminAreaTitle?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null, selectedIndividuals?: Array<{ __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, activeIndividualsCount?: number | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, adminUrl?: string | null, createdAt: any, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unhcrId: string, adminAreaTitle?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null> | null } | null, ticketNotes: { __typename?: 'TicketNoteNodeConnection', edges: Array<{ __typename?: 'TicketNoteNodeEdge', node?: { __typename?: 'TicketNoteNode', id: string, createdAt: any, updatedAt: any, description: string, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null } | null> }, programs?: Array<{ __typename?: 'ProgramNode', name: string, id: string } | null> | null, documentation?: Array<{ __typename?: 'GrievanceDocumentNode', id: string, createdAt: any, updatedAt: any, name?: string | null, fileSize?: number | null, contentType: string, filePath?: string | null, fileName?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null };

export type HouseholdMinimalFragment = { __typename?: 'HouseholdNode', id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, flexFields?: any | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, address: string, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } };

export type HouseholdDetailedFragment = { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } };

export type MergedHouseholdMinimalFragment = { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null, firstRegistrationDate: any, hasDuplicates?: boolean | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string }, admin1?: { __typename?: 'AreaNode', id: string, name: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null };

export type IndividualMinimalFragment = { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null };

export type IndividualDetailedFragment = { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } };

export type MergedIndividualMinimalFragment = { __typename?: 'IndividualNode', id: string, unicefId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: IndividualSex, role?: string | null, relationship?: IndividualRelationship | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, datahubId?: any | null } | null };

export type PaymentRecordDetailsFragment = { __typename?: 'PaymentRecordNode', id: string, status: PaymentRecordStatus, statusDate: any, caId?: string | null, caHashId?: any | null, registrationCaId?: string | null, fullName: string, distributionModality: string, totalPersonsCovered: number, currency: string, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveredQuantityUsd?: number | null, deliveryDate?: any | null, deliveryType?: PaymentRecordDeliveryType | null, entitlementCardIssueDate?: any | null, entitlementCardNumber?: string | null, transactionReferenceId?: string | null, verification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, statusDate?: any | null, receivedAmount?: number | null } | null, household: { __typename?: 'HouseholdNode', id: string, status?: string | null, size?: number | null, unicefId?: string | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null } }, targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string }, parent?: { __typename?: 'CashPlanNode', id: string, caId?: string | null, program: { __typename?: 'ProgramNode', id: string, name: string }, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, verificationChannel: PaymentVerificationPlanVerificationChannel } | null } | null> } | null } | null, serviceProvider: { __typename?: 'ServiceProviderNode', id: string, fullName?: string | null, shortName?: string | null } };

export type RegistrationMinimalFragment = { __typename?: 'RegistrationDataImportNode', id: string, createdAt: any, name: string, status: RegistrationDataImportStatus, erased: boolean, importDate: any, dataSource: RegistrationDataImportDataSource, numberOfHouseholds: number, numberOfIndividuals: number, refuseReason?: string | null, totalHouseholdsCountWithValidPhoneNo?: number | null, adminUrl?: string | null, importedBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, program?: { __typename?: 'ProgramNode', id: string, name: string, startDate: any, endDate: any, status: ProgramStatus } | null };

export type RegistrationDetailedFragment = { __typename?: 'RegistrationDataImportNode', numberOfIndividuals: number, datahubId?: any | null, errorMessage: string, id: string, createdAt: any, name: string, status: RegistrationDataImportStatus, erased: boolean, importDate: any, dataSource: RegistrationDataImportDataSource, numberOfHouseholds: number, refuseReason?: string | null, totalHouseholdsCountWithValidPhoneNo?: number | null, adminUrl?: string | null, batchDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, batchPossibleDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, batchUniqueCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordUniqueCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordPossibleDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, importedBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, program?: { __typename?: 'ProgramNode', id: string, name: string, startDate: any, endDate: any, status: ProgramStatus } | null };

export type ImportedHouseholdMinimalFragment = { __typename?: 'ImportedHouseholdNode', id: string, importId?: string | null, size?: number | null, admin1: string, admin1Title: string, admin2: string, admin2Title: string, flexFields?: any | null, deviceid: string, start?: any | null, koboAssetId: string, rowId?: number | null, firstRegistrationDate: any, lastRegistrationDate: any, hasDuplicates?: boolean | null, fchildHoh?: boolean | null, childHoh?: boolean | null, collectIndividualData: ImportedHouseholdCollectIndividualData, headOfHousehold?: { __typename?: 'ImportedIndividualNode', id: string, fullName: string } | null };

export type ImportedHouseholdDetailedFragment = { __typename?: 'ImportedHouseholdNode', residenceStatus: ImportedHouseholdResidenceStatus, country?: string | null, countryOrigin?: string | null, id: string, importId?: string | null, size?: number | null, admin1: string, admin1Title: string, admin2: string, admin2Title: string, flexFields?: any | null, deviceid: string, start?: any | null, koboAssetId: string, rowId?: number | null, firstRegistrationDate: any, lastRegistrationDate: any, hasDuplicates?: boolean | null, fchildHoh?: boolean | null, childHoh?: boolean | null, collectIndividualData: ImportedHouseholdCollectIndividualData, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null, name: string }, individuals: { __typename?: 'ImportedIndividualNodeConnection', edges: Array<{ __typename?: 'ImportedIndividualNodeEdge', node?: { __typename?: 'ImportedIndividualNode', id: string, importId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: ImportedIndividualSex, role?: string | null, relationship?: string | null, deduplicationBatchStatus?: ImportedIndividualDeduplicationBatchStatus | null, deduplicationGoldenRecordStatus?: ImportedIndividualDeduplicationGoldenRecordStatus | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null } } | null } | null> }, headOfHousehold?: { __typename?: 'ImportedIndividualNode', id: string, fullName: string } | null };

export type ImportedIndividualMinimalFragment = { __typename?: 'ImportedIndividualNode', id: string, importId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: ImportedIndividualSex, role?: string | null, relationship?: string | null, deduplicationBatchStatus?: ImportedIndividualDeduplicationBatchStatus | null, deduplicationGoldenRecordStatus?: ImportedIndividualDeduplicationGoldenRecordStatus | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null } };

export type ImportedIndividualDetailedFragment = { __typename?: 'ImportedIndividualNode', photo: string, givenName: string, familyName: string, middleName: string, estimatedBirthDate?: boolean | null, maritalStatus: ImportedIndividualMaritalStatus, workStatus: string, pregnant?: boolean | null, flexFields?: any | null, observedDisability?: Array<string | null> | null, seeingDisability: string, hearingDisability: string, physicalDisability: string, memoryDisability: string, selfcareDisability: string, commsDisability: string, disability: ImportedIndividualDisability, role?: string | null, relationship?: string | null, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null, preferredLanguage?: string | null, email?: string | null, id: string, importId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: ImportedIndividualSex, deduplicationBatchStatus?: ImportedIndividualDeduplicationBatchStatus | null, deduplicationGoldenRecordStatus?: ImportedIndividualDeduplicationGoldenRecordStatus | null, documents: { __typename?: 'ImportedDocumentNodeConnection', edges: Array<{ __typename?: 'ImportedDocumentNodeEdge', node?: { __typename?: 'ImportedDocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'ImportedDocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'ImportedIndividualIdentityNodeConnection', edges: Array<{ __typename?: 'ImportedIndividualIdentityNodeEdge', node?: { __typename?: 'ImportedIndividualIdentityNode', id: string, documentNumber: string, partner?: string | null, country?: string | null } | null } | null> }, household?: { __typename?: 'ImportedHouseholdNode', id: string, importId?: string | null, admin1: string, admin2: string, address: string } | null, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null, name: string }, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null };

export type TargetPopulationMinimalFragment = { __typename: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, createdAt: any, updatedAt: any, totalHouseholdsCount?: number | null, totalHouseholdsCountWithValidPhoneNo?: number | null, totalIndividualsCount?: number | null, program?: { __typename: 'ProgramNode', id: string, name: string } | null, createdBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null };

export type TargetPopulationDetailedFragment = { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null };

export type CreateFeedbackTicketMutationVariables = Exact<{
  input: CreateFeedbackInput;
}>;


export type CreateFeedbackTicketMutation = { __typename?: 'Mutations', createFeedback?: { __typename?: 'CreateFeedbackMutation', feedback?: { __typename?: 'FeedbackNode', id: string } | null } | null };

export type CreateFeedbackMsgMutationVariables = Exact<{
  input: CreateFeedbackMessageInput;
}>;


export type CreateFeedbackMsgMutation = { __typename?: 'Mutations', createFeedbackMessage?: { __typename?: 'CreateFeedbackMessageMutation', feedbackMessage?: { __typename?: 'FeedbackMessageNode', id: string, createdAt: any, updatedAt: any, description: string, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, username: string, email: string } | null } | null } | null };

export type CreateSurveyAccountabilityMutationVariables = Exact<{
  input: CreateSurveyInput;
}>;


export type CreateSurveyAccountabilityMutation = { __typename?: 'Mutations', createSurvey?: { __typename?: 'CreateSurveyMutation', survey?: { __typename?: 'SurveyNode', id: string } | null } | null };

export type ExportSurveySampleMutationVariables = Exact<{
  surveyId: Scalars['ID']['input'];
}>;


export type ExportSurveySampleMutation = { __typename?: 'Mutations', exportSurveySample?: { __typename?: 'ExportSurveySampleMutationMutation', survey?: { __typename?: 'SurveyNode', id: string } | null } | null };

export type UpdateFeedbackTicketMutationVariables = Exact<{
  input: UpdateFeedbackInput;
}>;


export type UpdateFeedbackTicketMutation = { __typename?: 'Mutations', updateFeedback?: { __typename?: 'UpdateFeedbackMutation', feedback?: { __typename?: 'FeedbackNode', id: string, unicefId?: string | null, issueType: FeedbackIssueType, createdAt: any, updatedAt: any, area: string, language: string, description: string, comments?: string | null, householdLookup?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string } } | null, individualLookup?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null } | null, program?: { __typename?: 'ProgramNode', id: string, name: string } | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, username: string, email: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null, linkedGrievance?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null } | null } | null } | null };

export type CreateAccountabilityCommunicationMessageMutationVariables = Exact<{
  input: CreateAccountabilityCommunicationMessageInput;
}>;


export type CreateAccountabilityCommunicationMessageMutation = { __typename?: 'Mutations', createAccountabilityCommunicationMessage?: { __typename?: 'CreateCommunicationMessageMutation', message?: { __typename?: 'CommunicationMessageNode', id: string } | null } | null };

export type CheckAgainstSanctionListUploadMutationVariables = Exact<{
  file: Scalars['Upload']['input'];
}>;


export type CheckAgainstSanctionListUploadMutation = { __typename?: 'Mutations', checkAgainstSanctionList?: { __typename?: 'CheckAgainstSanctionListMutation', errors?: Array<{ __typename?: 'XlsxRowErrorNode', header?: string | null, message?: string | null, rowNumber?: number | null } | null> | null } | null };

export type ApproveAddIndividualDataChangeMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  approveStatus: Scalars['Boolean']['input'];
}>;


export type ApproveAddIndividualDataChangeMutation = { __typename?: 'Mutations', approveAddIndividual?: { __typename?: 'SimpleApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number } | null } | null };

export type ApproveDeleteHouseholdDataChangeMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  approveStatus: Scalars['Boolean']['input'];
  reasonHhId?: InputMaybe<Scalars['String']['input']>;
}>;


export type ApproveDeleteHouseholdDataChangeMutation = { __typename?: 'Mutations', approveDeleteHousehold?: { __typename?: 'DeleteHouseholdApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number } | null } | null };

export type ApproveDeleteIndividualDataChangeMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  approveStatus: Scalars['Boolean']['input'];
}>;


export type ApproveDeleteIndividualDataChangeMutation = { __typename?: 'Mutations', approveDeleteIndividual?: { __typename?: 'SimpleApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number } | null } | null };

export type ApproveHouseholdDataChangeMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  householdApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  flexFieldsApproveData?: InputMaybe<Scalars['JSONString']['input']>;
}>;


export type ApproveHouseholdDataChangeMutation = { __typename?: 'Mutations', approveHouseholdDataChange?: { __typename?: 'HouseholdDataChangeApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number, householdDataUpdateTicketDetails?: { __typename?: 'TicketHouseholdDataUpdateDetailsNode', id: string, householdData?: any | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null } | null } | null } | null };

export type ApproveIndividualDataChangeMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  individualApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  flexFieldsApproveData?: InputMaybe<Scalars['JSONString']['input']>;
  approvedDocumentsToCreate?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedDocumentsToRemove?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedDocumentsToEdit?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedIdentitiesToCreate?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedIdentitiesToEdit?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedIdentitiesToRemove?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedPaymentChannelsToCreate?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedPaymentChannelsToEdit?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  approvedPaymentChannelsToRemove?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
}>;


export type ApproveIndividualDataChangeMutation = { __typename?: 'Mutations', approveIndividualDataChange?: { __typename?: 'IndividualDataChangeApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number, individualDataUpdateTicketDetails?: { __typename?: 'TicketIndividualDataUpdateDetailsNode', id: string, individualData?: any | null, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null } | null } | null } | null };

export type ApproveNeedsAdjudicationMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  selectedIndividualId?: InputMaybe<Scalars['ID']['input']>;
  selectedIndividualIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
}>;


export type ApproveNeedsAdjudicationMutation = { __typename?: 'Mutations', approveNeedsAdjudication?: { __typename?: 'NeedsAdjudicationApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number } | null } | null };

export type ApprovePaymentDetailsMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  approveStatus: Scalars['Boolean']['input'];
}>;


export type ApprovePaymentDetailsMutation = { __typename?: 'Mutations', approvePaymentDetails?: { __typename?: 'PaymentDetailsApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number, paymentVerificationTicketDetails?: { __typename?: 'TicketPaymentVerificationDetailsNode', id: string, approveStatus: boolean } | null } | null } | null };

export type ApproveSystemFlaggingMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  approveStatus: Scalars['Boolean']['input'];
}>;


export type ApproveSystemFlaggingMutation = { __typename?: 'Mutations', approveSystemFlagging?: { __typename?: 'SimpleApproveMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, status: number } | null } | null };

export type BulkUpdateGrievanceAddNoteMutationVariables = Exact<{
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>;
  note: Scalars['String']['input'];
  businessAreaSlug: Scalars['String']['input'];
}>;


export type BulkUpdateGrievanceAddNoteMutation = { __typename?: 'Mutations', bulkGrievanceAddNote?: { __typename?: 'BulkGrievanceAddNoteMutation', grievanceTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string } | null> | null } | null };

export type BulkUpdateGrievanceAssigneeMutationVariables = Exact<{
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>;
  assignedTo: Scalars['String']['input'];
  businessAreaSlug: Scalars['String']['input'];
}>;


export type BulkUpdateGrievanceAssigneeMutation = { __typename?: 'Mutations', bulkUpdateGrievanceAssignee?: { __typename?: 'BulkUpdateGrievanceTicketsAssigneesMutation', grievanceTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, assignedTo?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null } | null };

export type BulkUpdateGrievancePriorityMutationVariables = Exact<{
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>;
  priority: Scalars['Int']['input'];
  businessAreaSlug: Scalars['String']['input'];
}>;


export type BulkUpdateGrievancePriorityMutation = { __typename?: 'Mutations', bulkUpdateGrievancePriority?: { __typename?: 'BulkUpdateGrievanceTicketsPriorityMutation', grievanceTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, priority?: number | null } | null> | null } | null };

export type BulkUpdateGrievanceUrgencyMutationVariables = Exact<{
  grievanceTicketIds: Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>;
  urgency: Scalars['Int']['input'];
  businessAreaSlug: Scalars['String']['input'];
}>;


export type BulkUpdateGrievanceUrgencyMutation = { __typename?: 'Mutations', bulkUpdateGrievanceUrgency?: { __typename?: 'BulkUpdateGrievanceTicketsUrgencyMutation', grievanceTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, urgency?: number | null } | null> | null } | null };

export type CreateGrievanceMutationVariables = Exact<{
  input: CreateGrievanceTicketInput;
}>;


export type CreateGrievanceMutation = { __typename?: 'Mutations', createGrievanceTicket?: { __typename?: 'CreateGrievanceTicketMutation', grievanceTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, category: number } | null> | null } | null };

export type CreateGrievanceTicketNoteMutationVariables = Exact<{
  noteInput: CreateTicketNoteInput;
}>;


export type CreateGrievanceTicketNoteMutation = { __typename?: 'Mutations', createTicketNote?: { __typename?: 'CreateTicketNoteMutation', grievanceTicketNote?: { __typename?: 'TicketNoteNode', id: string, createdAt: any, updatedAt: any, createdBy?: { __typename?: 'UserNode', firstName: string, lastName: string, username: string, email: string } | null } | null } | null };

export type GrievanceTicketStatusChangeMutationVariables = Exact<{
  grievanceTicketId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GrievanceTicketStatusChangeMutation = { __typename?: 'Mutations', grievanceStatusChange?: { __typename?: 'GrievanceStatusChangeMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, category: number, consent: boolean, createdAt: any, updatedAt: any, description: string, language: string, admin?: string | null, area: string, adminUrl?: string | null, issueType?: number | null, priority?: number | null, urgency?: number | null, comments?: string | null, partner?: { __typename?: 'PartnerType', id: string, name: string } | null, businessArea: { __typename?: 'UserBusinessAreaNode', postponeDeduplication: boolean }, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, pCode?: string | null } | null, assignedTo?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, paymentRecord?: { __typename?: 'PaymentRecordAndPaymentNode', id?: string | null, caId?: string | null, deliveredQuantity?: number | null, entitlementQuantity?: number | null, objType?: string | null, parent?: { __typename?: 'CashPlanAndPaymentPlanNode', id?: string | null, unicefId?: string | null, objType?: string | null } | null, verification?: { __typename?: 'PaymentVerificationNode', id: string } | null } | null, relatedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, linkedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, category: number, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, existingTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, category: number, unicefId?: string | null, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, addIndividualTicketDetails?: { __typename?: 'TicketAddIndividualDetailsNode', id: string, individualData?: any | null, approveStatus: boolean, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null, individualDataUpdateTicketDetails?: { __typename?: 'TicketIndividualDataUpdateDetailsNode', id: string, individualData?: any | null, roleReassignData: any, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null } | null, householdDataUpdateTicketDetails?: { __typename?: 'TicketHouseholdDataUpdateDetailsNode', id: string, householdData?: any | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null } | null, deleteIndividualTicketDetails?: { __typename?: 'TicketDeleteIndividualDetailsNode', id: string, roleReassignData: any, approveStatus: boolean } | null, deleteHouseholdTicketDetails?: { __typename?: 'TicketDeleteHouseholdDetailsNode', id: string, approveStatus: boolean, reasonHousehold?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null, systemFlaggingTicketDetails?: { __typename?: 'TicketSystemFlaggingDetailsNode', id: string, approveStatus: boolean, roleReassignData: any, goldenRecordsIndividual: { __typename?: 'IndividualNode', id: string, fullName: string, birthDate: any, lastRegistrationDate: any, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, documentNumber: string, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> } }, sanctionListIndividual: { __typename?: 'SanctionListIndividualNode', id: string, fullName: string, referenceNumber: string, datesOfBirth: { __typename?: 'SanctionListIndividualDateOfBirthNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDateOfBirthNodeEdge', node?: { __typename?: 'SanctionListIndividualDateOfBirthNode', id: string, date: any } | null } | null> }, documents: { __typename?: 'SanctionListIndividualDocumentNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDocumentNodeEdge', node?: { __typename?: 'SanctionListIndividualDocumentNode', id: string, documentNumber: string, typeOfDocument: string } | null } | null> } } } | null, paymentVerificationTicketDetails?: { __typename?: 'TicketPaymentVerificationDetailsNode', id: string, newStatus?: TicketPaymentVerificationDetailsNewStatus | null, oldReceivedAmount?: number | null, newReceivedAmount?: number | null, approveStatus: boolean, paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus, hasMultiplePaymentVerifications?: boolean | null, paymentVerification?: { __typename?: 'PaymentVerificationNode', id: string, receivedAmount?: number | null } | null, paymentVerifications: { __typename?: 'PaymentVerificationNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationNodeEdge', node?: { __typename?: 'PaymentVerificationNode', id: string } | null } | null> } } | null, needsAdjudicationTicketDetails?: { __typename?: 'TicketNeedsAdjudicationDetailsNode', id: string, hasDuplicatedDocument?: boolean | null, isMultipleDuplicatesVersion: boolean, roleReassignData: any, extraData?: { __typename?: 'TicketNeedsAdjudicationDetailsExtraDataNode', goldenRecords?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null, possibleDuplicate?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null, goldenRecordsIndividual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string, birthDate: any, lastRegistrationDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null }, possibleDuplicate?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, lastRegistrationDate: any, fullName: string, birthDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null, possibleDuplicates?: Array<{ __typename?: 'IndividualNode', id: string, unicefId?: string | null, lastRegistrationDate: any, fullName: string, birthDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null> | null, selectedIndividual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, activeIndividualsCount?: number | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, adminUrl?: string | null, createdAt: any, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unhcrId: string, adminAreaTitle?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null, selectedIndividuals?: Array<{ __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, activeIndividualsCount?: number | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, adminUrl?: string | null, createdAt: any, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unhcrId: string, adminAreaTitle?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null> | null } | null, ticketNotes: { __typename?: 'TicketNoteNodeConnection', edges: Array<{ __typename?: 'TicketNoteNodeEdge', node?: { __typename?: 'TicketNoteNode', id: string, createdAt: any, updatedAt: any, description: string, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null } | null> }, programs?: Array<{ __typename?: 'ProgramNode', name: string, id: string } | null> | null, documentation?: Array<{ __typename?: 'GrievanceDocumentNode', id: string, createdAt: any, updatedAt: any, name?: string | null, fileSize?: number | null, contentType: string, filePath?: string | null, fileName?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null } | null } | null };

export type ReassignRoleGrievanceMutationVariables = Exact<{
  grievanceTicketId: Scalars['ID']['input'];
  householdId: Scalars['ID']['input'];
  individualId: Scalars['ID']['input'];
  newIndividualId?: InputMaybe<Scalars['ID']['input']>;
  role: Scalars['String']['input'];
}>;


export type ReassignRoleGrievanceMutation = { __typename?: 'Mutations', reassignRole?: { __typename?: 'ReassignRoleMutation', household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null, individual?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null } | null } | null };

export type UpdateGrievanceMutationVariables = Exact<{
  input: UpdateGrievanceTicketInput;
}>;


export type UpdateGrievanceMutation = { __typename?: 'Mutations', updateGrievanceTicket?: { __typename?: 'UpdateGrievanceTicketMutation', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string } | null } | null };

export type ActionPpMutationVariables = Exact<{
  input: ActionPaymentPlanInput;
}>;


export type ActionPpMutation = { __typename?: 'Mutations', actionPaymentPlanMutation?: { __typename?: 'ActionPaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus } | null } | null };

export type AssignFspToDeliveryMechMutationVariables = Exact<{
  input: AssignFspToDeliveryMechanismInput;
}>;


export type AssignFspToDeliveryMechMutation = { __typename?: 'Mutations', assignFspToDeliveryMechanism?: { __typename?: 'AssignFspToDeliveryMechanismMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, deliveryMechanisms?: Array<{ __typename?: 'DeliveryMechanismNode', id: string, name?: string | null, fsp?: { __typename?: 'FinancialServiceProviderNode', id: string, name: string } | null } | null> | null } | null } | null };

export type ChooseDeliveryMechForPaymentPlanMutationVariables = Exact<{
  input: ChooseDeliveryMechanismsForPaymentPlanInput;
}>;


export type ChooseDeliveryMechForPaymentPlanMutation = { __typename?: 'Mutations', chooseDeliveryMechanismsForPaymentPlan?: { __typename?: 'ChooseDeliveryMechanismsForPaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, deliveryMechanisms?: Array<{ __typename?: 'DeliveryMechanismNode', id: string, name?: string | null, fsp?: { __typename?: 'FinancialServiceProviderNode', id: string, name: string } | null } | null> | null } | null } | null };

export type CreateFollowUpPpMutationVariables = Exact<{
  dispersionStartDate: Scalars['Date']['input'];
  dispersionEndDate: Scalars['Date']['input'];
  paymentPlanId: Scalars['ID']['input'];
}>;


export type CreateFollowUpPpMutation = { __typename?: 'Mutations', createFollowUpPaymentPlan?: { __typename?: 'CreateFollowUpPaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, unicefId?: string | null } | null } | null };

export type CreatePpMutationVariables = Exact<{
  input: CreatePaymentPlanInput;
}>;


export type CreatePpMutation = { __typename?: 'Mutations', createPaymentPlan?: { __typename?: 'CreatePaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string } | null } | null };

export type DeletePpMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
}>;


export type DeletePpMutation = { __typename?: 'Mutations', deletePaymentPlan?: { __typename?: 'DeletePaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus } | null } | null };

export type UpdatePpMutationVariables = Exact<{
  input: UpdatePaymentPlanInput;
}>;


export type UpdatePpMutation = { __typename?: 'Mutations', updatePaymentPlan?: { __typename?: 'UpdatePaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string } | null } | null };

export type ExcludeHouseholdsPpMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
  excludedHouseholdsIds: Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>;
  exclusionReason?: InputMaybe<Scalars['String']['input']>;
}>;


export type ExcludeHouseholdsPpMutation = { __typename?: 'Mutations', excludeHouseholds?: { __typename?: 'ExcludeHouseholdsMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus, backgroundActionStatus?: PaymentPlanBackgroundActionStatus | null, excludeHouseholdError: string, exclusionReason: string, excludedHouseholds?: Array<{ __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null> | null } | null } | null };

export type ExportPdfPpSummaryMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
}>;


export type ExportPdfPpSummaryMutation = { __typename?: 'Mutations', exportPdfPaymentPlanSummary?: { __typename?: 'ExportPDFPaymentPlanSummaryMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string } | null } | null };

export type ExportXlsxPpListMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
}>;


export type ExportXlsxPpListMutation = { __typename?: 'Mutations', exportXlsxPaymentPlanPaymentList?: { __typename?: 'ExportXLSXPaymentPlanPaymentListMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus, backgroundActionStatus?: PaymentPlanBackgroundActionStatus | null } | null } | null };

export type ExportXlsxPpListPerFspMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
}>;


export type ExportXlsxPpListPerFspMutation = { __typename?: 'Mutations', exportXlsxPaymentPlanPaymentListPerFsp?: { __typename?: 'ExportXLSXPaymentPlanPaymentListPerFSPMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus, backgroundActionStatus?: PaymentPlanBackgroundActionStatus | null } | null } | null };

export type ImportXlsxPpListMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
  file: Scalars['Upload']['input'];
}>;


export type ImportXlsxPpListMutation = { __typename?: 'Mutations', importXlsxPaymentPlanPaymentList?: { __typename?: 'ImportXLSXPaymentPlanPaymentListMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus } | null, errors?: Array<{ __typename?: 'XlsxErrorNode', sheet?: string | null, coordinates?: string | null, message?: string | null } | null> | null } | null };

export type ImportXlsxPpListPerFspMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
  file: Scalars['Upload']['input'];
}>;


export type ImportXlsxPpListPerFspMutation = { __typename?: 'Mutations', importXlsxPaymentPlanPaymentListPerFsp?: { __typename?: 'ImportXLSXPaymentPlanPaymentListPerFSPMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus } | null, errors?: Array<{ __typename?: 'XlsxErrorNode', sheet?: string | null, coordinates?: string | null, message?: string | null } | null> | null } | null };

export type MarkPayAsFailedMutationVariables = Exact<{
  paymentId: Scalars['ID']['input'];
}>;


export type MarkPayAsFailedMutation = { __typename?: 'Mutations', markPaymentAsFailed?: { __typename?: 'MarkPaymentAsFailedMutation', payment?: { __typename?: 'PaymentNode', id: string, unicefId?: string | null, status: PaymentStatus, statusDate: any, deliveredQuantity?: number | null, deliveryDate?: any | null } | null } | null };

export type RevertMarkPayAsFailedMutationVariables = Exact<{
  paymentId: Scalars['ID']['input'];
  deliveredQuantity: Scalars['Decimal']['input'];
  deliveryDate: Scalars['Date']['input'];
}>;


export type RevertMarkPayAsFailedMutation = { __typename?: 'Mutations', revertMarkPaymentAsFailed?: { __typename?: 'RevertMarkPaymentAsFailedMutation', payment?: { __typename?: 'PaymentNode', id: string, unicefId?: string | null, status: PaymentStatus, statusDate: any, deliveredQuantity?: number | null, deliveryDate?: any | null } | null } | null };

export type SetSteficonRuleOnPpListMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
  steficonRuleId: Scalars['ID']['input'];
}>;


export type SetSteficonRuleOnPpListMutation = { __typename?: 'Mutations', setSteficonRuleOnPaymentPlanPaymentList?: { __typename?: 'SetSteficonRuleOnPaymentPlanPaymentListMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, steficonRule?: { __typename?: 'RuleCommitNode', id: string, rule?: { __typename?: 'SteficonRuleNode', id: string, name: string } | null } | null } | null } | null };

export type ActivatePaymentVerificationPlanMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
}>;


export type ActivatePaymentVerificationPlanMutation = { __typename?: 'Mutations', activatePaymentVerificationPlan?: { __typename?: 'ActivatePaymentVerificationPlan', validationErrors?: any | null, paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, activationDate?: any | null } | null } | null> } | null, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, status: PaymentVerificationSummaryStatus, activationDate?: any | null } | null } | null } | null };

export type CreatePaymentVerificationPlanMutationVariables = Exact<{
  input: CreatePaymentVerificationInput;
  version?: InputMaybe<Scalars['BigInt']['input']>;
}>;


export type CreatePaymentVerificationPlanMutation = { __typename?: 'Mutations', createPaymentVerificationPlan?: { __typename?: 'CreateVerificationPlanMutation', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null } | null } | null };

export type DeletePaymentVerificationPlanMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
}>;


export type DeletePaymentVerificationPlanMutation = { __typename?: 'Mutations', deletePaymentVerificationPlan?: { __typename?: 'DeletePaymentVerificationPlan', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, sampleSize?: number | null, receivedCount?: number | null, notReceivedCount?: number | null, respondedCount?: number | null, receivedWithProblemsCount?: number | null, activationDate?: any | null } | null } | null> } | null, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, status: PaymentVerificationSummaryStatus } | null } | null } | null };

export type DiscardPaymentVerificationPlanMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
}>;


export type DiscardPaymentVerificationPlanMutation = { __typename?: 'Mutations', discardPaymentVerificationPlan?: { __typename?: 'DiscardPaymentVerificationPlan', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, sampleSize?: number | null, receivedCount?: number | null, notReceivedCount?: number | null, respondedCount?: number | null, receivedWithProblemsCount?: number | null, activationDate?: any | null } | null } | null> } | null, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, status: PaymentVerificationSummaryStatus } | null } | null } | null };

export type EditPaymentVerificationPlanMutationVariables = Exact<{
  input: EditPaymentVerificationInput;
}>;


export type EditPaymentVerificationPlanMutation = { __typename?: 'Mutations', editPaymentVerificationPlan?: { __typename?: 'EditPaymentVerificationMutation', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null } | null } | null };

export type ExportXlsxPaymentVerificationPlanFileMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
}>;


export type ExportXlsxPaymentVerificationPlanFileMutation = { __typename?: 'Mutations', exportXlsxPaymentVerificationPlanFile?: { __typename?: 'ExportXlsxPaymentVerificationPlanFile', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null } | null } | null };

export type FinishPaymentVerificationPlanMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
}>;


export type FinishPaymentVerificationPlanMutation = { __typename?: 'Mutations', finishPaymentVerificationPlan?: { __typename?: 'FinishPaymentVerificationPlan', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, completionDate?: any | null } | null } | null> } | null, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, status: PaymentVerificationSummaryStatus } | null } | null } | null };

export type ImportXlsxPaymentVerificationPlanFileMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
  file: Scalars['Upload']['input'];
}>;


export type ImportXlsxPaymentVerificationPlanFileMutation = { __typename?: 'Mutations', importXlsxPaymentVerificationPlanFile?: { __typename?: 'ImportXlsxPaymentVerificationPlanFile', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null } | null, errors?: Array<{ __typename?: 'XlsxErrorNode', sheet?: string | null, coordinates?: string | null, message?: string | null } | null> | null } | null };

export type InvalidPaymentVerificationPlanMutationVariables = Exact<{
  paymentVerificationPlanId: Scalars['ID']['input'];
}>;


export type InvalidPaymentVerificationPlanMutation = { __typename?: 'Mutations', invalidPaymentVerificationPlan?: { __typename?: 'InvalidPaymentVerificationPlan', paymentPlan?: { __typename?: 'GenericPaymentPlanNode', id?: string | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, xlsxFileExporting: boolean, hasXlsxFile?: boolean | null, xlsxFileWasDownloaded?: boolean | null, xlsxFileImported: boolean } | null } | null> } | null } | null } | null };

export type MarkPrAsFailedMutationVariables = Exact<{
  paymentRecordId: Scalars['ID']['input'];
}>;


export type MarkPrAsFailedMutation = { __typename?: 'Mutations', markPaymentRecordAsFailed?: { __typename?: 'MarkPaymentRecordAsFailedMutation', paymentRecord?: { __typename?: 'PaymentRecordNode', id: string, status: PaymentRecordStatus, statusDate: any, caId?: string | null, caHashId?: any | null, registrationCaId?: string | null, fullName: string, distributionModality: string, totalPersonsCovered: number, currency: string, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveredQuantityUsd?: number | null, deliveryDate?: any | null, deliveryType?: PaymentRecordDeliveryType | null, entitlementCardIssueDate?: any | null, entitlementCardNumber?: string | null, transactionReferenceId?: string | null, verification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, statusDate?: any | null, receivedAmount?: number | null } | null, household: { __typename?: 'HouseholdNode', id: string, status?: string | null, size?: number | null, unicefId?: string | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null } }, targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string }, parent?: { __typename?: 'CashPlanNode', id: string, caId?: string | null, program: { __typename?: 'ProgramNode', id: string, name: string }, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, verificationChannel: PaymentVerificationPlanVerificationChannel } | null } | null> } | null } | null, serviceProvider: { __typename?: 'ServiceProviderNode', id: string, fullName?: string | null, shortName?: string | null } } | null } | null };

export type RevertMarkPrAsFailedMutationVariables = Exact<{
  paymentRecordId: Scalars['ID']['input'];
  deliveredQuantity: Scalars['Decimal']['input'];
  deliveryDate: Scalars['Date']['input'];
}>;


export type RevertMarkPrAsFailedMutation = { __typename?: 'Mutations', revertMarkPaymentRecordAsFailed?: { __typename?: 'RevertMarkPaymentRecordAsFailedMutation', paymentRecord?: { __typename?: 'PaymentRecordNode', id: string, status: PaymentRecordStatus, statusDate: any, caId?: string | null, caHashId?: any | null, registrationCaId?: string | null, fullName: string, distributionModality: string, totalPersonsCovered: number, currency: string, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveredQuantityUsd?: number | null, deliveryDate?: any | null, deliveryType?: PaymentRecordDeliveryType | null, entitlementCardIssueDate?: any | null, entitlementCardNumber?: string | null, transactionReferenceId?: string | null, verification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, statusDate?: any | null, receivedAmount?: number | null } | null, household: { __typename?: 'HouseholdNode', id: string, status?: string | null, size?: number | null, unicefId?: string | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null } }, targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string }, parent?: { __typename?: 'CashPlanNode', id: string, caId?: string | null, program: { __typename?: 'ProgramNode', id: string, name: string }, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, verificationChannel: PaymentVerificationPlanVerificationChannel } | null } | null> } | null } | null, serviceProvider: { __typename?: 'ServiceProviderNode', id: string, fullName?: string | null, shortName?: string | null } } | null } | null };

export type SplitPpMutationVariables = Exact<{
  paymentPlanId: Scalars['ID']['input'];
  splitType: Scalars['String']['input'];
  paymentsNo: Scalars['Int']['input'];
}>;


export type SplitPpMutation = { __typename?: 'Mutations', splitPaymentPlan?: { __typename?: 'SplitPaymentPlanMutation', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string } | null } | null };

export type UpdatePaymentVerificationReceivedAndReceivedAmountMutationVariables = Exact<{
  paymentVerificationId: Scalars['ID']['input'];
  receivedAmount: Scalars['Decimal']['input'];
  received: Scalars['Boolean']['input'];
}>;


export type UpdatePaymentVerificationReceivedAndReceivedAmountMutation = { __typename?: 'Mutations', updatePaymentVerificationReceivedAndReceivedAmount?: { __typename?: 'UpdatePaymentVerificationReceivedAndReceivedAmount', paymentVerification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, receivedAmount?: number | null, paymentVerificationPlan: { __typename?: 'PaymentVerificationPlanNode', id: string, receivedCount?: number | null, notReceivedCount?: number | null, respondedCount?: number | null, receivedWithProblemsCount?: number | null } } | null } | null };

export type UpdatePaymentVerificationStatusAndReceivedAmountMutationVariables = Exact<{
  paymentVerificationId: Scalars['ID']['input'];
  receivedAmount: Scalars['Decimal']['input'];
  status?: InputMaybe<PaymentVerificationStatusForUpdate>;
}>;


export type UpdatePaymentVerificationStatusAndReceivedAmountMutation = { __typename?: 'Mutations', updatePaymentVerificationStatusAndReceivedAmount?: { __typename?: 'UpdatePaymentVerificationStatusAndReceivedAmount', paymentVerification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, receivedAmount?: number | null } | null } | null };

export type CopyProgramMutationVariables = Exact<{
  programData: CopyProgramInput;
}>;


export type CopyProgramMutation = { __typename?: 'Mutations', copyProgram?: { __typename?: 'CopyProgram', validationErrors?: any | null, program?: { __typename?: 'ProgramNode', id: string } | null } | null };

export type CreateProgramMutationVariables = Exact<{
  programData: CreateProgramInput;
}>;


export type CreateProgramMutation = { __typename?: 'Mutations', createProgram?: { __typename?: 'CreateProgram', validationErrors?: any | null, program?: { __typename?: 'ProgramNode', id: string, name: string, programmeCode?: string | null, status: ProgramStatus, startDate: any, endDate: any, caId?: string | null, budget?: any | null, description: string, frequencyOfPayments: ProgramFrequencyOfPayments, sector: ProgramSector, scope?: ProgramScope | null, cashPlus: boolean, populationGoal: number, dataCollectingType?: { __typename?: 'DataCollectingTypeNode', id: string, code: string, label: string, active: boolean, individualFiltersAvailable: boolean } | null } | null } | null };

export type DeleteProgramMutationVariables = Exact<{
  programId: Scalars['String']['input'];
}>;


export type DeleteProgramMutation = { __typename?: 'Mutations', deleteProgram?: { __typename?: 'DeleteProgram', ok?: boolean | null } | null };

export type UpdateProgramMutationVariables = Exact<{
  programData: UpdateProgramInput;
  version: Scalars['BigInt']['input'];
}>;


export type UpdateProgramMutation = { __typename?: 'Mutations', updateProgram?: { __typename?: 'UpdateProgram', validationErrors?: any | null, program?: { __typename?: 'ProgramNode', id: string, name: string, programmeCode?: string | null, startDate: any, endDate: any, status: ProgramStatus, caId?: string | null, caHashId?: string | null, description: string, budget?: any | null, frequencyOfPayments: ProgramFrequencyOfPayments, cashPlus: boolean, populationGoal: number, scope?: ProgramScope | null, sector: ProgramSector, totalNumberOfHouseholds?: number | null, totalNumberOfHouseholdsWithTpInProgram?: number | null, administrativeAreasOfImplementation: string, version: any, dataCollectingType?: { __typename?: 'DataCollectingTypeNode', id: string, code: string, label: string, active: boolean, individualFiltersAvailable: boolean, householdFiltersAvailable: boolean, description: string } | null, partners?: Array<{ __typename?: 'PartnerNodeForProgram', id?: string | null, name?: string | null, areaAccess?: string | null, adminAreas?: Array<{ __typename?: 'AreaGroupNode', ids?: Array<string | null> | null, level?: number | null, totalCount?: number | null } | null> | null } | null> | null } | null } | null };

export type CreateRegistrationKoboImportMutationVariables = Exact<{
  registrationDataImportData: RegistrationKoboImportMutationInput;
}>;


export type CreateRegistrationKoboImportMutation = { __typename?: 'Mutations', registrationKoboImport?: { __typename?: 'RegistrationKoboImportMutation', validationErrors?: any | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, name: string, dataSource: RegistrationDataImportDataSource, datahubId?: any | null, screenBeneficiary: boolean } | null } | null };

export type CreateRegistrationXlsxImportMutationVariables = Exact<{
  registrationDataImportData: RegistrationXlsxImportMutationInput;
}>;


export type CreateRegistrationXlsxImportMutation = { __typename?: 'Mutations', registrationXlsxImport?: { __typename?: 'RegistrationXlsxImportMutation', validationErrors?: any | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, name: string, dataSource: RegistrationDataImportDataSource, datahubId?: any | null, screenBeneficiary: boolean } | null } | null };

export type EraseRdiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type EraseRdiMutation = { __typename?: 'Mutations', eraseRegistrationDataImport?: { __typename?: 'EraseRegistrationDataImportMutation', registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, status: RegistrationDataImportStatus, erased: boolean } | null } | null };

export type MergeRdiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type MergeRdiMutation = { __typename?: 'Mutations', mergeRegistrationDataImport?: { __typename?: 'MergeRegistrationDataImportMutation', registrationDataImport?: { __typename?: 'RegistrationDataImportNode', numberOfIndividuals: number, datahubId?: any | null, errorMessage: string, id: string, createdAt: any, name: string, status: RegistrationDataImportStatus, erased: boolean, importDate: any, dataSource: RegistrationDataImportDataSource, numberOfHouseholds: number, refuseReason?: string | null, totalHouseholdsCountWithValidPhoneNo?: number | null, adminUrl?: string | null, batchDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, batchPossibleDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, batchUniqueCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordUniqueCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordPossibleDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, importedBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, program?: { __typename?: 'ProgramNode', id: string, name: string, startDate: any, endDate: any, status: ProgramStatus } | null } | null } | null };

export type RefuseRdiMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  refuseReason?: InputMaybe<Scalars['String']['input']>;
}>;


export type RefuseRdiMutation = { __typename?: 'Mutations', refuseRegistrationDataImport?: { __typename?: 'RefuseRegistrationDataImportMutation', registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, status: RegistrationDataImportStatus, refuseReason?: string | null } | null } | null };

export type RerunDedupeMutationVariables = Exact<{
  registrationDataImportDatahubId: Scalars['ID']['input'];
}>;


export type RerunDedupeMutation = { __typename?: 'Mutations', rerunDedupe?: { __typename?: 'RegistrationDeduplicationMutation', ok?: boolean | null } | null };

export type SaveKoboImportDataMutationVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
  projectId: Scalars['Upload']['input'];
  onlyActiveSubmissions: Scalars['Boolean']['input'];
}>;


export type SaveKoboImportDataMutation = { __typename?: 'Mutations', saveKoboImportDataAsync?: { __typename?: 'SaveKoboProjectImportDataAsync', importData?: { __typename?: 'KoboImportDataNode', id: string } | null } | null };

export type SaveKoboImportDataAsyncMutationVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
  koboAssetId: Scalars['Upload']['input'];
  onlyActiveSubmissions: Scalars['Boolean']['input'];
}>;


export type SaveKoboImportDataAsyncMutation = { __typename?: 'Mutations', saveKoboImportDataAsync?: { __typename?: 'SaveKoboProjectImportDataAsync', importData?: { __typename?: 'KoboImportDataNode', id: string, status: ImportDataStatus } | null } | null };

export type UploadImportDataXlsxFileAsyncMutationVariables = Exact<{
  file: Scalars['Upload']['input'];
  businessAreaSlug: Scalars['String']['input'];
}>;


export type UploadImportDataXlsxFileAsyncMutation = { __typename?: 'Mutations', uploadImportDataXlsxFileAsync?: { __typename?: 'UploadImportDataXLSXFileAsync', errors?: Array<{ __typename?: 'XlsxRowErrorNode', header?: string | null, message?: string | null, rowNumber?: number | null } | null> | null, importData?: { __typename?: 'ImportDataNode', id: string, numberOfIndividuals?: number | null, numberOfHouseholds?: number | null, registrationDataImport?: { __typename?: 'RegistrationDataImportDatahubNode', id: string } | null } | null } | null };

export type CreateDashboardReportMutationVariables = Exact<{
  reportData: CreateDashboardReportInput;
}>;


export type CreateDashboardReportMutation = { __typename?: 'Mutations', createDashboardReport?: { __typename?: 'CreateDashboardReport', success?: boolean | null } | null };

export type CreateReportMutationVariables = Exact<{
  reportData: CreateReportInput;
}>;


export type CreateReportMutation = { __typename?: 'Mutations', createReport?: { __typename?: 'CreateReport', report?: { __typename?: 'ReportNode', id: string } | null } | null };

export type RestartCreateReportMutationVariables = Exact<{
  reportData: RestartCreateReportInput;
}>;


export type RestartCreateReportMutation = { __typename?: 'Mutations', restartCreateReport?: { __typename?: 'RestartCreateReport', report?: { __typename?: 'ReportNode', id: string, status: number, reportType: number, createdAt: any, dateFrom: any, dateTo: any, fileUrl?: string | null, createdBy: { __typename?: 'UserNode', firstName: string, lastName: string }, adminArea: { __typename?: 'AreaNodeConnection', edges: Array<{ __typename?: 'AreaNodeEdge', node?: { __typename?: 'AreaNode', name: string } | null } | null> }, program?: { __typename?: 'ProgramNode', name: string } | null } | null } | null };

export type CreateTpMutationVariables = Exact<{
  input: CreateTargetPopulationInput;
}>;


export type CreateTpMutation = { __typename?: 'Mutations', createTargetPopulation?: { __typename?: 'CreateTargetPopulationMutation', validationErrors?: any | null, targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, status: TargetPopulationStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null } | null } | null };

export type DeleteTargetPopulationMutationVariables = Exact<{
  input: DeleteTargetPopulationMutationInput;
}>;


export type DeleteTargetPopulationMutation = { __typename?: 'Mutations', deleteTargetPopulation?: { __typename?: 'DeleteTargetPopulationMutationPayload', clientMutationId?: string | null } | null };

export type CopyTargetPopulationMutationVariables = Exact<{
  input: CopyTargetPopulationMutationInput;
}>;


export type CopyTargetPopulationMutation = { __typename?: 'Mutations', copyTargetPopulation?: { __typename?: 'CopyTargetPopulationMutationPayload', clientMutationId?: string | null, validationErrors?: any | null, targetPopulation?: { __typename?: 'TargetPopulationNode', id: string } | null } | null };

export type FinalizeTpMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type FinalizeTpMutation = { __typename?: 'Mutations', finalizeTargetPopulation?: { __typename?: 'FinalizeTargetPopulationMutation', targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null } | null } | null };

export type LockTpMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type LockTpMutation = { __typename?: 'Mutations', lockTargetPopulation?: { __typename?: 'LockTargetPopulationMutation', targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null } | null } | null };

export type RebuildTpMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RebuildTpMutation = { __typename?: 'Mutations', targetPopulationRebuild?: { __typename?: 'RebuildTargetPopulationMutation', targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null } | null } | null };

export type SetSteficonRuleOnTargetPopulationMutationVariables = Exact<{
  input: SetSteficonRuleOnTargetPopulationMutationInput;
}>;


export type SetSteficonRuleOnTargetPopulationMutation = { __typename?: 'Mutations', setSteficonRuleOnTargetPopulation?: { __typename?: 'SetSteficonRuleOnTargetPopulationMutationPayload', targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null } | null } | null };

export type UnlockTpMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type UnlockTpMutation = { __typename?: 'Mutations', unlockTargetPopulation?: { __typename?: 'UnlockTargetPopulationMutation', targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null } | null } | null };

export type UpdateTpMutationVariables = Exact<{
  input: UpdateTargetPopulationInput;
}>;


export type UpdateTpMutation = { __typename?: 'Mutations', updateTargetPopulation?: { __typename?: 'UpdateTargetPopulationMutation', validationErrors?: any | null, targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, status: TargetPopulationStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null } | null } | null };

export type AccountabilityCommunicationMessageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type AccountabilityCommunicationMessageQuery = { __typename?: 'Query', accountabilityCommunicationMessage?: { __typename?: 'CommunicationMessageNode', id: string, unicefId?: string | null, adminUrl?: string | null, createdAt: any, title: string, body: string, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string } | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, name: string } | null } | null };

export type AccountabilityCommunicationMessageSampleSizeQueryVariables = Exact<{
  input: GetAccountabilityCommunicationMessageSampleSizeInput;
}>;


export type AccountabilityCommunicationMessageSampleSizeQuery = { __typename?: 'Query', accountabilityCommunicationMessageSampleSize?: { __typename?: 'GetCommunicationMessageSampleSizeNode', numberOfRecipients?: number | null, sampleSize?: number | null } | null };

export type AccountabilitySampleSizeQueryVariables = Exact<{
  input: AccountabilitySampleSizeInput;
}>;


export type AccountabilitySampleSizeQuery = { __typename?: 'Query', accountabilitySampleSize?: { __typename?: 'AccountabilitySampleSizeNode', numberOfRecipients?: number | null, sampleSize?: number | null } | null };

export type AllAccountabilityCommunicationMessageRecipientsQueryVariables = Exact<{
  offset?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  messageId: Scalars['String']['input'];
  recipientId?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  phoneNo?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllAccountabilityCommunicationMessageRecipientsQuery = { __typename?: 'Query', allAccountabilityCommunicationMessageRecipients?: { __typename?: 'CommunicationMessageRecipientMapNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'CommunicationMessageRecipientMapNodeEdge', cursor: string, node?: { __typename?: 'CommunicationMessageRecipientMapNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null, status?: string | null, residenceStatus?: string | null, lastRegistrationDate: any, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null } } | null } | null> } | null };

export type AllAccountabilityCommunicationMessagesQueryVariables = Exact<{
  offset?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  numberOfRecipients?: InputMaybe<Scalars['Int']['input']>;
  numberOfRecipients_Gte?: InputMaybe<Scalars['Int']['input']>;
  numberOfRecipients_Lte?: InputMaybe<Scalars['Int']['input']>;
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  samplingType?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllAccountabilityCommunicationMessagesQuery = { __typename?: 'Query', allAccountabilityCommunicationMessages?: { __typename?: 'CommunicationMessageNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'CommunicationMessageNodeEdge', cursor: string, node?: { __typename?: 'CommunicationMessageNode', id: string, unicefId?: string | null, title: string, numberOfRecipients: number, createdAt: any, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null } | null> } | null };

export type AllAdminAreasQueryVariables = Exact<{
  name?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  parentId?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllAdminAreasQuery = { __typename?: 'Query', allAdminAreas?: { __typename?: 'AreaNodeConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'AreaNodeEdge', node?: { __typename?: 'AreaNode', id: string, name: string, pCode?: string | null } | null } | null> } | null };

export type AllAreasTreeQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
}>;


export type AllAreasTreeQuery = { __typename?: 'Query', allAreasTree?: Array<{ __typename?: 'AreaTreeNode', id?: string | null, pCode?: string | null, name?: string | null, level?: number | null, areas?: Array<{ __typename?: 'AreaTreeNode', id?: string | null, name?: string | null, level?: number | null, pCode?: string | null, areas?: Array<{ __typename?: 'AreaTreeNode', id?: string | null, name?: string | null, pCode?: string | null, areas?: Array<{ __typename?: 'AreaTreeNode', id?: string | null, name?: string | null, pCode?: string | null } | null> | null } | null> | null } | null> | null } | null> | null };

export type AllBusinessAreasQueryVariables = Exact<{
  slug?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllBusinessAreasQuery = { __typename?: 'Query', allBusinessAreas?: { __typename?: 'BusinessAreaNodeConnection', pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'BusinessAreaNodeEdge', node?: { __typename?: 'BusinessAreaNode', id: string, name: string, slug: string } | null } | null> } | null };

export type AllLogEntriesQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
  objectId?: InputMaybe<Scalars['UUID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  module?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllLogEntriesQuery = { __typename?: 'Query', allLogEntries?: { __typename?: 'LogEntryNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'LogEntryNodeEdge', cursor: string, node?: { __typename?: 'LogEntryNode', id: string, action: LogEntryAction, changes?: any | null, objectRepr: string, objectId?: any | null, timestamp?: any | null, isUserGenerated?: boolean | null, contentType?: { __typename?: 'ContentTypeObjectType', id: string, appLabel: string, model: string, name?: string | null } | null, user?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string } | null } | null } | null> } | null, logEntryActionChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllSanctionListIndividualsQueryVariables = Exact<{
  referenceNumber: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  fullNameContains?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllSanctionListIndividualsQuery = { __typename?: 'Query', allSanctionListIndividuals?: { __typename?: 'SanctionListIndividualNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'SanctionListIndividualNodeEdge', cursor: string, node?: { __typename?: 'SanctionListIndividualNode', id: string, referenceNumber: string, fullName: string, listedOn: any, documents: { __typename?: 'SanctionListIndividualDocumentNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDocumentNodeEdge', node?: { __typename?: 'SanctionListIndividualDocumentNode', id: string, documentNumber: string, typeOfDocument: string, issuingCountry?: string | null } | null } | null> }, aliasNames: { __typename?: 'SanctionListIndividualAliasNameNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualAliasNameNodeEdge', node?: { __typename?: 'SanctionListIndividualAliasNameNode', id: string, name: string } | null } | null> }, datesOfBirth: { __typename?: 'SanctionListIndividualDateOfBirthNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDateOfBirthNodeEdge', node?: { __typename?: 'SanctionListIndividualDateOfBirthNode', id: string, date: any } | null } | null> } } | null } | null> } | null };

export type AllUsersQueryVariables = Exact<{
  search?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  partner?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllUsersQuery = { __typename?: 'Query', allUsers?: { __typename?: 'UserNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'UserNodeEdge', cursor: string, node?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, username: string, email: string, isActive: boolean, lastLogin?: any | null, status: UserStatus, partner?: { __typename?: 'PartnerNodeForProgram', name?: string | null } | null, userRoles: Array<{ __typename?: 'UserRoleNode', businessArea: { __typename?: 'UserBusinessAreaNode', name: string }, role: { __typename?: 'RoleNode', name: string, permissions?: Array<string> | null } }> } | null } | null> } | null };

export type AllUsersForFiltersQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  isTicketCreator?: InputMaybe<Scalars['Boolean']['input']>;
  isSurveyCreator?: InputMaybe<Scalars['Boolean']['input']>;
  isMessageCreator?: InputMaybe<Scalars['Boolean']['input']>;
  isFeedbackCreator?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AllUsersForFiltersQuery = { __typename?: 'Query', allUsers?: { __typename?: 'UserNodeConnection', edges: Array<{ __typename?: 'UserNodeEdge', node?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> } | null };

export type BusinessAreaDataQueryVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
}>;


export type BusinessAreaDataQuery = { __typename?: 'Query', businessArea?: { __typename?: 'BusinessAreaNode', id: string, screenBeneficiary: boolean, isPaymentPlanApplicable: boolean, isAccountabilityApplicable?: boolean | null } | null };

export type CashAssistUrlPrefixQueryVariables = Exact<{ [key: string]: never; }>;


export type CashAssistUrlPrefixQuery = { __typename?: 'Query', cashAssistUrlPrefix?: string | null };

export type CurrencyChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrencyChoicesQuery = { __typename?: 'Query', currencyChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type DataCollectionTypeChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type DataCollectionTypeChoiceDataQuery = { __typename?: 'Query', dataCollectionTypeChoices?: Array<{ __typename?: 'DataCollectingTypeChoiceObject', name?: string | null, value?: string | null, description?: string | null } | null> | null };

export type LoggedCheckerQueryVariables = Exact<{ [key: string]: never; }>;


export type LoggedCheckerQuery = { __typename?: 'Query', me?: { __typename?: 'UserNode', id: string } | null };

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { __typename?: 'Query', me?: { __typename?: 'UserNode', id: string, username: string, email: string, firstName: string, lastName: string, isSuperuser: boolean, businessAreas?: { __typename?: 'UserBusinessAreaNodeConnection', edges: Array<{ __typename?: 'UserBusinessAreaNodeEdge', node?: { __typename?: 'UserBusinessAreaNode', id: string, name: string, slug: string, permissions?: Array<string | null> | null } | null } | null> } | null } | null };

export type UserChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type UserChoiceDataQuery = { __typename?: 'Query', userRolesChoices?: Array<{ __typename?: 'RoleChoiceObject', name?: string | null, value?: string | null, subsystem?: string | null } | null> | null, userStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, userPartnerChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllAddIndividualFieldsQueryVariables = Exact<{ [key: string]: never; }>;


export type AllAddIndividualFieldsQuery = { __typename?: 'Query', allAddIndividualsFieldsAttributes?: Array<{ __typename?: 'FieldAttributeNode', isFlexField?: boolean | null, id?: string | null, type?: string | null, name?: string | null, required?: boolean | null, associatedWith?: string | null, labelEn?: string | null, hint?: string | null, labels?: Array<{ __typename?: 'LabelNode', language?: string | null, label?: string | null } | null> | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', labelEn?: string | null, value?: string | null, admin?: string | null, listName?: string | null, labels?: Array<{ __typename?: 'LabelNode', label?: string | null, language?: string | null } | null> | null } | null> | null } | null> | null, countriesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, documentTypeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, identityTypeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllEditHouseholdFieldsQueryVariables = Exact<{ [key: string]: never; }>;


export type AllEditHouseholdFieldsQuery = { __typename?: 'Query', allEditHouseholdFieldsAttributes?: Array<{ __typename?: 'FieldAttributeNode', isFlexField?: boolean | null, id?: string | null, type?: string | null, name?: string | null, required?: boolean | null, associatedWith?: string | null, labelEn?: string | null, hint?: string | null, labels?: Array<{ __typename?: 'LabelNode', language?: string | null, label?: string | null } | null> | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', labelEn?: string | null, value?: string | null, admin?: string | null, listName?: string | null, labels?: Array<{ __typename?: 'LabelNode', label?: string | null, language?: string | null } | null> | null } | null> | null } | null> | null, countriesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllHouseholdsFlexFieldsAttributesQueryVariables = Exact<{ [key: string]: never; }>;


export type AllHouseholdsFlexFieldsAttributesQuery = { __typename?: 'Query', allHouseholdsFlexFieldsAttributes?: Array<{ __typename?: 'FieldAttributeNode', isFlexField?: boolean | null, id?: string | null, type?: string | null, name?: string | null, required?: boolean | null, associatedWith?: string | null, labelEn?: string | null, hint?: string | null, labels?: Array<{ __typename?: 'LabelNode', language?: string | null, label?: string | null } | null> | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', labelEn?: string | null, value?: string | null, admin?: string | null, listName?: string | null, labels?: Array<{ __typename?: 'LabelNode', label?: string | null, language?: string | null } | null> | null } | null> | null } | null> | null };

export type AllIndividualsFlexFieldsAttributesQueryVariables = Exact<{ [key: string]: never; }>;


export type AllIndividualsFlexFieldsAttributesQuery = { __typename?: 'Query', allIndividualsFlexFieldsAttributes?: Array<{ __typename?: 'FieldAttributeNode', isFlexField?: boolean | null, id?: string | null, type?: string | null, name?: string | null, required?: boolean | null, associatedWith?: string | null, labelEn?: string | null, hint?: string | null, labels?: Array<{ __typename?: 'LabelNode', language?: string | null, label?: string | null } | null> | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', labelEn?: string | null, value?: string | null, admin?: string | null, listName?: string | null, labels?: Array<{ __typename?: 'LabelNode', label?: string | null, language?: string | null } | null> | null } | null> | null } | null> | null };

export type FlexFieldsQueryVariables = Exact<{ [key: string]: never; }>;


export type FlexFieldsQuery = { __typename?: 'Query', allGroupsWithFields?: Array<{ __typename?: 'GroupAttributeNode', name: string, labelEn?: string | null, flexAttributes?: Array<{ __typename?: 'FieldAttributeNode', id?: string | null, labelEn?: string | null, associatedWith?: string | null } | null> | null } | null> | null };

export type ImportedIndividualFieldsQueryVariables = Exact<{
  businessAreaSlug?: InputMaybe<Scalars['String']['input']>;
  programId?: InputMaybe<Scalars['String']['input']>;
}>;


export type ImportedIndividualFieldsQuery = { __typename?: 'Query', allFieldsAttributes?: Array<{ __typename?: 'FieldAttributeNode', isFlexField?: boolean | null, id?: string | null, type?: string | null, name?: string | null, associatedWith?: string | null, labelEn?: string | null, hint?: string | null, labels?: Array<{ __typename?: 'LabelNode', language?: string | null, label?: string | null } | null> | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', labelEn?: string | null, value?: string | null, admin?: string | null, listName?: string | null, labels?: Array<{ __typename?: 'LabelNode', label?: string | null, language?: string | null } | null> | null } | null> | null } | null> | null };

export type AllFeedbacksQueryVariables = Exact<{
  offset?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  feedbackId?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  isActiveProgram?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllFeedbacksQuery = { __typename?: 'Query', allFeedbacks?: { __typename?: 'FeedbackNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'FeedbackNodeEdge', cursor: string, node?: { __typename?: 'FeedbackNode', id: string, unicefId?: string | null, issueType: FeedbackIssueType, createdAt: any, householdLookup?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, linkedGrievance?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, category: number } | null, program?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null } | null> } | null };

export type FeedbackQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type FeedbackQuery = { __typename?: 'Query', feedback?: { __typename?: 'FeedbackNode', id: string, unicefId?: string | null, issueType: FeedbackIssueType, adminUrl?: string | null, createdAt: any, updatedAt: any, area: string, language: string, description: string, comments?: string | null, householdLookup?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string } } | null, individualLookup?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null } | null, program?: { __typename?: 'ProgramNode', id: string, name: string } | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, username: string, email: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null, linkedGrievance?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, category: number } | null, feedbackMessages: { __typename?: 'FeedbackMessageNodeConnection', edges: Array<{ __typename?: 'FeedbackMessageNodeEdge', node?: { __typename?: 'FeedbackMessageNode', id: string, createdAt: any, updatedAt: any, description: string, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, username: string, email: string } | null } | null } | null> } } | null };

export type FeedbackIssueTypeChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type FeedbackIssueTypeChoicesQuery = { __typename?: 'Query', feedbackIssueTypeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllGrievanceDashboardChartsQueryVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
}>;


export type AllGrievanceDashboardChartsQuery = { __typename?: 'Query', ticketsByType?: { __typename?: 'TicketByType', userGeneratedCount?: number | null, systemGeneratedCount?: number | null, closedUserGeneratedCount?: number | null, closedSystemGeneratedCount?: number | null, userGeneratedAvgResolution?: number | null, systemGeneratedAvgResolution?: number | null } | null, ticketsByStatus?: { __typename?: 'ChartDatasetNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DatasetsNode', data?: Array<number | null> | null } | null> | null } | null, ticketsByCategory?: { __typename?: 'ChartDatasetNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DatasetsNode', data?: Array<number | null> | null } | null> | null } | null, ticketsByLocationAndCategory?: { __typename?: 'ChartDetailedDatasetsNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DetailedDatasetsNode', data?: Array<number | null> | null, label?: string | null } | null> | null } | null };

export type AllGrievanceTicketQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  fsp?: InputMaybe<Scalars['String']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  admin2?: InputMaybe<Scalars['ID']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  registrationDataImport?: InputMaybe<Scalars['ID']['input']>;
  assignedTo?: InputMaybe<Scalars['ID']['input']>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  cashPlan?: InputMaybe<Scalars['String']['input']>;
  scoreMin?: InputMaybe<Scalars['String']['input']>;
  scoreMax?: InputMaybe<Scalars['String']['input']>;
  household?: InputMaybe<Scalars['String']['input']>;
  grievanceType?: InputMaybe<Scalars['String']['input']>;
  grievanceStatus?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['String']['input']>;
  urgency?: InputMaybe<Scalars['String']['input']>;
  preferredLanguage?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
  isCrossArea?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AllGrievanceTicketQuery = { __typename?: 'Query', allGrievanceTicket?: { __typename?: 'GrievanceTicketNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'GrievanceTicketNodeEdge', cursor: string, node?: { __typename?: 'GrievanceTicketNode', id: string, status: number, category: number, issueType?: number | null, createdAt: any, userModified?: any | null, admin?: string | null, unicefId?: string | null, priority?: number | null, urgency?: number | null, updatedAt: any, totalDays?: string | null, assignedTo?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, createdBy?: { __typename?: 'UserNode', id: string } | null, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string } | null, relatedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string } | null> | null, programs?: Array<{ __typename?: 'ProgramNode', id: string, name: string } | null> | null } | null } | null> } | null };

export type GrievanceTicketAreaScopeQueryVariables = Exact<{ [key: string]: never; }>;


export type GrievanceTicketAreaScopeQuery = { __typename?: 'Query', crossAreaFilterAvailable?: boolean | null };

export type ExistingGrievanceTicketsQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  businessArea: Scalars['String']['input'];
  household?: InputMaybe<Scalars['ID']['input']>;
  individual?: InputMaybe<Scalars['ID']['input']>;
  paymentRecord?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  category?: InputMaybe<Scalars['String']['input']>;
  issueType?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type ExistingGrievanceTicketsQuery = { __typename?: 'Query', existingGrievanceTickets?: { __typename?: 'GrievanceTicketNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'GrievanceTicketNodeEdge', cursor: string, node?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, category: number, createdAt: any, issueType?: number | null, userModified?: any | null, admin?: string | null, assignedTo?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string } | null, individual?: { __typename?: 'IndividualNode', unicefId?: string | null, id: string } | null } | null } | null> } | null };

export type GrievanceTicketQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GrievanceTicketQuery = { __typename?: 'Query', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, category: number, consent: boolean, createdAt: any, updatedAt: any, description: string, language: string, admin?: string | null, area: string, adminUrl?: string | null, issueType?: number | null, priority?: number | null, urgency?: number | null, comments?: string | null, partner?: { __typename?: 'PartnerType', id: string, name: string } | null, businessArea: { __typename?: 'UserBusinessAreaNode', postponeDeduplication: boolean }, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, pCode?: string | null } | null, assignedTo?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, paymentRecord?: { __typename?: 'PaymentRecordAndPaymentNode', id?: string | null, caId?: string | null, deliveredQuantity?: number | null, entitlementQuantity?: number | null, objType?: string | null, parent?: { __typename?: 'CashPlanAndPaymentPlanNode', id?: string | null, unicefId?: string | null, objType?: string | null } | null, verification?: { __typename?: 'PaymentVerificationNode', id: string } | null } | null, relatedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, linkedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null, category: number, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, existingTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, category: number, unicefId?: string | null, status: number, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null> | null, addIndividualTicketDetails?: { __typename?: 'TicketAddIndividualDetailsNode', id: string, individualData?: any | null, approveStatus: boolean, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null, individualDataUpdateTicketDetails?: { __typename?: 'TicketIndividualDataUpdateDetailsNode', id: string, individualData?: any | null, roleReassignData: any, individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null } | null, householdDataUpdateTicketDetails?: { __typename?: 'TicketHouseholdDataUpdateDetailsNode', id: string, householdData?: any | null, household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null } | null, deleteIndividualTicketDetails?: { __typename?: 'TicketDeleteIndividualDetailsNode', id: string, roleReassignData: any, approveStatus: boolean } | null, deleteHouseholdTicketDetails?: { __typename?: 'TicketDeleteHouseholdDetailsNode', id: string, approveStatus: boolean, reasonHousehold?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null } | null, systemFlaggingTicketDetails?: { __typename?: 'TicketSystemFlaggingDetailsNode', id: string, approveStatus: boolean, roleReassignData: any, goldenRecordsIndividual: { __typename?: 'IndividualNode', id: string, fullName: string, birthDate: any, lastRegistrationDate: any, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, documentNumber: string, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> } }, sanctionListIndividual: { __typename?: 'SanctionListIndividualNode', id: string, fullName: string, referenceNumber: string, datesOfBirth: { __typename?: 'SanctionListIndividualDateOfBirthNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDateOfBirthNodeEdge', node?: { __typename?: 'SanctionListIndividualDateOfBirthNode', id: string, date: any } | null } | null> }, documents: { __typename?: 'SanctionListIndividualDocumentNodeConnection', edges: Array<{ __typename?: 'SanctionListIndividualDocumentNodeEdge', node?: { __typename?: 'SanctionListIndividualDocumentNode', id: string, documentNumber: string, typeOfDocument: string } | null } | null> } } } | null, paymentVerificationTicketDetails?: { __typename?: 'TicketPaymentVerificationDetailsNode', id: string, newStatus?: TicketPaymentVerificationDetailsNewStatus | null, oldReceivedAmount?: number | null, newReceivedAmount?: number | null, approveStatus: boolean, paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus, hasMultiplePaymentVerifications?: boolean | null, paymentVerification?: { __typename?: 'PaymentVerificationNode', id: string, receivedAmount?: number | null } | null, paymentVerifications: { __typename?: 'PaymentVerificationNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationNodeEdge', node?: { __typename?: 'PaymentVerificationNode', id: string } | null } | null> } } | null, needsAdjudicationTicketDetails?: { __typename?: 'TicketNeedsAdjudicationDetailsNode', id: string, hasDuplicatedDocument?: boolean | null, isMultipleDuplicatesVersion: boolean, roleReassignData: any, extraData?: { __typename?: 'TicketNeedsAdjudicationDetailsExtraDataNode', goldenRecords?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null, possibleDuplicate?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null, goldenRecordsIndividual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string, birthDate: any, lastRegistrationDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null }, possibleDuplicate?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, lastRegistrationDate: any, fullName: string, birthDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null, possibleDuplicates?: Array<{ __typename?: 'IndividualNode', id: string, unicefId?: string | null, lastRegistrationDate: any, fullName: string, birthDate: any, sex: IndividualSex, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', unicefId?: string | null, id: string, village: string, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, proximityToScore?: number | null, score?: number | null } | null> | null } | null> | null, selectedIndividual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, activeIndividualsCount?: number | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, adminUrl?: string | null, createdAt: any, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unhcrId: string, adminAreaTitle?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null, selectedIndividuals?: Array<{ __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, activeIndividualsCount?: number | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, adminUrl?: string | null, createdAt: any, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unhcrId: string, adminAreaTitle?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, individual: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null> | null } | null, ticketNotes: { __typename?: 'TicketNoteNodeConnection', edges: Array<{ __typename?: 'TicketNoteNodeEdge', node?: { __typename?: 'TicketNoteNode', id: string, createdAt: any, updatedAt: any, description: string, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null } | null> }, programs?: Array<{ __typename?: 'ProgramNode', name: string, id: string } | null> | null, documentation?: Array<{ __typename?: 'GrievanceDocumentNode', id: string, createdAt: any, updatedAt: any, name?: string | null, fileSize?: number | null, contentType: string, filePath?: string | null, fileName?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null } | null };

export type GrievanceTicketFlexFieldsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GrievanceTicketFlexFieldsQuery = { __typename?: 'Query', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, individualDataUpdateTicketDetails?: { __typename?: 'TicketIndividualDataUpdateDetailsNode', id: string, individualData?: any | null } | null, householdDataUpdateTicketDetails?: { __typename?: 'TicketHouseholdDataUpdateDetailsNode', id: string, householdData?: any | null } | null } | null };

export type GrievanceTicketUnicefIdQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GrievanceTicketUnicefIdQuery = { __typename?: 'Query', grievanceTicket?: { __typename?: 'GrievanceTicketNode', id: string, unicefId?: string | null } | null };

export type GrievancesChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type GrievancesChoiceDataQuery = { __typename?: 'Query', grievanceTicketStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, grievanceTicketCategoryChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, grievanceTicketManualCategoryChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, grievanceTicketSystemCategoryChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, grievanceTicketPriorityChoices?: Array<{ __typename?: 'ChoiceObjectInt', name?: string | null, value?: number | null } | null> | null, grievanceTicketUrgencyChoices?: Array<{ __typename?: 'ChoiceObjectInt', name?: string | null, value?: number | null } | null> | null, grievanceTicketIssueTypeChoices?: Array<{ __typename?: 'IssueTypesObject', category?: string | null, label?: string | null, subCategories?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null } | null> | null, grievanceTicketSearchTypesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type PartnerForGrievanceChoicesQueryVariables = Exact<{
  householdId?: InputMaybe<Scalars['ID']['input']>;
  individualId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type PartnerForGrievanceChoicesQuery = { __typename?: 'Query', partnerForGrievanceChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type RelatedGrievanceTicketsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RelatedGrievanceTicketsQuery = { __typename?: 'Query', grievanceTicket?: { __typename?: 'GrievanceTicketNode', relatedTickets?: Array<{ __typename?: 'GrievanceTicketNode', id: string, status: number, category: number, issueType?: number | null, unicefId?: string | null } | null> | null } | null };

export type AllDeliveryMechanismsQueryVariables = Exact<{ [key: string]: never; }>;


export type AllDeliveryMechanismsQuery = { __typename?: 'Query', allDeliveryMechanisms?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllPaymentPlansForTableQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  totalEntitledQuantityFrom?: InputMaybe<Scalars['Float']['input']>;
  totalEntitledQuantityTo?: InputMaybe<Scalars['Float']['input']>;
  dispersionStartDate?: InputMaybe<Scalars['Date']['input']>;
  dispersionEndDate?: InputMaybe<Scalars['Date']['input']>;
  isFollowUp?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllPaymentPlansForTableQuery = { __typename?: 'Query', allPaymentPlans?: { __typename?: 'PaymentPlanNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'PaymentPlanNodeEdge', cursor: string, node?: { __typename?: 'PaymentPlanNode', id: string, unicefId?: string | null, name?: string | null, isFollowUp: boolean, status: PaymentPlanStatus, currency: PaymentPlanCurrency, currencyName?: string | null, startDate?: any | null, endDate?: any | null, dispersionStartDate?: any | null, dispersionEndDate?: any | null, femaleChildrenCount: number, femaleAdultsCount: number, maleChildrenCount: number, maleAdultsCount: number, totalHouseholdsCount: number, totalIndividualsCount: number, totalEntitledQuantity?: number | null, totalDeliveredQuantity?: number | null, totalUndeliveredQuantity?: number | null, followUps: { __typename?: 'PaymentPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentPlanNodeEdge', node?: { __typename?: 'PaymentPlanNode', id: string, unicefId?: string | null } | null } | null> }, createdBy: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string }, program: { __typename?: 'ProgramNode', id: string, name: string }, targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string } } | null } | null> } | null };

export type AvailableFspsForDeliveryMechanismsQueryVariables = Exact<{
  input: AvailableFspsForDeliveryMechanismsInput;
}>;


export type AvailableFspsForDeliveryMechanismsQuery = { __typename?: 'Query', availableFspsForDeliveryMechanisms?: Array<{ __typename?: 'FspChoices', deliveryMechanism?: string | null, fsps?: Array<{ __typename?: 'FspChoice', id?: string | null, name?: string | null, configurations?: Array<{ __typename?: 'FspConfiguration', id?: string | null, key?: string | null, label?: string | null } | null> | null } | null> | null } | null> | null };

export type PaymentQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PaymentQuery = { __typename?: 'Query', payment?: { __typename?: 'PaymentNode', id: string, unicefId?: string | null, distributionModality?: string | null, status: PaymentStatus, statusDate: any, snapshotCollectorBankName?: string | null, snapshotCollectorBankAccountNumber?: string | null, debitCardNumber?: string | null, debitCardIssuer?: string | null, currency: string, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveryDate?: any | null, deliveredQuantityUsd?: number | null, deliveryType?: PaymentDeliveryType | null, transactionReferenceId?: string | null, additionalCollectorName?: string | null, additionalDocumentType?: string | null, additionalDocumentNumber?: string | null, reasonForUnsuccessfulPayment?: string | null, snapshotCollectorFullName?: string | null, adminUrl?: string | null, targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string } | null, sourcePayment?: { __typename?: 'PaymentNode', id: string, unicefId?: string | null } | null, verification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, statusDate?: any | null, receivedAmount?: number | null, isManuallyEditable?: boolean | null, adminUrl?: string | null } | null, household: { __typename?: 'HouseholdNode', id: string, size?: number | null, status?: string | null, unicefId?: string | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null, fullName: string } }, collector: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string, email: string, phoneNo: string, phoneNoValid?: boolean | null, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null }, parent: { __typename?: 'PaymentPlanNode', id: string, status: PaymentPlanStatus, isFollowUp: boolean, unicefId?: string | null, program: { __typename?: 'ProgramNode', id: string, name: string }, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, verificationChannel: PaymentVerificationPlanVerificationChannel } | null } | null> } | null }, serviceProvider?: { __typename?: 'FinancialServiceProviderNode', id: string, fullName?: string | null } | null } | null };

export type PaymentPlanQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PaymentPlanQuery = { __typename?: 'Query', paymentPlan?: { __typename?: 'PaymentPlanNode', id: string, version: any, unicefId?: string | null, status: PaymentPlanStatus, canCreateFollowUp?: boolean | null, backgroundActionStatus?: PaymentPlanBackgroundActionStatus | null, canCreatePaymentVerificationPlan?: boolean | null, availablePaymentRecordsCount?: number | null, bankReconciliationSuccess?: number | null, bankReconciliationError?: number | null, adminUrl?: string | null, currency: PaymentPlanCurrency, currencyName?: string | null, startDate?: any | null, endDate?: any | null, dispersionStartDate?: any | null, dispersionEndDate?: any | null, femaleChildrenCount: number, femaleAdultsCount: number, maleChildrenCount: number, maleAdultsCount: number, totalHouseholdsCount: number, totalIndividualsCount: number, totalEntitledQuantity?: number | null, totalDeliveredQuantity?: number | null, totalUndeliveredQuantity?: number | null, totalWithdrawnHouseholdsCount?: number | null, hasPaymentListExportFile?: boolean | null, hasFspDeliveryMechanismXlsxTemplate?: boolean | null, importedFileDate?: any | null, importedFileName?: string | null, totalEntitledQuantityUsd?: number | null, paymentsConflictsCount?: number | null, canSendToPaymentGateway?: boolean | null, canSplit?: boolean | null, exclusionReason: string, excludeHouseholdError: string, isFollowUp: boolean, unsuccessfulPaymentsCount?: number | null, createdBy: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string }, program: { __typename?: 'ProgramNode', id: string, name: string, caId?: string | null }, targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string }, approvalProcess: { __typename?: 'ApprovalProcessNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'ApprovalProcessNodeEdge', node?: { __typename?: 'ApprovalProcessNode', id: string, sentForApprovalDate?: any | null, sentForAuthorizationDate?: any | null, sentForFinanceReleaseDate?: any | null, approvalNumberRequired: number, authorizationNumberRequired: number, financeReleaseNumberRequired: number, rejectedOn?: string | null, sentForApprovalBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, sentForAuthorizationBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, sentForFinanceReleaseBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, actions?: { __typename?: 'FilteredActionsListNode', approval?: Array<{ __typename?: 'ApprovalNode', createdAt: any, comment?: string | null, info?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null, authorization?: Array<{ __typename?: 'ApprovalNode', createdAt: any, comment?: string | null, info?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null, financeRelease?: Array<{ __typename?: 'ApprovalNode', createdAt: any, comment?: string | null, info?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null, reject?: Array<{ __typename?: 'ApprovalNode', createdAt: any, comment?: string | null, info?: string | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null> | null } | null } | null } | null> }, steficonRule?: { __typename?: 'RuleCommitNode', id: string, rule?: { __typename?: 'SteficonRuleNode', id: string, name: string } | null } | null, deliveryMechanisms?: Array<{ __typename?: 'DeliveryMechanismNode', id: string, name?: string | null, order?: number | null, sentToPaymentGateway: boolean, chosenConfiguration?: string | null, fsp?: { __typename?: 'FinancialServiceProviderNode', id: string, name: string, communicationChannel: FinancialServiceProviderCommunicationChannel, isPaymentGateway?: boolean | null } | null } | null> | null, splitChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, volumeByDeliveryMechanism?: Array<{ __typename?: 'VolumeByDeliveryMechanismNode', volume?: number | null, volumeUsd?: number | null, deliveryMechanism?: { __typename?: 'DeliveryMechanismNode', id: string, name?: string | null, order?: number | null, fsp?: { __typename?: 'FinancialServiceProviderNode', id: string, name: string } | null } | null } | null> | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, unicefId?: string | null, adminUrl?: string | null, status: PaymentVerificationPlanStatus, sampleSize?: number | null, receivedCount?: number | null, notReceivedCount?: number | null, respondedCount?: number | null, verificationChannel: PaymentVerificationPlanVerificationChannel, sampling: PaymentVerificationPlanSampling, receivedWithProblemsCount?: number | null, rapidProFlowId: string, confidenceInterval?: number | null, marginOfError?: number | null, activationDate?: any | null, completionDate?: any | null, excludedAdminAreasFilter?: Array<string | null> | null, sexFilter?: string | null, xlsxFileExporting: boolean, hasXlsxFile?: boolean | null, xlsxFileWasDownloaded?: boolean | null, xlsxFileImported: boolean, ageFilter?: { __typename?: 'AgeFilterObject', min?: number | null, max?: number | null } | null } | null } | null> } | null, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, createdAt: any, updatedAt: any, status: PaymentVerificationSummaryStatus, activationDate?: any | null, completionDate?: any | null } | null, paymentItems: { __typename?: 'PaymentNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'PaymentNodeEdge', node?: { __typename?: 'PaymentNode', id: string, status: PaymentStatus } | null } | null> }, reconciliationSummary?: { __typename?: 'ReconciliationSummaryNode', deliveredFully?: number | null, deliveredPartially?: number | null, notDelivered?: number | null, unsuccessful?: number | null, pending?: number | null, numberOfPayments?: number | null, reconciled?: number | null } | null, excludedHouseholds?: Array<{ __typename?: 'HouseholdNode', id: string, unicefId?: string | null } | null> | null, followUps: { __typename?: 'PaymentPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentPlanNodeEdge', node?: { __typename?: 'PaymentPlanNode', id: string, unicefId?: string | null, createdAt: any, paymentItems: { __typename?: 'PaymentNodeConnection', totalCount?: number | null } } | null } | null> }, sourcePaymentPlan?: { __typename?: 'PaymentPlanNode', id: string, unicefId?: string | null } | null } | null };

export type AllCashPlansQueryVariables = Exact<{
  program?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  serviceProvider?: InputMaybe<Scalars['String']['input']>;
  deliveryType?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  verificationStatus?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  startDateGte?: InputMaybe<Scalars['DateTime']['input']>;
  endDateLte?: InputMaybe<Scalars['DateTime']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllCashPlansQuery = { __typename?: 'Query', allCashPlans?: { __typename?: 'CashPlanNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'CashPlanNodeEdge', cursor: string, node?: { __typename?: 'CashPlanNode', id: string, caId?: string | null, assistanceThrough: string, totalNumberOfHouseholds?: number | null, deliveryType?: string | null, startDate: any, endDate: any, totalPersonsCovered: number, dispersionDate: any, assistanceMeasurement: string, status: CashPlanStatus, currency?: string | null, totalEntitledQuantity?: number | null, totalDeliveredQuantity?: number | null, totalUndeliveredQuantity?: number | null, updatedAt: any, serviceProvider?: { __typename?: 'ServiceProviderNode', id: string, caId: string, fullName?: string | null } | null, program: { __typename?: 'ProgramNode', id: string, name: string }, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, status: PaymentVerificationSummaryStatus } | null } | null } | null> } | null };

export type AllCashPlansAndPaymentPlansQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  serviceProvider?: InputMaybe<Scalars['String']['input']>;
  deliveryType?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  verificationStatus?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  startDateGte?: InputMaybe<Scalars['String']['input']>;
  endDateLte?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  isPaymentVerificationPage?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AllCashPlansAndPaymentPlansQuery = { __typename?: 'Query', allCashPlansAndPaymentPlans?: { __typename?: 'PaginatedCashPlanAndPaymentPlanNode', totalCount?: number | null, pageInfo?: { __typename?: 'PageInfoNode', startCursor?: string | null, endCursor?: string | null, hasNextPage?: boolean | null, hasPreviousPage?: boolean | null } | null, edges?: Array<{ __typename?: 'CashPlanAndPaymentPlanEdges', cursor?: string | null, node?: { __typename?: 'CashPlanAndPaymentPlanNode', objType?: string | null, id?: string | null, unicefId?: string | null, verificationStatus?: string | null, status?: string | null, currency?: string | null, totalDeliveredQuantity?: number | null, startDate?: string | null, endDate?: string | null, programName?: string | null, updatedAt?: string | null, totalNumberOfHouseholds?: number | null, assistanceMeasurement?: string | null, totalEntitledQuantity?: number | null, totalUndeliveredQuantity?: number | null, dispersionDate?: string | null, serviceProviderFullName?: string | null, verificationPlans?: Array<{ __typename?: 'PaymentVerificationPlanNode', id: string, createdAt: any, unicefId?: string | null } | null> | null } | null } | null> | null } | null };

export type AllPaymentRecordsQueryVariables = Exact<{
  parent?: InputMaybe<Scalars['ID']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllPaymentRecordsQuery = { __typename?: 'Query', allPaymentRecords?: { __typename?: 'PaymentRecordNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'PaymentRecordNodeEdge', cursor: string, node?: { __typename?: 'PaymentRecordNode', id: string, createdAt: any, updatedAt: any, fullName: string, statusDate: any, status: PaymentRecordStatus, caId?: string | null, totalPersonsCovered: number, currency: string, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveredQuantityUsd?: number | null, deliveryDate?: any | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null }, headOfHousehold?: { __typename?: 'IndividualNode', id: string, fullName: string } | null, parent?: { __typename?: 'CashPlanNode', id: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> } | null };

export type AllPaymentRecordsAndPaymentsQueryVariables = Exact<{
  household?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  businessArea: Scalars['String']['input'];
}>;


export type AllPaymentRecordsAndPaymentsQuery = { __typename?: 'Query', allPaymentRecordsAndPayments?: { __typename?: 'PaginatedPaymentRecordsAndPaymentsNode', totalCount?: number | null, pageInfo?: { __typename?: 'PageInfoNode', hasNextPage?: boolean | null, hasPreviousPage?: boolean | null, startCursor?: string | null, endCursor?: string | null } | null, edges?: Array<{ __typename?: 'PaymentRecordsAndPaymentsEdges', cursor?: string | null, node?: { __typename?: 'PaymentRecordAndPaymentNode', objType?: string | null, id?: string | null, fullName?: string | null, status?: string | null, caId?: string | null, currency?: string | null, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveredQuantityUsd?: number | null, deliveryDate?: string | null, parent?: { __typename?: 'CashPlanAndPaymentPlanNode', id?: string | null, programName?: string | null } | null, verification?: { __typename?: 'PaymentVerificationNode', id: string, receivedAmount?: number | null } | null } | null } | null> | null } | null };

export type AllPaymentsForTableQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  paymentPlanId: Scalars['String']['input'];
}>;


export type AllPaymentsForTableQuery = { __typename?: 'Query', allPayments?: { __typename?: 'PaymentNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'PaymentNodeEdge', cursor: string, node?: { __typename?: 'PaymentNode', id: string, unicefId?: string | null, status: PaymentStatus, entitlementQuantity?: number | null, entitlementQuantityUsd?: number | null, currency: string, deliveredQuantity?: number | null, deliveredQuantityUsd?: number | null, paymentPlanHardConflicted?: boolean | null, paymentPlanSoftConflicted?: boolean | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null, individuals?: { __typename?: 'IndividualNodeConnection', edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string } | null } | null> } | null }, paymentPlanHardConflictedData?: Array<{ __typename?: 'PaymentConflictDataNode', paymentPlanUnicefId?: string | null, paymentPlanId?: string | null, paymentPlanStartDate?: string | null, paymentPlanEndDate?: string | null, paymentPlanStatus?: string | null, paymentId?: string | null, paymentUnicefId?: string | null } | null> | null, paymentPlanSoftConflictedData?: Array<{ __typename?: 'PaymentConflictDataNode', paymentPlanUnicefId?: string | null, paymentPlanId?: string | null, paymentPlanStartDate?: string | null, paymentPlanEndDate?: string | null, paymentPlanStatus?: string | null, paymentId?: string | null, paymentUnicefId?: string | null } | null> | null, collector: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, fullName: string }, financialServiceProvider?: { __typename?: 'FinancialServiceProviderNode', id: string, name: string } | null } | null } | null> } | null };

export type CashPlanQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type CashPlanQuery = { __typename?: 'Query', cashPlan?: { __typename?: 'CashPlanNode', id: string, version: any, canCreatePaymentVerificationPlan?: boolean | null, availablePaymentRecordsCount?: number | null, name: string, startDate: any, endDate: any, updatedAt: any, status: CashPlanStatus, deliveryType?: string | null, fundsCommitment?: string | null, downPayment?: string | null, dispersionDate: any, assistanceThrough: string, caId?: string | null, caHashId?: any | null, bankReconciliationSuccess?: number | null, bankReconciliationError?: number | null, totalNumberOfHouseholds?: number | null, serviceProvider?: { __typename?: 'ServiceProviderNode', id: string, caId: string, fullName?: string | null } | null, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, unicefId?: string | null, adminUrl?: string | null, status: PaymentVerificationPlanStatus, sampleSize?: number | null, receivedCount?: number | null, notReceivedCount?: number | null, respondedCount?: number | null, verificationChannel: PaymentVerificationPlanVerificationChannel, sampling: PaymentVerificationPlanSampling, receivedWithProblemsCount?: number | null, rapidProFlowId: string, confidenceInterval?: number | null, marginOfError?: number | null, activationDate?: any | null, completionDate?: any | null, excludedAdminAreasFilter?: Array<string | null> | null, sexFilter?: string | null, xlsxFileExporting: boolean, hasXlsxFile?: boolean | null, xlsxFileWasDownloaded?: boolean | null, xlsxFileImported: boolean, ageFilter?: { __typename?: 'AgeFilterObject', min?: number | null, max?: number | null } | null } | null } | null> } | null, paymentVerificationSummary?: { __typename?: 'PaymentVerificationSummaryNode', id: string, createdAt: any, updatedAt: any, status: PaymentVerificationSummaryStatus, activationDate?: any | null, completionDate?: any | null } | null, program: { __typename?: 'ProgramNode', id: string, name: string, caId?: string | null }, paymentItems: { __typename?: 'PaymentRecordNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string } } | null } | null> } } | null };

export type IndividualPhotosQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type IndividualPhotosQuery = { __typename?: 'Query', individual?: { __typename?: 'IndividualNode', id: string, photo?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, documentNumber: string, photo?: string | null } | null } | null> } } | null };

export type ImportedIndividualPhotosQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ImportedIndividualPhotosQuery = { __typename?: 'Query', importedIndividual?: { __typename?: 'ImportedIndividualNode', id: string, photo: string, documents: { __typename?: 'ImportedDocumentNodeConnection', edges: Array<{ __typename?: 'ImportedDocumentNodeEdge', node?: { __typename?: 'ImportedDocumentNode', id: string, photo?: string | null } | null } | null> } } | null };

export type LookUpPaymentRecordsQueryVariables = Exact<{
  parent?: InputMaybe<Scalars['ID']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type LookUpPaymentRecordsQuery = { __typename?: 'Query', allPaymentRecords?: { __typename?: 'PaymentRecordNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'PaymentRecordNodeEdge', cursor: string, node?: { __typename?: 'PaymentRecordNode', id: string, caId?: string | null, deliveredQuantity?: number | null, parent?: { __typename?: 'CashPlanNode', id: string, name: string } | null } | null } | null> } | null };

export type PaymentRecordQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PaymentRecordQuery = { __typename?: 'Query', paymentRecord?: { __typename?: 'PaymentRecordNode', id: string, status: PaymentRecordStatus, statusDate: any, caId?: string | null, caHashId?: any | null, registrationCaId?: string | null, fullName: string, distributionModality: string, totalPersonsCovered: number, currency: string, entitlementQuantity?: number | null, deliveredQuantity?: number | null, deliveryDate?: any | null, entitlementCardIssueDate?: any | null, entitlementCardNumber?: string | null, deliveredQuantityUsd?: number | null, deliveryType?: PaymentRecordDeliveryType | null, transactionReferenceId?: string | null, targetPopulation: { __typename?: 'TargetPopulationNode', id: string, name: string }, verification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, statusDate?: any | null, receivedAmount?: number | null, isManuallyEditable?: boolean | null, adminUrl?: string | null } | null, household: { __typename?: 'HouseholdNode', id: string, size?: number | null, status?: string | null, unicefId?: string | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null } }, parent?: { __typename?: 'CashPlanNode', id: string, unicefId?: string | null, caId?: string | null, program: { __typename?: 'ProgramNode', id: string, name: string }, verificationPlans?: { __typename?: 'PaymentVerificationPlanNodeConnection', edges: Array<{ __typename?: 'PaymentVerificationPlanNodeEdge', node?: { __typename?: 'PaymentVerificationPlanNode', id: string, status: PaymentVerificationPlanStatus, verificationChannel: PaymentVerificationPlanVerificationChannel } | null } | null> } | null } | null, serviceProvider: { __typename?: 'ServiceProviderNode', id: string, fullName?: string | null, shortName?: string | null } } | null };

export type AllPaymentVerificationLogEntriesQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
  objectId?: InputMaybe<Scalars['UUID']['input']>;
  objectType?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  module?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllPaymentVerificationLogEntriesQuery = { __typename?: 'Query', allPaymentVerificationLogEntries?: { __typename?: 'PaymentVerificationLogEntryNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'PaymentVerificationLogEntryNodeEdge', cursor: string, node?: { __typename?: 'PaymentVerificationLogEntryNode', id: string, action: LogEntryAction, changes?: any | null, objectRepr: string, objectId?: any | null, timestamp?: any | null, contentType?: { __typename?: 'ContentTypeObjectType', id: string, appLabel: string, model: string, name?: string | null } | null, user?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string } | null, contentObject?: { __typename?: 'PaymentVerificationPlanNode', id: string, unicefId?: string | null } | null } | null } | null> } | null, logEntryActionChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllPaymentVerificationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  paymentVerificationPlan?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  businessArea: Scalars['String']['input'];
  verificationChannel?: InputMaybe<Scalars['String']['input']>;
  paymentPlanId?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllPaymentVerificationsQuery = { __typename?: 'Query', allPaymentVerifications?: { __typename?: 'PaymentVerificationNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'PaymentVerificationNodeEdge', cursor: string, node?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, receivedAmount?: number | null, paymentVerificationPlan: { __typename?: 'PaymentVerificationPlanNode', id: string, unicefId?: string | null, verificationChannel: PaymentVerificationPlanVerificationChannel }, payment?: { __typename?: 'GenericPaymentNode', id?: string | null, unicefId?: string | null, deliveredQuantity?: number | null, currency?: string | null, household?: { __typename?: 'HouseholdNode', status?: string | null, unicefId?: string | null, id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, familyName: string, phoneNo: string, phoneNoAlternative: string } } | null } | null } | null } | null> } | null };

export type AllRapidProFlowsQueryVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
}>;


export type AllRapidProFlowsQuery = { __typename?: 'Query', allRapidProFlows?: Array<{ __typename?: 'RapidProFlow', id?: string | null, name?: string | null } | null> | null };

export type PaymentVerificationPlanQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PaymentVerificationPlanQuery = { __typename?: 'Query', paymentVerificationPlan?: { __typename?: 'PaymentVerificationPlanNode', id: string } | null };

export type CashPlanVerificationStatusChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type CashPlanVerificationStatusChoicesQuery = { __typename?: 'Query', cashPlanVerificationStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, paymentRecordDeliveryTypeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type PaymentPlanStatusChoicesQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentPlanStatusChoicesQueryQuery = { __typename?: 'Query', paymentPlanStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type PaymentRecordVerificationQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PaymentRecordVerificationQuery = { __typename?: 'Query', paymentRecordVerification?: { __typename?: 'PaymentVerificationNode', id: string, status: PaymentVerificationStatus, statusDate?: any | null, receivedAmount?: number | null, isManuallyEditable?: boolean | null } | null };

export type PaymentVerificationChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentVerificationChoicesQuery = { __typename?: 'Query', paymentVerificationStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, cashPlanVerificationVerificationChannelChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, paymentRecordDeliveryTypeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type SampleSizeQueryVariables = Exact<{
  input: GetCashplanVerificationSampleSizeInput;
}>;


export type SampleSizeQuery = { __typename?: 'Query', sampleSize?: { __typename?: 'GetCashplanVerificationSampleSizeObject', paymentRecordCount?: number | null, sampleSize?: number | null } | null };

export type CashPlanVerificationSamplingChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type CashPlanVerificationSamplingChoicesQuery = { __typename?: 'Query', cashPlanVerificationSamplingChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllHouseholdsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  familySize?: InputMaybe<Scalars['String']['input']>;
  headOfHouseholdFullNameIcontains?: InputMaybe<Scalars['String']['input']>;
  headOfHouseholdPhoneNoValid?: InputMaybe<Scalars['Boolean']['input']>;
  adminArea?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  residenceStatus?: InputMaybe<Scalars['String']['input']>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  admin2?: InputMaybe<Scalars['ID']['input']>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
}>;


export type AllHouseholdsQuery = { __typename?: 'Query', allHouseholds?: { __typename?: 'HouseholdNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'HouseholdNodeEdge', cursor: string, node?: { __typename?: 'HouseholdNode', id: string, status?: string | null, unicefId?: string | null, hasDuplicates?: boolean | null, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, size?: number | null, address: string, village: string, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, residenceStatus?: string | null, totalCashReceived?: any | null, currency?: string | null, lastRegistrationDate: any, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, phoneNo: string, birthDate: any, relationship?: IndividualRelationship | null }, admin1?: { __typename?: 'AreaNode', id: string, name: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null> } | null };

export type AllHouseholdsForPopulationTableQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  familySize?: InputMaybe<Scalars['String']['input']>;
  headOfHouseholdFullNameIcontains?: InputMaybe<Scalars['String']['input']>;
  adminArea?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  residenceStatus?: InputMaybe<Scalars['String']['input']>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  admin2?: InputMaybe<Scalars['ID']['input']>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
  headOfHouseholdPhoneNoValid?: InputMaybe<Scalars['Boolean']['input']>;
  program?: InputMaybe<Scalars['ID']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AllHouseholdsForPopulationTableQuery = { __typename?: 'Query', allHouseholds?: { __typename?: 'HouseholdNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'HouseholdNodeEdge', cursor: string, node?: { __typename?: 'HouseholdNode', id: string, status?: string | null, unicefId?: string | null, hasDuplicates?: boolean | null, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, size?: number | null, residenceStatus?: string | null, totalCashReceived?: any | null, currency?: string | null, lastRegistrationDate: any, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string }, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, program?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null } | null> } | null };

export type AllIndividualsQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  fullNameContains?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  age?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  programs?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  householdId?: InputMaybe<Scalars['UUID']['input']>;
  excludedId?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  adminArea?: InputMaybe<Scalars['ID']['input']>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
  admin2?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  flags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
}>;


export type AllIndividualsQuery = { __typename?: 'Query', allIndividuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'IndividualNodeEdge', cursor: string, node?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, fullName: string, relationship?: IndividualRelationship | null, age?: number | null, sex: IndividualSex, lastRegistrationDate: any, phoneNo: string, birthDate: any, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, countryIso3?: string | null, number: string } | null } | null> }, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null } | null } | null> } | null };

export type AllIndividualsForPopulationTableQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  fullNameContains?: InputMaybe<Scalars['String']['input']>;
  sex?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  age?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  searchType?: InputMaybe<Scalars['String']['input']>;
  programs?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  lastRegistrationDate?: InputMaybe<Scalars['String']['input']>;
  householdId?: InputMaybe<Scalars['UUID']['input']>;
  excludedId?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  adminArea?: InputMaybe<Scalars['ID']['input']>;
  withdrawn?: InputMaybe<Scalars['Boolean']['input']>;
  admin2?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  flags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  program?: InputMaybe<Scalars['ID']['input']>;
  isActiveProgram?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AllIndividualsForPopulationTableQuery = { __typename?: 'Query', allIndividuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'IndividualNodeEdge', cursor: string, node?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, status?: string | null, sanctionListLastCheck?: any | null, fullName: string, relationship?: IndividualRelationship | null, age?: number | null, sex: IndividualSex, lastRegistrationDate: any, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null, program?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null } | null> } | null };

export type HouseholdQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type HouseholdQuery = { __typename?: 'Query', household?: { __typename?: 'HouseholdNode', activeIndividualsCount?: number | null, countryOrigin?: string | null, country?: string | null, zipCode?: string | null, femaleAgeGroup05Count?: number | null, femaleAgeGroup611Count?: number | null, femaleAgeGroup1217Count?: number | null, femaleAgeGroup1859Count?: number | null, femaleAgeGroup60Count?: number | null, pregnantCount?: number | null, maleAgeGroup05Count?: number | null, maleAgeGroup611Count?: number | null, maleAgeGroup1217Count?: number | null, maleAgeGroup1859Count?: number | null, maleAgeGroup60Count?: number | null, femaleAgeGroup05DisabledCount?: number | null, femaleAgeGroup611DisabledCount?: number | null, femaleAgeGroup1217DisabledCount?: number | null, femaleAgeGroup1859DisabledCount?: number | null, femaleAgeGroup60DisabledCount?: number | null, maleAgeGroup05DisabledCount?: number | null, maleAgeGroup611DisabledCount?: number | null, maleAgeGroup1217DisabledCount?: number | null, maleAgeGroup1859DisabledCount?: number | null, maleAgeGroup60DisabledCount?: number | null, fchildHoh?: boolean | null, childHoh?: boolean | null, start?: any | null, deviceid: string, orgNameEnumerator: string, returnee?: boolean | null, address: string, nameEnumerator: string, lastSyncAt?: any | null, consentSharing?: Array<string | null> | null, orgEnumerator: HouseholdOrgEnumerator, updatedAt: any, consent?: boolean | null, collectIndividualData: HouseholdCollectIndividualData, flexFields?: any | null, id: string, status?: string | null, adminUrl?: string | null, createdAt: any, residenceStatus?: string | null, maleChildrenCount?: number | null, femaleChildrenCount?: number | null, childrenDisabledCount?: number | null, size?: number | null, totalCashReceived?: any | null, totalCashReceivedUsd?: any | null, currency?: string | null, firstRegistrationDate: any, lastRegistrationDate: any, sanctionListPossibleMatch?: boolean | null, sanctionListConfirmedMatch?: boolean | null, hasDuplicates?: boolean | null, unicefId?: string | null, unhcrId: string, geopoint?: any | null, village: string, adminAreaTitle?: string | null, individuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, edges: Array<{ __typename?: 'IndividualNodeEdge', node?: { __typename?: 'IndividualNode', id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, email: string, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, countryIso3?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> }, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, status?: string | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null } | null } | null> } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> }, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, paymentrecordSet: { __typename?: 'PaymentRecordNodeConnection', edges: Array<{ __typename?: 'PaymentRecordNodeEdge', node?: { __typename?: 'PaymentRecordNode', id: string, fullName: string, parent?: { __typename?: 'CashPlanNode', id: string, totalPersonsCovered: number, totalDeliveredQuantity?: number | null, assistanceMeasurement: string, program: { __typename?: 'ProgramNode', id: string, name: string } } | null } | null } | null> }, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin3?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin4?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, givenName: string, familyName: string } } | null };

export type HouseholdChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type HouseholdChoiceDataQuery = { __typename?: 'Query', residenceStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, relationshipChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, roleChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, maritalStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, workStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, deduplicationBatchStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, deduplicationGoldenRecordStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, observedDisabilityChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, severityOfDisabilityChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, householdSearchTypesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type HouseholdFlexFieldsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type HouseholdFlexFieldsQuery = { __typename?: 'Query', household?: { __typename?: 'HouseholdNode', id: string, flexFields?: any | null } | null };

export type IndividualQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type IndividualQuery = { __typename?: 'Query', individual?: { __typename?: 'IndividualNode', givenName: string, familyName: string, estimatedBirthDate?: boolean | null, pregnant?: boolean | null, lastSyncAt?: any | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, disability: IndividualDisability, importedIndividualId?: any | null, commsDisability: string, firstRegistrationDate: any, whoAnswersAltPhone: string, memoryDisability: string, middleName: string, whoAnswersPhone: string, phoneNoAlternative: string, phoneNoAlternativeValid?: boolean | null, email: string, hearingDisability: string, observedDisability?: Array<string | null> | null, individualId: string, seeingDisability: string, physicalDisability: string, selfcareDisability: string, photo?: string | null, workStatus: string, enrolledInNutritionProgramme?: boolean | null, administrationOfRutf?: boolean | null, flexFields?: any | null, preferredLanguage?: string | null, paymentDeliveryPhoneNo?: string | null, id: string, age?: number | null, lastRegistrationDate: any, adminUrl?: string | null, createdAt: any, updatedAt: any, fullName: string, sex: IndividualSex, unicefId?: string | null, birthDate: any, maritalStatus: IndividualMaritalStatus, phoneNo: string, phoneNoValid?: boolean | null, sanctionListPossibleMatch: boolean, sanctionListConfirmedMatch: boolean, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, sanctionListLastCheck?: any | null, role?: string | null, relationship?: IndividualRelationship | null, status?: string | null, paymentChannels?: Array<{ __typename?: 'BankAccountInfoNode', id: string, bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null> | null, documents: { __typename?: 'DocumentNodeConnection', edges: Array<{ __typename?: 'DocumentNodeEdge', node?: { __typename?: 'DocumentNode', id: string, country?: string | null, photo?: string | null, documentNumber: string, countryIso3?: string | null, type: { __typename?: 'DocumentTypeNode', label: string, key: string } } | null } | null> }, household?: { __typename?: 'HouseholdNode', status?: string | null, id: string, residenceStatus?: string | null, address: string, village: string, zipCode?: string | null, geopoint?: any | null, country?: string | null, countryOrigin?: string | null, unicefId?: string | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', name: string, dataSource: RegistrationDataImportDataSource, importDate: any, importedBy?: { __typename?: 'UserNode', firstName: string, lastName: string, email: string, username: string } | null } | null, deliveredQuantities?: Array<{ __typename?: 'DeliveredQuantityNode', totalDeliveredQuantity?: any | null, currency?: string | null } | null> | null, adminArea?: { __typename?: 'AreaNode', id: string, name: string, level: number } | null, admin1?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string, level: number, pCode?: string | null } | null, programs: { __typename?: 'ProgramNodeConnection', edges: Array<{ __typename?: 'ProgramNodeEdge', node?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null> } } | null, headingHousehold?: { __typename?: 'HouseholdNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, givenName: string, familyName: string, fullName: string } } | null, householdsAndRoles: Array<{ __typename?: 'IndividualRoleInHouseholdNode', id: any, role?: IndividualRoleInHouseholdRole | null, household: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null } }>, bankAccountInfo?: { __typename?: 'BankAccountInfoNode', bankName: string, bankAccountNumber: string, accountHolderName: string, bankBranchName: string } | null, identities: { __typename?: 'IndividualIdentityNodeConnection', edges: Array<{ __typename?: 'IndividualIdentityNodeEdge', node?: { __typename?: 'IndividualIdentityNode', id: string, partner?: string | null, country?: string | null, number: string } | null } | null> } } | null };

export type IndividualChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type IndividualChoiceDataQuery = { __typename?: 'Query', flagChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, individualSearchTypesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type IndividualFlexFieldsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type IndividualFlexFieldsQuery = { __typename?: 'Query', individual?: { __typename?: 'IndividualNode', id: string, flexFields?: any | null } | null };

export type AllActiveProgramsQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  sector?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  businessArea: Scalars['String']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  numberOfHouseholdsWithTpInProgram?: InputMaybe<Scalars['String']['input']>;
  dataCollectingType?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllActiveProgramsQuery = { __typename?: 'Query', allActivePrograms?: { __typename?: 'ProgramNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'ProgramNodeEdge', cursor: string, node?: { __typename?: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, sector: ProgramSector, totalNumberOfHouseholds?: number | null, totalNumberOfHouseholdsWithTpInProgram?: number | null, budget?: any | null } | null } | null> } | null };

export type AllProgramsQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  sector?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  businessArea: Scalars['String']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  numberOfHouseholds?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  dataCollectingType?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllProgramsQuery = { __typename?: 'Query', allPrograms?: { __typename?: 'ProgramNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'ProgramNodeEdge', cursor: string, node?: { __typename?: 'ProgramNode', id: string, name: string, startDate: any, endDate: any, status: ProgramStatus, caId?: string | null, description: string, budget?: any | null, frequencyOfPayments: ProgramFrequencyOfPayments, populationGoal: number, sector: ProgramSector, totalNumberOfHouseholds?: number | null, totalNumberOfHouseholdsWithTpInProgram?: number | null } | null } | null> } | null };

export type AllProgramsForChoicesQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  sector?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  businessArea: Scalars['String']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  numberOfHouseholds?: InputMaybe<Scalars['String']['input']>;
  budget?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllProgramsForChoicesQuery = { __typename?: 'Query', allPrograms?: { __typename?: 'ProgramNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'ProgramNodeEdge', cursor: string, node?: { __typename?: 'ProgramNode', id: string, name: string, status: ProgramStatus, dataCollectingType?: { __typename?: 'DataCollectingTypeNode', id: string, code: string, type?: DataCollectingTypeType | null, label: string, active: boolean, individualFiltersAvailable: boolean, householdFiltersAvailable: boolean, description: string } | null } | null } | null> } | null };

export type ProgramQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ProgramQuery = { __typename?: 'Query', program?: { __typename?: 'ProgramNode', id: string, name: string, programmeCode?: string | null, startDate: any, endDate: any, status: ProgramStatus, caId?: string | null, caHashId?: string | null, description: string, budget?: any | null, frequencyOfPayments: ProgramFrequencyOfPayments, cashPlus: boolean, populationGoal: number, scope?: ProgramScope | null, sector: ProgramSector, totalNumberOfHouseholds?: number | null, totalNumberOfHouseholdsWithTpInProgram?: number | null, administrativeAreasOfImplementation: string, isSocialWorkerProgram?: boolean | null, version: any, adminUrl?: string | null, dataCollectingType?: { __typename?: 'DataCollectingTypeNode', id: string, code: string, label: string, active: boolean, individualFiltersAvailable: boolean, householdFiltersAvailable: boolean, description: string } | null, partners?: Array<{ __typename?: 'PartnerNodeForProgram', id?: string | null, name?: string | null, areaAccess?: string | null, adminAreas?: Array<{ __typename?: 'AreaGroupNode', ids?: Array<string | null> | null, level?: number | null, totalCount?: number | null } | null> | null } | null> | null } | null };

export type ProgrammeChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type ProgrammeChoiceDataQuery = { __typename?: 'Query', programFrequencyOfPaymentsChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, programScopeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, programSectorChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, programStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, dataCollectingTypeChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type UserPartnerChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type UserPartnerChoicesQuery = { __typename?: 'Query', userPartnerChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllImportedHouseholdsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllImportedHouseholdsQuery = { __typename?: 'Query', allImportedHouseholds?: { __typename?: 'ImportedHouseholdNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'ImportedHouseholdNodeEdge', cursor: string, node?: { __typename?: 'ImportedHouseholdNode', id: string, importId?: string | null, size?: number | null, admin1: string, admin1Title: string, admin2: string, admin2Title: string, flexFields?: any | null, deviceid: string, start?: any | null, koboAssetId: string, rowId?: number | null, firstRegistrationDate: any, lastRegistrationDate: any, hasDuplicates?: boolean | null, fchildHoh?: boolean | null, childHoh?: boolean | null, collectIndividualData: ImportedHouseholdCollectIndividualData, headOfHousehold?: { __typename?: 'ImportedIndividualNode', id: string, fullName: string } | null } | null } | null> } | null };

export type AllImportedIndividualsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  duplicatesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllImportedIndividualsQuery = { __typename?: 'Query', allImportedIndividuals?: { __typename?: 'ImportedIndividualNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'ImportedIndividualNodeEdge', cursor: string, node?: { __typename?: 'ImportedIndividualNode', id: string, importId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: ImportedIndividualSex, role?: string | null, relationship?: string | null, deduplicationBatchStatus?: ImportedIndividualDeduplicationBatchStatus | null, deduplicationGoldenRecordStatus?: ImportedIndividualDeduplicationGoldenRecordStatus | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null } } | null } | null> } | null };

export type AllKoboProjectsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  businessAreaSlug: Scalars['String']['input'];
}>;


export type AllKoboProjectsQuery = { __typename?: 'Query', allKoboProjects?: { __typename?: 'KoboAssetObjectConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'KoboAssetObjectEdge', cursor: string, node?: { __typename?: 'KoboAssetObject', name?: string | null, id?: string | null } | null } | null> } | null };

export type AllMergedHouseholdsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllMergedHouseholdsQuery = { __typename?: 'Query', allMergedHouseholds?: { __typename?: 'HouseholdNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'HouseholdNodeEdge', cursor: string, node?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null, firstRegistrationDate: any, hasDuplicates?: boolean | null, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string }, admin1?: { __typename?: 'AreaNode', id: string, name: string } | null, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null } | null> } | null };

export type AllMergedIndividualsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  rdiId?: InputMaybe<Scalars['String']['input']>;
  household?: InputMaybe<Scalars['ID']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  duplicatesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllMergedIndividualsQuery = { __typename?: 'Query', allMergedIndividuals?: { __typename?: 'IndividualNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'IndividualNodeEdge', cursor: string, node?: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: IndividualSex, role?: string | null, relationship?: IndividualRelationship | null, deduplicationBatchStatus: IndividualDeduplicationBatchStatus, deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, registrationDataImport?: { __typename?: 'RegistrationDataImportNode', id: string, datahubId?: any | null } | null } | null } | null> } | null };

export type AllRegistrationDataImportsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  importedBy?: InputMaybe<Scalars['UUID']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  importDate?: InputMaybe<Scalars['Date']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  importDateRange?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
}>;


export type AllRegistrationDataImportsQuery = { __typename?: 'Query', allRegistrationDataImports?: { __typename?: 'RegistrationDataImportNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'RegistrationDataImportNodeEdge', cursor: string, node?: { __typename?: 'RegistrationDataImportNode', id: string, createdAt: any, name: string, status: RegistrationDataImportStatus, erased: boolean, importDate: any, dataSource: RegistrationDataImportDataSource, numberOfHouseholds: number, numberOfIndividuals: number, refuseReason?: string | null, totalHouseholdsCountWithValidPhoneNo?: number | null, adminUrl?: string | null, importedBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, program?: { __typename?: 'ProgramNode', id: string, name: string, startDate: any, endDate: any, status: ProgramStatus } | null } | null } | null> } | null };

export type ImportedHouseholdQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ImportedHouseholdQuery = { __typename?: 'Query', importedHousehold?: { __typename?: 'ImportedHouseholdNode', residenceStatus: ImportedHouseholdResidenceStatus, country?: string | null, countryOrigin?: string | null, id: string, importId?: string | null, size?: number | null, admin1: string, admin1Title: string, admin2: string, admin2Title: string, flexFields?: any | null, deviceid: string, start?: any | null, koboAssetId: string, rowId?: number | null, firstRegistrationDate: any, lastRegistrationDate: any, hasDuplicates?: boolean | null, fchildHoh?: boolean | null, childHoh?: boolean | null, collectIndividualData: ImportedHouseholdCollectIndividualData, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null, name: string }, individuals: { __typename?: 'ImportedIndividualNodeConnection', edges: Array<{ __typename?: 'ImportedIndividualNodeEdge', node?: { __typename?: 'ImportedIndividualNode', id: string, importId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: ImportedIndividualSex, role?: string | null, relationship?: string | null, deduplicationBatchStatus?: ImportedIndividualDeduplicationBatchStatus | null, deduplicationGoldenRecordStatus?: ImportedIndividualDeduplicationGoldenRecordStatus | null, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null } } | null } | null> }, headOfHousehold?: { __typename?: 'ImportedIndividualNode', id: string, fullName: string } | null } | null };

export type ImportedIndividualQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ImportedIndividualQuery = { __typename?: 'Query', importedIndividual?: { __typename?: 'ImportedIndividualNode', photo: string, givenName: string, familyName: string, middleName: string, estimatedBirthDate?: boolean | null, maritalStatus: ImportedIndividualMaritalStatus, workStatus: string, pregnant?: boolean | null, flexFields?: any | null, observedDisability?: Array<string | null> | null, seeingDisability: string, hearingDisability: string, physicalDisability: string, memoryDisability: string, selfcareDisability: string, commsDisability: string, disability: ImportedIndividualDisability, role?: string | null, relationship?: string | null, phoneNo: string, phoneNoAlternative: string, phoneNoValid?: boolean | null, phoneNoAlternativeValid?: boolean | null, preferredLanguage?: string | null, email?: string | null, id: string, importId?: string | null, age?: number | null, fullName: string, birthDate: any, sex: ImportedIndividualSex, deduplicationBatchStatus?: ImportedIndividualDeduplicationBatchStatus | null, deduplicationGoldenRecordStatus?: ImportedIndividualDeduplicationGoldenRecordStatus | null, documents: { __typename?: 'ImportedDocumentNodeConnection', edges: Array<{ __typename?: 'ImportedDocumentNodeEdge', node?: { __typename?: 'ImportedDocumentNode', id: string, country?: string | null, documentNumber: string, photo?: string | null, type: { __typename?: 'ImportedDocumentTypeNode', label: string, key: string } } | null } | null> }, identities: { __typename?: 'ImportedIndividualIdentityNodeConnection', edges: Array<{ __typename?: 'ImportedIndividualIdentityNodeEdge', node?: { __typename?: 'ImportedIndividualIdentityNode', id: string, documentNumber: string, partner?: string | null, country?: string | null } | null } | null> }, household?: { __typename?: 'ImportedHouseholdNode', id: string, importId?: string | null, admin1: string, admin2: string, address: string } | null, registrationDataImport: { __typename?: 'RegistrationDataImportDatahubNode', id: string, hctId?: any | null, name: string }, deduplicationGoldenRecordResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null, deduplicationBatchResults?: Array<{ __typename?: 'DeduplicationResultNode', hitId?: string | null, fullName?: string | null, score?: number | null, proximityToScore?: number | null, age?: number | null, location?: string | null } | null> | null } | null };

export type ImportedIndividualFlexFieldsQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ImportedIndividualFlexFieldsQuery = { __typename?: 'Query', importedIndividual?: { __typename?: 'ImportedIndividualNode', id: string, flexFields?: any | null } | null };

export type KoboImportDataQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type KoboImportDataQuery = { __typename?: 'Query', koboImportData?: { __typename?: 'KoboImportDataNode', id: string, status: ImportDataStatus, numberOfIndividuals?: number | null, numberOfHouseholds?: number | null, error: string, koboValidationErrors?: Array<{ __typename?: 'KoboErrorNode', header?: string | null, message?: string | null } | null> | null } | null };

export type RegistrationChoicesQueryVariables = Exact<{ [key: string]: never; }>;


export type RegistrationChoicesQuery = { __typename?: 'Query', registrationDataStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type RegistrationDataImportQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RegistrationDataImportQuery = { __typename?: 'Query', registrationDataImport?: { __typename?: 'RegistrationDataImportNode', numberOfIndividuals: number, datahubId?: any | null, errorMessage: string, id: string, createdAt: any, name: string, status: RegistrationDataImportStatus, erased: boolean, importDate: any, dataSource: RegistrationDataImportDataSource, numberOfHouseholds: number, refuseReason?: string | null, totalHouseholdsCountWithValidPhoneNo?: number | null, adminUrl?: string | null, batchDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, batchPossibleDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, batchUniqueCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordUniqueCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, goldenRecordPossibleDuplicatesCountAndPercentage?: { __typename?: 'CountAndPercentageNode', count?: number | null, percentage?: number | null } | null, importedBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null, program?: { __typename?: 'ProgramNode', id: string, name: string, startDate: any, endDate: any, status: ProgramStatus } | null } | null };

export type XlsxImportDataQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type XlsxImportDataQuery = { __typename?: 'Query', importData?: { __typename?: 'ImportDataNode', id: string, status: ImportDataStatus, numberOfIndividuals?: number | null, numberOfHouseholds?: number | null, error: string, xlsxValidationErrors?: Array<{ __typename?: 'XlsxRowErrorNode', rowNumber?: number | null, header?: string | null, message?: string | null } | null> | null } | null };

export type AllReportsQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  businessArea: Scalars['String']['input'];
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  reportType?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
  createdBy?: InputMaybe<Scalars['ID']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllReportsQuery = { __typename?: 'Query', allReports?: { __typename?: 'ReportNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null }, edges: Array<{ __typename?: 'ReportNodeEdge', cursor: string, node?: { __typename?: 'ReportNode', id: string, reportType: number, dateFrom: any, dateTo: any, status: number, createdAt: any, updatedAt: any, fileUrl?: string | null, numberOfRecords?: number | null, createdBy: { __typename?: 'UserNode', firstName: string, lastName: string } } | null } | null> } | null };

export type ReportQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ReportQuery = { __typename?: 'Query', report?: { __typename?: 'ReportNode', id: string, status: number, reportType: number, createdAt: any, updatedAt: any, dateFrom: any, dateTo: any, fileUrl?: string | null, numberOfRecords?: number | null, createdBy: { __typename?: 'UserNode', firstName: string, lastName: string }, adminArea2?: { __typename?: 'AreaNodeConnection', edges: Array<{ __typename?: 'AreaNodeEdge', node?: { __typename?: 'AreaNode', name: string } | null } | null> } | null, adminArea1?: { __typename?: 'AreaNodeConnection', edges: Array<{ __typename?: 'AreaNodeEdge', node?: { __typename?: 'AreaNode', name: string } | null } | null> } | null, program?: { __typename?: 'ProgramNode', name: string } | null } | null };

export type ReportChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type ReportChoiceDataQuery = { __typename?: 'Query', reportStatusChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null, reportTypesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllChartsQueryVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
  year: Scalars['Int']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllChartsQuery = { __typename?: 'Query', chartProgrammesBySector?: { __typename?: 'ChartDetailedDatasetsNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DetailedDatasetsNode', label?: string | null, data?: Array<number | null> | null } | null> | null } | null, chartPaymentVerification?: { __typename?: 'ChartPaymentVerification', labels?: Array<string | null> | null, households?: number | null, averageSampleSize?: number | null, datasets?: Array<{ __typename?: '_DetailedDatasetsNode', label?: string | null, data?: Array<number | null> | null } | null> | null } | null, chartVolumeByDeliveryMechanism?: { __typename?: 'ChartDatasetNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DatasetsNode', data?: Array<number | null> | null } | null> | null } | null, chartPayment?: { __typename?: 'ChartDatasetNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DatasetsNode', data?: Array<number | null> | null } | null> | null } | null, chartGrievances?: { __typename?: 'ChartGrievanceTicketsNode', labels?: Array<string | null> | null, totalNumberOfGrievances?: number | null, totalNumberOfFeedback?: number | null, totalNumberOfOpenSensitive?: number | null, datasets?: Array<{ __typename?: '_DatasetsNode', data?: Array<number | null> | null } | null> | null } | null, sectionHouseholdsReached?: { __typename?: 'SectionTotalNode', total?: number | null } | null, sectionIndividualsReached?: { __typename?: 'SectionTotalNode', total?: number | null } | null, sectionChildReached?: { __typename?: 'SectionTotalNode', total?: number | null } | null, chartIndividualsReachedByAgeAndGender?: { __typename?: 'ChartDatasetNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DatasetsNode', data?: Array<number | null> | null } | null> | null } | null, chartIndividualsWithDisabilityReachedByAge?: { __typename?: 'ChartDetailedDatasetsNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DetailedDatasetsNode', data?: Array<number | null> | null, label?: string | null } | null> | null } | null, sectionTotalTransferred?: { __typename?: 'SectionTotalNode', total?: number | null } | null, chartTotalTransferredByMonth?: { __typename?: 'ChartDetailedDatasetsNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DetailedDatasetsNode', data?: Array<number | null> | null, label?: string | null } | null> | null } | null };

export type CountryChartsQueryVariables = Exact<{
  businessAreaSlug: Scalars['String']['input'];
  year: Scalars['Int']['input'];
  program?: InputMaybe<Scalars['String']['input']>;
  administrativeArea?: InputMaybe<Scalars['String']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type CountryChartsQuery = { __typename?: 'Query', tableTotalCashTransferredByAdministrativeArea?: { __typename?: 'TableTotalCashTransferred', data?: Array<{ __typename?: '_TableTotalCashTransferredDataNode', id?: string | null, admin2?: string | null, totalCashTransferred?: number | null, totalHouseholds?: number | null } | null> | null } | null };

export type DashboardReportChoiceDataQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
}>;


export type DashboardReportChoiceDataQuery = { __typename?: 'Query', dashboardReportTypesChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type DashboardYearsChoiceDataQueryVariables = Exact<{
  businessArea: Scalars['String']['input'];
}>;


export type DashboardYearsChoiceDataQuery = { __typename?: 'Query', dashboardYearsChoices?: Array<string | null> | null };

export type GlobalAreaChartsQueryVariables = Exact<{
  year: Scalars['Int']['input'];
}>;


export type GlobalAreaChartsQuery = { __typename?: 'Query', chartTotalTransferredCashByCountry?: { __typename?: 'ChartDetailedDatasetsNode', labels?: Array<string | null> | null, datasets?: Array<{ __typename?: '_DetailedDatasetsNode', data?: Array<number | null> | null, label?: string | null } | null> | null } | null };

export type LanguageAutocompleteQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
}>;


export type LanguageAutocompleteQuery = { __typename?: 'Query', allLanguages?: { __typename?: 'LanguageObjectConnection', edges: Array<{ __typename?: 'LanguageObjectEdge', cursor: string, node?: { __typename?: 'LanguageObject', english?: string | null, code?: string | null } | null } | null> } | null };

export type RdiAutocompleteQueryVariables = Exact<{
  businessArea?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type RdiAutocompleteQuery = { __typename?: 'Query', allRegistrationDataImports?: { __typename?: 'RegistrationDataImportNodeConnection', edges: Array<{ __typename?: 'RegistrationDataImportNodeEdge', cursor: string, node?: { __typename?: 'RegistrationDataImportNode', id: string, name: string } | null } | null> } | null };

export type AllSurveysQueryVariables = Exact<{
  offset?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  program: Scalars['ID']['input'];
  targetPopulation?: InputMaybe<Scalars['ID']['input']>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllSurveysQuery = { __typename?: 'Query', allSurveys?: { __typename?: 'SurveyNodeConnection', totalCount?: number | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'SurveyNodeEdge', cursor: string, node?: { __typename?: 'SurveyNode', id: string, unicefId?: string | null, title: string, category: SurveyCategory, numberOfRecipients: number, createdAt: any, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, email: string } | null } | null } | null> } | null };

export type SurveyAvailableFlowsQueryVariables = Exact<{ [key: string]: never; }>;


export type SurveyAvailableFlowsQuery = { __typename?: 'Query', surveyAvailableFlows?: Array<{ __typename?: 'RapidProFlowNode', id?: string | null, name?: string | null } | null> | null };

export type RecipientsQueryVariables = Exact<{
  offset?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  survey: Scalars['String']['input'];
  orderBy?: InputMaybe<Scalars['String']['input']>;
}>;


export type RecipientsQuery = { __typename?: 'Query', recipients?: { __typename?: 'RecipientNodeConnection', totalCount?: number | null, edgeCount?: number | null, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename?: 'RecipientNodeEdge', cursor: string, node?: { __typename?: 'RecipientNode', id: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, fullName: string, household?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null, status?: string | null, residenceStatus?: string | null, lastRegistrationDate: any, admin2?: { __typename?: 'AreaNode', id: string, name: string } | null } | null } } | null } | null> } | null };

export type SurveyQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SurveyQuery = { __typename?: 'Query', survey?: { __typename?: 'SurveyNode', id: string, unicefId?: string | null, category: SurveyCategory, title: string, adminUrl?: string | null, createdAt: any, body: string, rapidProUrl?: string | null, sampleFilePath?: string | null, hasValidSampleFile?: boolean | null, createdBy?: { __typename?: 'UserNode', id: string, firstName: string, lastName: string, username: string, email: string } | null, targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string } | null, program?: { __typename?: 'ProgramNode', id: string, name: string } | null } | null };

export type SurveysChoiceDataQueryVariables = Exact<{ [key: string]: never; }>;


export type SurveysChoiceDataQuery = { __typename?: 'Query', surveyCategoryChoices?: Array<{ __typename?: 'ChoiceObject', name?: string | null, value?: string | null } | null> | null };

export type AllActiveTargetPopulationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountWithValidPhoneNoMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountWithValidPhoneNoMax?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  statusNot?: InputMaybe<Scalars['String']['input']>;
}>;


export type AllActiveTargetPopulationsQuery = { __typename?: 'Query', allActiveTargetPopulations?: { __typename?: 'TargetPopulationNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'TargetPopulationNodeEdge', cursor: string, node?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, totalHouseholdsCount?: number | null, totalHouseholdsCountWithValidPhoneNo?: number | null, createdAt: any, updatedAt: any, program?: { __typename?: 'ProgramNode', id: string, name: string } | null, createdBy?: { __typename?: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null } | null } | null> } | null };

export type AllFieldsAttributesQueryVariables = Exact<{ [key: string]: never; }>;


export type AllFieldsAttributesQuery = { __typename?: 'Query', allFieldsAttributes?: Array<{ __typename?: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, associatedWith?: string | null, isFlexField?: boolean | null } | null> | null };

export type AllSteficonRulesQueryVariables = Exact<{
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  deprecated?: InputMaybe<Scalars['Boolean']['input']>;
  type: Scalars['String']['input'];
}>;


export type AllSteficonRulesQuery = { __typename?: 'Query', allSteficonRules?: { __typename?: 'SteficonRuleNodeConnection', edges: Array<{ __typename?: 'SteficonRuleNodeEdge', node?: { __typename?: 'SteficonRuleNode', id: string, name: string } | null } | null> } | null };

export type AllTargetPopulationForChoicesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  numberOfHouseholdsMin?: InputMaybe<Scalars['Int']['input']>;
  numberOfHouseholdsMax?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
}>;


export type AllTargetPopulationForChoicesQuery = { __typename?: 'Query', allTargetPopulation?: { __typename?: 'TargetPopulationNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'TargetPopulationNodeEdge', cursor: string, node?: { __typename?: 'TargetPopulationNode', id: string, name: string } | null } | null> } | null };

export type AllTargetPopulationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalHouseholdsCountMin?: InputMaybe<Scalars['Int']['input']>;
  totalHouseholdsCountMax?: InputMaybe<Scalars['Int']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
  program?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>> | InputMaybe<Scalars['ID']['input']>>;
  createdAtRange?: InputMaybe<Scalars['String']['input']>;
  paymentPlanApplicable?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AllTargetPopulationsQuery = { __typename?: 'Query', allTargetPopulation?: { __typename?: 'TargetPopulationNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'TargetPopulationNodeEdge', cursor: string, node?: { __typename: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, createdAt: any, updatedAt: any, totalHouseholdsCount?: number | null, totalHouseholdsCountWithValidPhoneNo?: number | null, totalIndividualsCount?: number | null, program?: { __typename: 'ProgramNode', id: string, name: string } | null, createdBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null } | null } | null> } | null };

export type TargetPopulationQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type TargetPopulationQuery = { __typename?: 'Query', targetPopulation?: { __typename?: 'TargetPopulationNode', id: string, name: string, status: TargetPopulationStatus, adminUrl?: string | null, buildStatus: TargetPopulationBuildStatus, totalHouseholdsCount?: number | null, totalIndividualsCount?: number | null, childMaleCount?: number | null, childFemaleCount?: number | null, adultMaleCount?: number | null, adultFemaleCount?: number | null, caHashId?: string | null, excludedIds: string, exclusionReason: string, vulnerabilityScoreMin?: number | null, vulnerabilityScoreMax?: number | null, changeDate?: any | null, finalizedAt?: any | null, steficonRule?: { __typename: 'RuleCommitNode', id: string, rule?: { __typename: 'SteficonRuleNode', id: string, name: string } | null } | null, finalizedBy?: { __typename: 'UserNode', id: string, firstName: string, lastName: string } | null, program?: { __typename: 'ProgramNode', id: string, name: string, status: ProgramStatus, startDate: any, endDate: any, isSocialWorkerProgram?: boolean | null } | null, createdBy?: { __typename: 'UserNode', id: string, email: string, firstName: string, lastName: string } | null, targetingCriteria?: { __typename: 'TargetingCriteriaNode', id: any, flagExcludeIfActiveAdjudicationTicket: boolean, flagExcludeIfOnSanctionList: boolean, rules?: Array<{ __typename: 'TargetingCriteriaRuleNode', id: any, individualsFiltersBlocks?: Array<{ __typename: 'TargetingIndividualRuleFilterBlockNode', individualBlockFilters?: Array<{ __typename: 'TargetingIndividualBlockRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null, filters?: Array<{ __typename: 'TargetingCriteriaRuleFilterNode', id: any, fieldName: string, isFlexField: boolean, arguments?: Array<any | null> | null, comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod, fieldAttribute?: { __typename: 'FieldAttributeNode', id?: string | null, name?: string | null, labelEn?: string | null, type?: string | null, choices?: Array<{ __typename?: 'CoreFieldChoiceObject', value?: string | null, labelEn?: string | null } | null> | null } | null } | null> | null } | null> | null } | null } | null };

export type TargetPopulationHouseholdsQueryVariables = Exact<{
  targetPopulation: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Scalars['String']['input']>;
  businessArea?: InputMaybe<Scalars['String']['input']>;
}>;


export type TargetPopulationHouseholdsQuery = { __typename?: 'Query', targetPopulationHouseholds?: { __typename?: 'HouseholdNodeConnection', totalCount?: number | null, edgeCount?: number | null, edges: Array<{ __typename?: 'HouseholdNodeEdge', cursor: string, node?: { __typename?: 'HouseholdNode', id: string, unicefId?: string | null, size?: number | null, updatedAt: any, address: string, headOfHousehold: { __typename?: 'IndividualNode', id: string, unicefId?: string | null, givenName: string, familyName: string, fullName: string }, adminArea?: { __typename?: 'AreaNode', id: string, name: string } | null, selection?: { __typename?: 'HouseholdSelectionNode', vulnerabilityScore?: number | null } | null } | null } | null> } | null };

export const IndividualMinimalFragmentDoc = gql`
    fragment individualMinimal on IndividualNode {
  id
  age
  lastRegistrationDate
  adminUrl
  createdAt
  updatedAt
  fullName
  sex
  unicefId
  birthDate
  maritalStatus
  phoneNo
  phoneNoValid
  email
  sanctionListPossibleMatch
  sanctionListConfirmedMatch
  deduplicationGoldenRecordStatus
  sanctionListLastCheck
  role
  relationship
  status
  documents {
    edges {
      node {
        id
        country
        countryIso3
        documentNumber
        photo
        type {
          label
          key
        }
      }
    }
  }
  identities {
    edges {
      node {
        id
        partner
        country
        number
      }
    }
  }
  household {
    id
    unicefId
    status
    admin1 {
      id
      name
      level
      pCode
    }
    admin2 {
      id
      name
      level
      pCode
    }
    programs {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
    `;
export const IndividualDetailedFragmentDoc = gql`
    fragment individualDetailed on IndividualNode {
  ...individualMinimal
  givenName
  familyName
  estimatedBirthDate
  pregnant
  lastSyncAt
  deduplicationBatchStatus
  disability
  importedIndividualId
  commsDisability
  firstRegistrationDate
  whoAnswersAltPhone
  memoryDisability
  middleName
  whoAnswersPhone
  phoneNoAlternative
  phoneNoAlternativeValid
  email
  hearingDisability
  observedDisability
  individualId
  seeingDisability
  physicalDisability
  selfcareDisability
  disability
  photo
  workStatus
  paymentChannels {
    id
    bankName
    bankAccountNumber
    accountHolderName
    bankBranchName
  }
  documents {
    edges {
      node {
        id
        country
        photo
        type {
          label
          key
        }
        documentNumber
      }
    }
  }
  enrolledInNutritionProgramme
  administrationOfRutf
  household {
    registrationDataImport {
      name
      dataSource
      importDate
      importedBy {
        firstName
        lastName
        email
        username
      }
    }
    status
    id
    residenceStatus
    address
    village
    zipCode
    geopoint
    country
    countryOrigin
    deliveredQuantities {
      totalDeliveredQuantity
      currency
    }
    adminArea {
      id
      name
      level
    }
  }
  headingHousehold {
    id
    headOfHousehold {
      id
      givenName
      familyName
      fullName
    }
  }
  flexFields
  householdsAndRoles {
    id
    role
    household {
      id
      unicefId
    }
  }
  bankAccountInfo {
    bankName
    bankAccountNumber
    accountHolderName
    bankBranchName
  }
  preferredLanguage
  paymentDeliveryPhoneNo
}
    ${IndividualMinimalFragmentDoc}`;
export const HouseholdMinimalFragmentDoc = gql`
    fragment householdMinimal on HouseholdNode {
  id
  status
  adminUrl
  createdAt
  residenceStatus
  maleChildrenCount
  femaleChildrenCount
  childrenDisabledCount
  size
  totalCashReceived
  totalCashReceivedUsd
  currency
  firstRegistrationDate
  lastRegistrationDate
  status
  sanctionListPossibleMatch
  sanctionListConfirmedMatch
  hasDuplicates
  unicefId
  flexFields
  unhcrId
  geopoint
  village
  adminAreaTitle
  admin1 {
    id
    name
    level
    pCode
  }
  admin2 {
    id
    name
    level
    pCode
  }
  admin3 {
    id
    name
    level
    pCode
  }
  admin4 {
    id
    name
    level
    pCode
  }
  headOfHousehold {
    id
    fullName
    givenName
    familyName
  }
  address
  individuals {
    totalCount
  }
  programs {
    edges {
      node {
        id
        name
      }
    }
  }
}
    `;
export const HouseholdDetailedFragmentDoc = gql`
    fragment householdDetailed on HouseholdNode {
  ...householdMinimal
  activeIndividualsCount
  countryOrigin
  country
  zipCode
  femaleAgeGroup05Count
  femaleAgeGroup611Count
  femaleAgeGroup1217Count
  femaleAgeGroup1859Count
  femaleAgeGroup60Count
  pregnantCount
  maleAgeGroup05Count
  maleAgeGroup611Count
  maleAgeGroup1217Count
  maleAgeGroup1859Count
  maleAgeGroup60Count
  femaleAgeGroup05DisabledCount
  femaleAgeGroup611DisabledCount
  femaleAgeGroup1217DisabledCount
  femaleAgeGroup1859DisabledCount
  femaleAgeGroup60DisabledCount
  maleAgeGroup05DisabledCount
  maleAgeGroup611DisabledCount
  maleAgeGroup1217DisabledCount
  maleAgeGroup1859DisabledCount
  maleAgeGroup60DisabledCount
  fchildHoh
  childHoh
  start
  deviceid
  orgNameEnumerator
  returnee
  address
  nameEnumerator
  lastSyncAt
  consentSharing
  orgEnumerator
  updatedAt
  consent
  collectIndividualData
  individuals {
    totalCount
    edges {
      node {
        ...individualMinimal
      }
    }
  }
  programs {
    edges {
      node {
        id
        name
      }
    }
  }
  registrationDataImport {
    name
    dataSource
    importDate
    importedBy {
      firstName
      lastName
      email
      username
    }
  }
  paymentrecordSet {
    edges {
      node {
        id
        fullName
        parent {
          id
          totalPersonsCovered
          program {
            id
            name
          }
          totalDeliveredQuantity
          assistanceMeasurement
        }
      }
    }
  }
  flexFields
  deliveredQuantities {
    totalDeliveredQuantity
    currency
  }
}
    ${HouseholdMinimalFragmentDoc}
${IndividualMinimalFragmentDoc}`;
export const GrievanceTicketDetailedFragmentDoc = gql`
    fragment grievanceTicketDetailed on GrievanceTicketNode {
  id
  unicefId
  status
  category
  consent
  partner {
    id
    name
  }
  businessArea {
    postponeDeduplication
  }
  createdBy {
    id
    firstName
    lastName
    email
  }
  createdAt
  updatedAt
  description
  language
  admin
  admin2 {
    id
    name
    pCode
  }
  area
  assignedTo {
    id
    firstName
    lastName
    email
  }
  adminUrl
  individual {
    ...individualDetailed
    householdsAndRoles {
      individual {
        id
        unicefId
        fullName
      }
      household {
        id
        unicefId
      }
      id
      role
    }
  }
  household {
    ...householdDetailed
  }
  paymentRecord {
    id
    caId
    deliveredQuantity
    entitlementQuantity
    objType
    parent {
      id
      unicefId
      objType
    }
    verification {
      id
    }
  }
  relatedTickets {
    id
    unicefId
    status
    household {
      id
      unicefId
    }
  }
  linkedTickets {
    id
    unicefId
    category
    status
    household {
      id
      unicefId
    }
  }
  existingTickets {
    id
    category
    unicefId
    status
    household {
      id
      unicefId
    }
  }
  addIndividualTicketDetails {
    id
    individualData
    approveStatus
    household {
      id
      unicefId
    }
  }
  individualDataUpdateTicketDetails {
    id
    individual {
      ...individualDetailed
    }
    individualData
    roleReassignData
  }
  householdDataUpdateTicketDetails {
    id
    household {
      ...householdDetailed
    }
    householdData
  }
  deleteIndividualTicketDetails {
    id
    roleReassignData
    approveStatus
  }
  deleteHouseholdTicketDetails {
    id
    approveStatus
    reasonHousehold {
      id
      unicefId
    }
  }
  systemFlaggingTicketDetails {
    id
    approveStatus
    roleReassignData
    goldenRecordsIndividual {
      id
      fullName
      birthDate
      lastRegistrationDate
      documents {
        edges {
          node {
            id
            type {
              label
              key
            }
            documentNumber
          }
        }
      }
    }
    sanctionListIndividual {
      id
      fullName
      referenceNumber
      datesOfBirth {
        edges {
          node {
            id
            date
          }
        }
      }
      documents {
        edges {
          node {
            id
            documentNumber
            typeOfDocument
          }
        }
      }
    }
  }
  paymentVerificationTicketDetails {
    id
    newStatus
    oldReceivedAmount
    newReceivedAmount
    approveStatus
    paymentVerificationStatus
    hasMultiplePaymentVerifications
    paymentVerification {
      id
      receivedAmount
    }
    paymentVerifications {
      edges {
        node {
          id
        }
      }
    }
  }
  needsAdjudicationTicketDetails {
    id
    hasDuplicatedDocument
    extraData {
      goldenRecords {
        hitId
        proximityToScore
        score
      }
      possibleDuplicate {
        hitId
        proximityToScore
        score
      }
    }
    goldenRecordsIndividual {
      id
      unicefId
      documents {
        edges {
          node {
            id
            country
            type {
              label
              key
            }
            documentNumber
            photo
          }
        }
      }
      household {
        id
        unicefId
        village
        admin2 {
          id
          name
        }
      }
      fullName
      birthDate
      lastRegistrationDate
      sex
      deduplicationGoldenRecordResults {
        hitId
        proximityToScore
        score
      }
    }
    possibleDuplicate {
      id
      documents {
        edges {
          node {
            id
            country
            type {
              label
              key
            }
            documentNumber
            photo
          }
        }
      }
      unicefId
      lastRegistrationDate
      household {
        unicefId
        id
        village
        admin2 {
          id
          name
        }
      }
      fullName
      birthDate
      sex
      deduplicationGoldenRecordResults {
        hitId
        proximityToScore
        score
      }
    }
    isMultipleDuplicatesVersion
    possibleDuplicates {
      id
      documents {
        edges {
          node {
            id
            country
            type {
              label
              key
            }
            documentNumber
            photo
          }
        }
      }
      unicefId
      lastRegistrationDate
      household {
        unicefId
        id
        village
        admin2 {
          id
          name
        }
      }
      fullName
      birthDate
      sex
      deduplicationGoldenRecordResults {
        hitId
        proximityToScore
        score
      }
    }
    selectedIndividual {
      ...individualDetailed
      household {
        ...householdDetailed
      }
      householdsAndRoles {
        individual {
          id
          unicefId
          fullName
        }
        household {
          id
          unicefId
        }
        id
        role
      }
    }
    selectedIndividuals {
      ...individualDetailed
      household {
        ...householdDetailed
      }
      householdsAndRoles {
        individual {
          id
          unicefId
          fullName
        }
        household {
          id
          unicefId
        }
        id
        role
      }
    }
    roleReassignData
  }
  issueType
  ticketNotes {
    edges {
      node {
        id
        createdAt
        updatedAt
        description
        createdBy {
          id
          firstName
          lastName
          email
        }
      }
    }
  }
  priority
  urgency
  programs {
    name
    id
  }
  comments
  documentation {
    id
    createdAt
    updatedAt
    name
    createdBy {
      id
      firstName
      lastName
      email
    }
    fileSize
    contentType
    filePath
    fileName
  }
}
    ${IndividualDetailedFragmentDoc}
${HouseholdDetailedFragmentDoc}`;
export const MergedHouseholdMinimalFragmentDoc = gql`
    fragment mergedHouseholdMinimal on HouseholdNode {
  id
  unicefId
  headOfHousehold {
    id
    fullName
  }
  size
  admin1 {
    id
    name
  }
  admin2 {
    id
    name
  }
  firstRegistrationDate
  hasDuplicates
}
    `;
export const MergedIndividualMinimalFragmentDoc = gql`
    fragment mergedIndividualMinimal on IndividualNode {
  id
  unicefId
  age
  fullName
  birthDate
  sex
  role
  relationship
  deduplicationBatchStatus
  deduplicationGoldenRecordStatus
  deduplicationGoldenRecordResults {
    hitId
    fullName
    score
    proximityToScore
    age
    location
  }
  deduplicationBatchResults {
    hitId
    fullName
    score
    proximityToScore
    age
    location
  }
  registrationDataImport {
    id
    datahubId
  }
}
    `;
export const PaymentRecordDetailsFragmentDoc = gql`
    fragment paymentRecordDetails on PaymentRecordNode {
  id
  status
  statusDate
  caId
  caHashId
  registrationCaId
  verification {
    id
    status
    statusDate
    receivedAmount
  }
  household {
    id
    status
    size
    unicefId
    headOfHousehold {
      id
      phoneNo
      phoneNoAlternative
      phoneNoValid
      phoneNoAlternativeValid
    }
  }
  fullName
  distributionModality
  totalPersonsCovered
  targetPopulation {
    id
    name
  }
  parent {
    id
    caId
    program {
      id
      name
    }
    verificationPlans {
      edges {
        node {
          id
          status
          verificationChannel
        }
      }
    }
  }
  currency
  entitlementQuantity
  deliveredQuantity
  deliveredQuantityUsd
  deliveryDate
  deliveryType
  entitlementCardIssueDate
  entitlementCardNumber
  transactionReferenceId
  serviceProvider {
    id
    fullName
    shortName
  }
}
    `;
export const RegistrationMinimalFragmentDoc = gql`
    fragment registrationMinimal on RegistrationDataImportNode {
  id
  createdAt
  name
  status
  erased
  importDate
  importedBy {
    id
    firstName
    lastName
    email
  }
  dataSource
  numberOfHouseholds
  numberOfIndividuals
  program {
    id
    name
    startDate
    endDate
    status
  }
  refuseReason
  totalHouseholdsCountWithValidPhoneNo
  adminUrl
}
    `;
export const RegistrationDetailedFragmentDoc = gql`
    fragment registrationDetailed on RegistrationDataImportNode {
  ...registrationMinimal
  numberOfIndividuals
  datahubId
  errorMessage
  batchDuplicatesCountAndPercentage {
    count
    percentage
  }
  batchPossibleDuplicatesCountAndPercentage {
    count
    percentage
  }
  batchUniqueCountAndPercentage {
    count
    percentage
  }
  goldenRecordUniqueCountAndPercentage {
    count
    percentage
  }
  goldenRecordDuplicatesCountAndPercentage {
    count
    percentage
  }
  goldenRecordPossibleDuplicatesCountAndPercentage {
    count
    percentage
  }
}
    ${RegistrationMinimalFragmentDoc}`;
export const ImportedHouseholdMinimalFragmentDoc = gql`
    fragment importedHouseholdMinimal on ImportedHouseholdNode {
  id
  importId
  headOfHousehold {
    id
    fullName
  }
  size
  admin1
  admin1Title
  admin2
  admin2Title
  flexFields
  deviceid
  start
  koboAssetId
  rowId
  firstRegistrationDate
  lastRegistrationDate
  hasDuplicates
  fchildHoh
  childHoh
  collectIndividualData
}
    `;
export const ImportedIndividualMinimalFragmentDoc = gql`
    fragment importedIndividualMinimal on ImportedIndividualNode {
  id
  importId
  age
  fullName
  birthDate
  sex
  role
  relationship
  deduplicationBatchStatus
  deduplicationGoldenRecordStatus
  deduplicationGoldenRecordResults {
    hitId
    fullName
    score
    proximityToScore
    age
    location
  }
  deduplicationBatchResults {
    hitId
    fullName
    score
    proximityToScore
    age
    location
  }
  registrationDataImport {
    id
    hctId
  }
}
    `;
export const ImportedHouseholdDetailedFragmentDoc = gql`
    fragment importedHouseholdDetailed on ImportedHouseholdNode {
  ...importedHouseholdMinimal
  residenceStatus
  country
  countryOrigin
  registrationDataImport {
    id
    hctId
    name
  }
  individuals {
    edges {
      node {
        ...importedIndividualMinimal
      }
    }
  }
}
    ${ImportedHouseholdMinimalFragmentDoc}
${ImportedIndividualMinimalFragmentDoc}`;
export const ImportedIndividualDetailedFragmentDoc = gql`
    fragment importedIndividualDetailed on ImportedIndividualNode {
  ...importedIndividualMinimal
  photo
  givenName
  familyName
  middleName
  estimatedBirthDate
  maritalStatus
  workStatus
  pregnant
  flexFields
  observedDisability
  seeingDisability
  hearingDisability
  physicalDisability
  memoryDisability
  selfcareDisability
  commsDisability
  disability
  documents {
    edges {
      node {
        id
        country
        type {
          label
          key
        }
        documentNumber
        photo
      }
    }
  }
  identities {
    edges {
      node {
        id
        documentNumber
        partner
        country
      }
    }
  }
  role
  relationship
  household {
    id
    importId
    admin1
    admin2
    address
  }
  registrationDataImport {
    id
    hctId
    name
  }
  phoneNo
  phoneNoAlternative
  phoneNoValid
  phoneNoAlternativeValid
  preferredLanguage
  email
}
    ${ImportedIndividualMinimalFragmentDoc}`;
export const TargetPopulationMinimalFragmentDoc = gql`
    fragment targetPopulationMinimal on TargetPopulationNode {
  id
  name
  status
  createdAt
  updatedAt
  totalHouseholdsCount
  totalHouseholdsCountWithValidPhoneNo
  totalIndividualsCount
  __typename
  program {
    id
    name
    __typename
  }
  createdBy {
    id
    firstName
    lastName
    __typename
  }
}
    `;
export const TargetPopulationDetailedFragmentDoc = gql`
    fragment targetPopulationDetailed on TargetPopulationNode {
  id
  name
  status
  adminUrl
  buildStatus
  totalHouseholdsCount
  totalIndividualsCount
  childMaleCount
  childFemaleCount
  adultMaleCount
  adultFemaleCount
  caHashId
  excludedIds
  exclusionReason
  steficonRule {
    __typename
    id
    rule {
      __typename
      id
      name
    }
  }
  vulnerabilityScoreMin
  vulnerabilityScoreMax
  changeDate
  finalizedAt
  finalizedBy {
    __typename
    id
    firstName
    lastName
  }
  program {
    __typename
    id
    name
    status
    startDate
    endDate
    isSocialWorkerProgram
  }
  createdBy {
    __typename
    id
    email
    firstName
    lastName
  }
  targetingCriteria {
    __typename
    id
    flagExcludeIfActiveAdjudicationTicket
    flagExcludeIfOnSanctionList
    rules {
      __typename
      id
      individualsFiltersBlocks {
        __typename
        individualBlockFilters {
          __typename
          id
          fieldName
          isFlexField
          arguments
          comparisonMethod
          fieldAttribute {
            __typename
            id
            name
            labelEn
            type
            choices {
              value
              labelEn
            }
          }
        }
      }
      filters {
        __typename
        id
        fieldName
        isFlexField
        arguments
        comparisonMethod
        fieldAttribute {
          __typename
          id
          name
          labelEn
          type
          choices {
            value
            labelEn
          }
        }
      }
    }
  }
}
    `;
export const CreateFeedbackTicketDocument = gql`
    mutation CreateFeedbackTicket($input: CreateFeedbackInput!) {
  createFeedback(input: $input) {
    feedback {
      id
    }
  }
}
    `;
export type CreateFeedbackTicketMutationFn = Apollo.MutationFunction<CreateFeedbackTicketMutation, CreateFeedbackTicketMutationVariables>;

/**
 * __useCreateFeedbackTicketMutation__
 *
 * To run a mutation, you first call `useCreateFeedbackTicketMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFeedbackTicketMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFeedbackTicketMutation, { data, loading, error }] = useCreateFeedbackTicketMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFeedbackTicketMutation(baseOptions?: Apollo.MutationHookOptions<CreateFeedbackTicketMutation, CreateFeedbackTicketMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFeedbackTicketMutation, CreateFeedbackTicketMutationVariables>(CreateFeedbackTicketDocument, options);
      }
export type CreateFeedbackTicketMutationHookResult = ReturnType<typeof useCreateFeedbackTicketMutation>;
export type CreateFeedbackTicketMutationResult = Apollo.MutationResult<CreateFeedbackTicketMutation>;
export type CreateFeedbackTicketMutationOptions = Apollo.BaseMutationOptions<CreateFeedbackTicketMutation, CreateFeedbackTicketMutationVariables>;
export const CreateFeedbackMsgDocument = gql`
    mutation CreateFeedbackMsg($input: CreateFeedbackMessageInput!) {
  createFeedbackMessage(input: $input) {
    feedbackMessage {
      id
      createdAt
      updatedAt
      description
      createdBy {
        id
        firstName
        lastName
        username
        email
      }
    }
  }
}
    `;
export type CreateFeedbackMsgMutationFn = Apollo.MutationFunction<CreateFeedbackMsgMutation, CreateFeedbackMsgMutationVariables>;

/**
 * __useCreateFeedbackMsgMutation__
 *
 * To run a mutation, you first call `useCreateFeedbackMsgMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFeedbackMsgMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFeedbackMsgMutation, { data, loading, error }] = useCreateFeedbackMsgMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFeedbackMsgMutation(baseOptions?: Apollo.MutationHookOptions<CreateFeedbackMsgMutation, CreateFeedbackMsgMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFeedbackMsgMutation, CreateFeedbackMsgMutationVariables>(CreateFeedbackMsgDocument, options);
      }
export type CreateFeedbackMsgMutationHookResult = ReturnType<typeof useCreateFeedbackMsgMutation>;
export type CreateFeedbackMsgMutationResult = Apollo.MutationResult<CreateFeedbackMsgMutation>;
export type CreateFeedbackMsgMutationOptions = Apollo.BaseMutationOptions<CreateFeedbackMsgMutation, CreateFeedbackMsgMutationVariables>;
export const CreateSurveyAccountabilityDocument = gql`
    mutation CreateSurveyAccountability($input: CreateSurveyInput!) {
  createSurvey(input: $input) {
    survey {
      id
    }
  }
}
    `;
export type CreateSurveyAccountabilityMutationFn = Apollo.MutationFunction<CreateSurveyAccountabilityMutation, CreateSurveyAccountabilityMutationVariables>;

/**
 * __useCreateSurveyAccountabilityMutation__
 *
 * To run a mutation, you first call `useCreateSurveyAccountabilityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSurveyAccountabilityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSurveyAccountabilityMutation, { data, loading, error }] = useCreateSurveyAccountabilityMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSurveyAccountabilityMutation(baseOptions?: Apollo.MutationHookOptions<CreateSurveyAccountabilityMutation, CreateSurveyAccountabilityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSurveyAccountabilityMutation, CreateSurveyAccountabilityMutationVariables>(CreateSurveyAccountabilityDocument, options);
      }
export type CreateSurveyAccountabilityMutationHookResult = ReturnType<typeof useCreateSurveyAccountabilityMutation>;
export type CreateSurveyAccountabilityMutationResult = Apollo.MutationResult<CreateSurveyAccountabilityMutation>;
export type CreateSurveyAccountabilityMutationOptions = Apollo.BaseMutationOptions<CreateSurveyAccountabilityMutation, CreateSurveyAccountabilityMutationVariables>;
export const ExportSurveySampleDocument = gql`
    mutation ExportSurveySample($surveyId: ID!) {
  exportSurveySample(surveyId: $surveyId) {
    survey {
      id
    }
  }
}
    `;
export type ExportSurveySampleMutationFn = Apollo.MutationFunction<ExportSurveySampleMutation, ExportSurveySampleMutationVariables>;

/**
 * __useExportSurveySampleMutation__
 *
 * To run a mutation, you first call `useExportSurveySampleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExportSurveySampleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [exportSurveySampleMutation, { data, loading, error }] = useExportSurveySampleMutation({
 *   variables: {
 *      surveyId: // value for 'surveyId'
 *   },
 * });
 */
export function useExportSurveySampleMutation(baseOptions?: Apollo.MutationHookOptions<ExportSurveySampleMutation, ExportSurveySampleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExportSurveySampleMutation, ExportSurveySampleMutationVariables>(ExportSurveySampleDocument, options);
      }
export type ExportSurveySampleMutationHookResult = ReturnType<typeof useExportSurveySampleMutation>;
export type ExportSurveySampleMutationResult = Apollo.MutationResult<ExportSurveySampleMutation>;
export type ExportSurveySampleMutationOptions = Apollo.BaseMutationOptions<ExportSurveySampleMutation, ExportSurveySampleMutationVariables>;
export const UpdateFeedbackTicketDocument = gql`
    mutation UpdateFeedbackTicket($input: UpdateFeedbackInput!) {
  updateFeedback(input: $input) {
    feedback {
      id
      unicefId
      issueType
      householdLookup {
        id
        unicefId
        headOfHousehold {
          id
          fullName
        }
      }
      individualLookup {
        id
        unicefId
      }
      program {
        id
        name
      }
      createdBy {
        id
        firstName
        lastName
        username
        email
      }
      createdAt
      updatedAt
      admin2 {
        id
        name
      }
      area
      language
      description
      comments
      linkedGrievance {
        id
        unicefId
      }
    }
  }
}
    `;
export type UpdateFeedbackTicketMutationFn = Apollo.MutationFunction<UpdateFeedbackTicketMutation, UpdateFeedbackTicketMutationVariables>;

/**
 * __useUpdateFeedbackTicketMutation__
 *
 * To run a mutation, you first call `useUpdateFeedbackTicketMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFeedbackTicketMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFeedbackTicketMutation, { data, loading, error }] = useUpdateFeedbackTicketMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFeedbackTicketMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFeedbackTicketMutation, UpdateFeedbackTicketMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFeedbackTicketMutation, UpdateFeedbackTicketMutationVariables>(UpdateFeedbackTicketDocument, options);
      }
export type UpdateFeedbackTicketMutationHookResult = ReturnType<typeof useUpdateFeedbackTicketMutation>;
export type UpdateFeedbackTicketMutationResult = Apollo.MutationResult<UpdateFeedbackTicketMutation>;
export type UpdateFeedbackTicketMutationOptions = Apollo.BaseMutationOptions<UpdateFeedbackTicketMutation, UpdateFeedbackTicketMutationVariables>;
export const CreateAccountabilityCommunicationMessageDocument = gql`
    mutation CreateAccountabilityCommunicationMessage($input: CreateAccountabilityCommunicationMessageInput!) {
  createAccountabilityCommunicationMessage(input: $input) {
    message {
      id
    }
  }
}
    `;
export type CreateAccountabilityCommunicationMessageMutationFn = Apollo.MutationFunction<CreateAccountabilityCommunicationMessageMutation, CreateAccountabilityCommunicationMessageMutationVariables>;

/**
 * __useCreateAccountabilityCommunicationMessageMutation__
 *
 * To run a mutation, you first call `useCreateAccountabilityCommunicationMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAccountabilityCommunicationMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAccountabilityCommunicationMessageMutation, { data, loading, error }] = useCreateAccountabilityCommunicationMessageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAccountabilityCommunicationMessageMutation(baseOptions?: Apollo.MutationHookOptions<CreateAccountabilityCommunicationMessageMutation, CreateAccountabilityCommunicationMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAccountabilityCommunicationMessageMutation, CreateAccountabilityCommunicationMessageMutationVariables>(CreateAccountabilityCommunicationMessageDocument, options);
      }
export type CreateAccountabilityCommunicationMessageMutationHookResult = ReturnType<typeof useCreateAccountabilityCommunicationMessageMutation>;
export type CreateAccountabilityCommunicationMessageMutationResult = Apollo.MutationResult<CreateAccountabilityCommunicationMessageMutation>;
export type CreateAccountabilityCommunicationMessageMutationOptions = Apollo.BaseMutationOptions<CreateAccountabilityCommunicationMessageMutation, CreateAccountabilityCommunicationMessageMutationVariables>;
export const CheckAgainstSanctionListUploadDocument = gql`
    mutation CheckAgainstSanctionListUpload($file: Upload!) {
  checkAgainstSanctionList(file: $file) {
    errors {
      header
      message
      rowNumber
    }
  }
}
    `;
export type CheckAgainstSanctionListUploadMutationFn = Apollo.MutationFunction<CheckAgainstSanctionListUploadMutation, CheckAgainstSanctionListUploadMutationVariables>;

/**
 * __useCheckAgainstSanctionListUploadMutation__
 *
 * To run a mutation, you first call `useCheckAgainstSanctionListUploadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCheckAgainstSanctionListUploadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [checkAgainstSanctionListUploadMutation, { data, loading, error }] = useCheckAgainstSanctionListUploadMutation({
 *   variables: {
 *      file: // value for 'file'
 *   },
 * });
 */
export function useCheckAgainstSanctionListUploadMutation(baseOptions?: Apollo.MutationHookOptions<CheckAgainstSanctionListUploadMutation, CheckAgainstSanctionListUploadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CheckAgainstSanctionListUploadMutation, CheckAgainstSanctionListUploadMutationVariables>(CheckAgainstSanctionListUploadDocument, options);
      }
export type CheckAgainstSanctionListUploadMutationHookResult = ReturnType<typeof useCheckAgainstSanctionListUploadMutation>;
export type CheckAgainstSanctionListUploadMutationResult = Apollo.MutationResult<CheckAgainstSanctionListUploadMutation>;
export type CheckAgainstSanctionListUploadMutationOptions = Apollo.BaseMutationOptions<CheckAgainstSanctionListUploadMutation, CheckAgainstSanctionListUploadMutationVariables>;
export const ApproveAddIndividualDataChangeDocument = gql`
    mutation ApproveAddIndividualDataChange($grievanceTicketId: ID!, $approveStatus: Boolean!) {
  approveAddIndividual(
    grievanceTicketId: $grievanceTicketId
    approveStatus: $approveStatus
  ) {
    grievanceTicket {
      id
      status
    }
  }
}
    `;
export type ApproveAddIndividualDataChangeMutationFn = Apollo.MutationFunction<ApproveAddIndividualDataChangeMutation, ApproveAddIndividualDataChangeMutationVariables>;

/**
 * __useApproveAddIndividualDataChangeMutation__
 *
 * To run a mutation, you first call `useApproveAddIndividualDataChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveAddIndividualDataChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveAddIndividualDataChangeMutation, { data, loading, error }] = useApproveAddIndividualDataChangeMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      approveStatus: // value for 'approveStatus'
 *   },
 * });
 */
export function useApproveAddIndividualDataChangeMutation(baseOptions?: Apollo.MutationHookOptions<ApproveAddIndividualDataChangeMutation, ApproveAddIndividualDataChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveAddIndividualDataChangeMutation, ApproveAddIndividualDataChangeMutationVariables>(ApproveAddIndividualDataChangeDocument, options);
      }
export type ApproveAddIndividualDataChangeMutationHookResult = ReturnType<typeof useApproveAddIndividualDataChangeMutation>;
export type ApproveAddIndividualDataChangeMutationResult = Apollo.MutationResult<ApproveAddIndividualDataChangeMutation>;
export type ApproveAddIndividualDataChangeMutationOptions = Apollo.BaseMutationOptions<ApproveAddIndividualDataChangeMutation, ApproveAddIndividualDataChangeMutationVariables>;
export const ApproveDeleteHouseholdDataChangeDocument = gql`
    mutation ApproveDeleteHouseholdDataChange($grievanceTicketId: ID!, $approveStatus: Boolean!, $reasonHhId: String) {
  approveDeleteHousehold(
    grievanceTicketId: $grievanceTicketId
    approveStatus: $approveStatus
    reasonHhId: $reasonHhId
  ) {
    grievanceTicket {
      id
      status
    }
  }
}
    `;
export type ApproveDeleteHouseholdDataChangeMutationFn = Apollo.MutationFunction<ApproveDeleteHouseholdDataChangeMutation, ApproveDeleteHouseholdDataChangeMutationVariables>;

/**
 * __useApproveDeleteHouseholdDataChangeMutation__
 *
 * To run a mutation, you first call `useApproveDeleteHouseholdDataChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveDeleteHouseholdDataChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveDeleteHouseholdDataChangeMutation, { data, loading, error }] = useApproveDeleteHouseholdDataChangeMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      approveStatus: // value for 'approveStatus'
 *      reasonHhId: // value for 'reasonHhId'
 *   },
 * });
 */
export function useApproveDeleteHouseholdDataChangeMutation(baseOptions?: Apollo.MutationHookOptions<ApproveDeleteHouseholdDataChangeMutation, ApproveDeleteHouseholdDataChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveDeleteHouseholdDataChangeMutation, ApproveDeleteHouseholdDataChangeMutationVariables>(ApproveDeleteHouseholdDataChangeDocument, options);
      }
export type ApproveDeleteHouseholdDataChangeMutationHookResult = ReturnType<typeof useApproveDeleteHouseholdDataChangeMutation>;
export type ApproveDeleteHouseholdDataChangeMutationResult = Apollo.MutationResult<ApproveDeleteHouseholdDataChangeMutation>;
export type ApproveDeleteHouseholdDataChangeMutationOptions = Apollo.BaseMutationOptions<ApproveDeleteHouseholdDataChangeMutation, ApproveDeleteHouseholdDataChangeMutationVariables>;
export const ApproveDeleteIndividualDataChangeDocument = gql`
    mutation ApproveDeleteIndividualDataChange($grievanceTicketId: ID!, $approveStatus: Boolean!) {
  approveDeleteIndividual(
    grievanceTicketId: $grievanceTicketId
    approveStatus: $approveStatus
  ) {
    grievanceTicket {
      id
      status
    }
  }
}
    `;
export type ApproveDeleteIndividualDataChangeMutationFn = Apollo.MutationFunction<ApproveDeleteIndividualDataChangeMutation, ApproveDeleteIndividualDataChangeMutationVariables>;

/**
 * __useApproveDeleteIndividualDataChangeMutation__
 *
 * To run a mutation, you first call `useApproveDeleteIndividualDataChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveDeleteIndividualDataChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveDeleteIndividualDataChangeMutation, { data, loading, error }] = useApproveDeleteIndividualDataChangeMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      approveStatus: // value for 'approveStatus'
 *   },
 * });
 */
export function useApproveDeleteIndividualDataChangeMutation(baseOptions?: Apollo.MutationHookOptions<ApproveDeleteIndividualDataChangeMutation, ApproveDeleteIndividualDataChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveDeleteIndividualDataChangeMutation, ApproveDeleteIndividualDataChangeMutationVariables>(ApproveDeleteIndividualDataChangeDocument, options);
      }
export type ApproveDeleteIndividualDataChangeMutationHookResult = ReturnType<typeof useApproveDeleteIndividualDataChangeMutation>;
export type ApproveDeleteIndividualDataChangeMutationResult = Apollo.MutationResult<ApproveDeleteIndividualDataChangeMutation>;
export type ApproveDeleteIndividualDataChangeMutationOptions = Apollo.BaseMutationOptions<ApproveDeleteIndividualDataChangeMutation, ApproveDeleteIndividualDataChangeMutationVariables>;
export const ApproveHouseholdDataChangeDocument = gql`
    mutation ApproveHouseholdDataChange($grievanceTicketId: ID!, $householdApproveData: JSONString, $flexFieldsApproveData: JSONString) {
  approveHouseholdDataChange(
    grievanceTicketId: $grievanceTicketId
    householdApproveData: $householdApproveData
    flexFieldsApproveData: $flexFieldsApproveData
  ) {
    grievanceTicket {
      id
      status
      householdDataUpdateTicketDetails {
        id
        household {
          ...householdDetailed
        }
        householdData
      }
    }
  }
}
    ${HouseholdDetailedFragmentDoc}`;
export type ApproveHouseholdDataChangeMutationFn = Apollo.MutationFunction<ApproveHouseholdDataChangeMutation, ApproveHouseholdDataChangeMutationVariables>;

/**
 * __useApproveHouseholdDataChangeMutation__
 *
 * To run a mutation, you first call `useApproveHouseholdDataChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveHouseholdDataChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveHouseholdDataChangeMutation, { data, loading, error }] = useApproveHouseholdDataChangeMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      householdApproveData: // value for 'householdApproveData'
 *      flexFieldsApproveData: // value for 'flexFieldsApproveData'
 *   },
 * });
 */
export function useApproveHouseholdDataChangeMutation(baseOptions?: Apollo.MutationHookOptions<ApproveHouseholdDataChangeMutation, ApproveHouseholdDataChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveHouseholdDataChangeMutation, ApproveHouseholdDataChangeMutationVariables>(ApproveHouseholdDataChangeDocument, options);
      }
export type ApproveHouseholdDataChangeMutationHookResult = ReturnType<typeof useApproveHouseholdDataChangeMutation>;
export type ApproveHouseholdDataChangeMutationResult = Apollo.MutationResult<ApproveHouseholdDataChangeMutation>;
export type ApproveHouseholdDataChangeMutationOptions = Apollo.BaseMutationOptions<ApproveHouseholdDataChangeMutation, ApproveHouseholdDataChangeMutationVariables>;
export const ApproveIndividualDataChangeDocument = gql`
    mutation ApproveIndividualDataChange($grievanceTicketId: ID!, $individualApproveData: JSONString, $flexFieldsApproveData: JSONString, $approvedDocumentsToCreate: [Int], $approvedDocumentsToRemove: [Int], $approvedDocumentsToEdit: [Int], $approvedIdentitiesToCreate: [Int], $approvedIdentitiesToEdit: [Int], $approvedIdentitiesToRemove: [Int], $approvedPaymentChannelsToCreate: [Int], $approvedPaymentChannelsToEdit: [Int], $approvedPaymentChannelsToRemove: [Int]) {
  approveIndividualDataChange(
    grievanceTicketId: $grievanceTicketId
    individualApproveData: $individualApproveData
    flexFieldsApproveData: $flexFieldsApproveData
    approvedDocumentsToCreate: $approvedDocumentsToCreate
    approvedDocumentsToRemove: $approvedDocumentsToRemove
    approvedDocumentsToEdit: $approvedDocumentsToEdit
    approvedIdentitiesToCreate: $approvedIdentitiesToCreate
    approvedIdentitiesToEdit: $approvedIdentitiesToEdit
    approvedIdentitiesToRemove: $approvedIdentitiesToRemove
    approvedPaymentChannelsToCreate: $approvedPaymentChannelsToCreate
    approvedPaymentChannelsToEdit: $approvedPaymentChannelsToEdit
    approvedPaymentChannelsToRemove: $approvedPaymentChannelsToRemove
  ) {
    grievanceTicket {
      id
      status
      individualDataUpdateTicketDetails {
        id
        individual {
          ...individualDetailed
        }
        individualData
      }
    }
  }
}
    ${IndividualDetailedFragmentDoc}`;
export type ApproveIndividualDataChangeMutationFn = Apollo.MutationFunction<ApproveIndividualDataChangeMutation, ApproveIndividualDataChangeMutationVariables>;

/**
 * __useApproveIndividualDataChangeMutation__
 *
 * To run a mutation, you first call `useApproveIndividualDataChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveIndividualDataChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveIndividualDataChangeMutation, { data, loading, error }] = useApproveIndividualDataChangeMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      individualApproveData: // value for 'individualApproveData'
 *      flexFieldsApproveData: // value for 'flexFieldsApproveData'
 *      approvedDocumentsToCreate: // value for 'approvedDocumentsToCreate'
 *      approvedDocumentsToRemove: // value for 'approvedDocumentsToRemove'
 *      approvedDocumentsToEdit: // value for 'approvedDocumentsToEdit'
 *      approvedIdentitiesToCreate: // value for 'approvedIdentitiesToCreate'
 *      approvedIdentitiesToEdit: // value for 'approvedIdentitiesToEdit'
 *      approvedIdentitiesToRemove: // value for 'approvedIdentitiesToRemove'
 *      approvedPaymentChannelsToCreate: // value for 'approvedPaymentChannelsToCreate'
 *      approvedPaymentChannelsToEdit: // value for 'approvedPaymentChannelsToEdit'
 *      approvedPaymentChannelsToRemove: // value for 'approvedPaymentChannelsToRemove'
 *   },
 * });
 */
export function useApproveIndividualDataChangeMutation(baseOptions?: Apollo.MutationHookOptions<ApproveIndividualDataChangeMutation, ApproveIndividualDataChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveIndividualDataChangeMutation, ApproveIndividualDataChangeMutationVariables>(ApproveIndividualDataChangeDocument, options);
      }
export type ApproveIndividualDataChangeMutationHookResult = ReturnType<typeof useApproveIndividualDataChangeMutation>;
export type ApproveIndividualDataChangeMutationResult = Apollo.MutationResult<ApproveIndividualDataChangeMutation>;
export type ApproveIndividualDataChangeMutationOptions = Apollo.BaseMutationOptions<ApproveIndividualDataChangeMutation, ApproveIndividualDataChangeMutationVariables>;
export const ApproveNeedsAdjudicationDocument = gql`
    mutation ApproveNeedsAdjudication($grievanceTicketId: ID!, $selectedIndividualId: ID, $selectedIndividualIds: [ID]) {
  approveNeedsAdjudication(
    grievanceTicketId: $grievanceTicketId
    selectedIndividualId: $selectedIndividualId
    selectedIndividualIds: $selectedIndividualIds
  ) {
    grievanceTicket {
      id
      status
    }
  }
}
    `;
export type ApproveNeedsAdjudicationMutationFn = Apollo.MutationFunction<ApproveNeedsAdjudicationMutation, ApproveNeedsAdjudicationMutationVariables>;

/**
 * __useApproveNeedsAdjudicationMutation__
 *
 * To run a mutation, you first call `useApproveNeedsAdjudicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveNeedsAdjudicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveNeedsAdjudicationMutation, { data, loading, error }] = useApproveNeedsAdjudicationMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      selectedIndividualId: // value for 'selectedIndividualId'
 *      selectedIndividualIds: // value for 'selectedIndividualIds'
 *   },
 * });
 */
export function useApproveNeedsAdjudicationMutation(baseOptions?: Apollo.MutationHookOptions<ApproveNeedsAdjudicationMutation, ApproveNeedsAdjudicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveNeedsAdjudicationMutation, ApproveNeedsAdjudicationMutationVariables>(ApproveNeedsAdjudicationDocument, options);
      }
export type ApproveNeedsAdjudicationMutationHookResult = ReturnType<typeof useApproveNeedsAdjudicationMutation>;
export type ApproveNeedsAdjudicationMutationResult = Apollo.MutationResult<ApproveNeedsAdjudicationMutation>;
export type ApproveNeedsAdjudicationMutationOptions = Apollo.BaseMutationOptions<ApproveNeedsAdjudicationMutation, ApproveNeedsAdjudicationMutationVariables>;
export const ApprovePaymentDetailsDocument = gql`
    mutation ApprovePaymentDetails($grievanceTicketId: ID!, $approveStatus: Boolean!) {
  approvePaymentDetails(
    grievanceTicketId: $grievanceTicketId
    approveStatus: $approveStatus
  ) {
    grievanceTicket {
      id
      status
      paymentVerificationTicketDetails {
        id
        approveStatus
      }
    }
  }
}
    `;
export type ApprovePaymentDetailsMutationFn = Apollo.MutationFunction<ApprovePaymentDetailsMutation, ApprovePaymentDetailsMutationVariables>;

/**
 * __useApprovePaymentDetailsMutation__
 *
 * To run a mutation, you first call `useApprovePaymentDetailsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApprovePaymentDetailsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approvePaymentDetailsMutation, { data, loading, error }] = useApprovePaymentDetailsMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      approveStatus: // value for 'approveStatus'
 *   },
 * });
 */
export function useApprovePaymentDetailsMutation(baseOptions?: Apollo.MutationHookOptions<ApprovePaymentDetailsMutation, ApprovePaymentDetailsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApprovePaymentDetailsMutation, ApprovePaymentDetailsMutationVariables>(ApprovePaymentDetailsDocument, options);
      }
export type ApprovePaymentDetailsMutationHookResult = ReturnType<typeof useApprovePaymentDetailsMutation>;
export type ApprovePaymentDetailsMutationResult = Apollo.MutationResult<ApprovePaymentDetailsMutation>;
export type ApprovePaymentDetailsMutationOptions = Apollo.BaseMutationOptions<ApprovePaymentDetailsMutation, ApprovePaymentDetailsMutationVariables>;
export const ApproveSystemFlaggingDocument = gql`
    mutation ApproveSystemFlagging($grievanceTicketId: ID!, $approveStatus: Boolean!) {
  approveSystemFlagging(
    grievanceTicketId: $grievanceTicketId
    approveStatus: $approveStatus
  ) {
    grievanceTicket {
      id
      status
    }
  }
}
    `;
export type ApproveSystemFlaggingMutationFn = Apollo.MutationFunction<ApproveSystemFlaggingMutation, ApproveSystemFlaggingMutationVariables>;

/**
 * __useApproveSystemFlaggingMutation__
 *
 * To run a mutation, you first call `useApproveSystemFlaggingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveSystemFlaggingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveSystemFlaggingMutation, { data, loading, error }] = useApproveSystemFlaggingMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      approveStatus: // value for 'approveStatus'
 *   },
 * });
 */
export function useApproveSystemFlaggingMutation(baseOptions?: Apollo.MutationHookOptions<ApproveSystemFlaggingMutation, ApproveSystemFlaggingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveSystemFlaggingMutation, ApproveSystemFlaggingMutationVariables>(ApproveSystemFlaggingDocument, options);
      }
export type ApproveSystemFlaggingMutationHookResult = ReturnType<typeof useApproveSystemFlaggingMutation>;
export type ApproveSystemFlaggingMutationResult = Apollo.MutationResult<ApproveSystemFlaggingMutation>;
export type ApproveSystemFlaggingMutationOptions = Apollo.BaseMutationOptions<ApproveSystemFlaggingMutation, ApproveSystemFlaggingMutationVariables>;
export const BulkUpdateGrievanceAddNoteDocument = gql`
    mutation BulkUpdateGrievanceAddNote($grievanceTicketIds: [ID]!, $note: String!, $businessAreaSlug: String!) {
  bulkGrievanceAddNote(
    grievanceTicketIds: $grievanceTicketIds
    note: $note
    businessAreaSlug: $businessAreaSlug
  ) {
    grievanceTickets {
      id
    }
  }
}
    `;
export type BulkUpdateGrievanceAddNoteMutationFn = Apollo.MutationFunction<BulkUpdateGrievanceAddNoteMutation, BulkUpdateGrievanceAddNoteMutationVariables>;

/**
 * __useBulkUpdateGrievanceAddNoteMutation__
 *
 * To run a mutation, you first call `useBulkUpdateGrievanceAddNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkUpdateGrievanceAddNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkUpdateGrievanceAddNoteMutation, { data, loading, error }] = useBulkUpdateGrievanceAddNoteMutation({
 *   variables: {
 *      grievanceTicketIds: // value for 'grievanceTicketIds'
 *      note: // value for 'note'
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useBulkUpdateGrievanceAddNoteMutation(baseOptions?: Apollo.MutationHookOptions<BulkUpdateGrievanceAddNoteMutation, BulkUpdateGrievanceAddNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkUpdateGrievanceAddNoteMutation, BulkUpdateGrievanceAddNoteMutationVariables>(BulkUpdateGrievanceAddNoteDocument, options);
      }
export type BulkUpdateGrievanceAddNoteMutationHookResult = ReturnType<typeof useBulkUpdateGrievanceAddNoteMutation>;
export type BulkUpdateGrievanceAddNoteMutationResult = Apollo.MutationResult<BulkUpdateGrievanceAddNoteMutation>;
export type BulkUpdateGrievanceAddNoteMutationOptions = Apollo.BaseMutationOptions<BulkUpdateGrievanceAddNoteMutation, BulkUpdateGrievanceAddNoteMutationVariables>;
export const BulkUpdateGrievanceAssigneeDocument = gql`
    mutation BulkUpdateGrievanceAssignee($grievanceTicketIds: [ID]!, $assignedTo: String!, $businessAreaSlug: String!) {
  bulkUpdateGrievanceAssignee(
    grievanceTicketIds: $grievanceTicketIds
    assignedTo: $assignedTo
    businessAreaSlug: $businessAreaSlug
  ) {
    grievanceTickets {
      id
      assignedTo {
        id
        firstName
        lastName
        email
      }
    }
  }
}
    `;
export type BulkUpdateGrievanceAssigneeMutationFn = Apollo.MutationFunction<BulkUpdateGrievanceAssigneeMutation, BulkUpdateGrievanceAssigneeMutationVariables>;

/**
 * __useBulkUpdateGrievanceAssigneeMutation__
 *
 * To run a mutation, you first call `useBulkUpdateGrievanceAssigneeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkUpdateGrievanceAssigneeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkUpdateGrievanceAssigneeMutation, { data, loading, error }] = useBulkUpdateGrievanceAssigneeMutation({
 *   variables: {
 *      grievanceTicketIds: // value for 'grievanceTicketIds'
 *      assignedTo: // value for 'assignedTo'
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useBulkUpdateGrievanceAssigneeMutation(baseOptions?: Apollo.MutationHookOptions<BulkUpdateGrievanceAssigneeMutation, BulkUpdateGrievanceAssigneeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkUpdateGrievanceAssigneeMutation, BulkUpdateGrievanceAssigneeMutationVariables>(BulkUpdateGrievanceAssigneeDocument, options);
      }
export type BulkUpdateGrievanceAssigneeMutationHookResult = ReturnType<typeof useBulkUpdateGrievanceAssigneeMutation>;
export type BulkUpdateGrievanceAssigneeMutationResult = Apollo.MutationResult<BulkUpdateGrievanceAssigneeMutation>;
export type BulkUpdateGrievanceAssigneeMutationOptions = Apollo.BaseMutationOptions<BulkUpdateGrievanceAssigneeMutation, BulkUpdateGrievanceAssigneeMutationVariables>;
export const BulkUpdateGrievancePriorityDocument = gql`
    mutation BulkUpdateGrievancePriority($grievanceTicketIds: [ID]!, $priority: Int!, $businessAreaSlug: String!) {
  bulkUpdateGrievancePriority(
    grievanceTicketIds: $grievanceTicketIds
    priority: $priority
    businessAreaSlug: $businessAreaSlug
  ) {
    grievanceTickets {
      id
      priority
    }
  }
}
    `;
export type BulkUpdateGrievancePriorityMutationFn = Apollo.MutationFunction<BulkUpdateGrievancePriorityMutation, BulkUpdateGrievancePriorityMutationVariables>;

/**
 * __useBulkUpdateGrievancePriorityMutation__
 *
 * To run a mutation, you first call `useBulkUpdateGrievancePriorityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkUpdateGrievancePriorityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkUpdateGrievancePriorityMutation, { data, loading, error }] = useBulkUpdateGrievancePriorityMutation({
 *   variables: {
 *      grievanceTicketIds: // value for 'grievanceTicketIds'
 *      priority: // value for 'priority'
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useBulkUpdateGrievancePriorityMutation(baseOptions?: Apollo.MutationHookOptions<BulkUpdateGrievancePriorityMutation, BulkUpdateGrievancePriorityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkUpdateGrievancePriorityMutation, BulkUpdateGrievancePriorityMutationVariables>(BulkUpdateGrievancePriorityDocument, options);
      }
export type BulkUpdateGrievancePriorityMutationHookResult = ReturnType<typeof useBulkUpdateGrievancePriorityMutation>;
export type BulkUpdateGrievancePriorityMutationResult = Apollo.MutationResult<BulkUpdateGrievancePriorityMutation>;
export type BulkUpdateGrievancePriorityMutationOptions = Apollo.BaseMutationOptions<BulkUpdateGrievancePriorityMutation, BulkUpdateGrievancePriorityMutationVariables>;
export const BulkUpdateGrievanceUrgencyDocument = gql`
    mutation BulkUpdateGrievanceUrgency($grievanceTicketIds: [ID]!, $urgency: Int!, $businessAreaSlug: String!) {
  bulkUpdateGrievanceUrgency(
    grievanceTicketIds: $grievanceTicketIds
    urgency: $urgency
    businessAreaSlug: $businessAreaSlug
  ) {
    grievanceTickets {
      id
      urgency
    }
  }
}
    `;
export type BulkUpdateGrievanceUrgencyMutationFn = Apollo.MutationFunction<BulkUpdateGrievanceUrgencyMutation, BulkUpdateGrievanceUrgencyMutationVariables>;

/**
 * __useBulkUpdateGrievanceUrgencyMutation__
 *
 * To run a mutation, you first call `useBulkUpdateGrievanceUrgencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkUpdateGrievanceUrgencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkUpdateGrievanceUrgencyMutation, { data, loading, error }] = useBulkUpdateGrievanceUrgencyMutation({
 *   variables: {
 *      grievanceTicketIds: // value for 'grievanceTicketIds'
 *      urgency: // value for 'urgency'
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useBulkUpdateGrievanceUrgencyMutation(baseOptions?: Apollo.MutationHookOptions<BulkUpdateGrievanceUrgencyMutation, BulkUpdateGrievanceUrgencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkUpdateGrievanceUrgencyMutation, BulkUpdateGrievanceUrgencyMutationVariables>(BulkUpdateGrievanceUrgencyDocument, options);
      }
export type BulkUpdateGrievanceUrgencyMutationHookResult = ReturnType<typeof useBulkUpdateGrievanceUrgencyMutation>;
export type BulkUpdateGrievanceUrgencyMutationResult = Apollo.MutationResult<BulkUpdateGrievanceUrgencyMutation>;
export type BulkUpdateGrievanceUrgencyMutationOptions = Apollo.BaseMutationOptions<BulkUpdateGrievanceUrgencyMutation, BulkUpdateGrievanceUrgencyMutationVariables>;
export const CreateGrievanceDocument = gql`
    mutation CreateGrievance($input: CreateGrievanceTicketInput!) {
  createGrievanceTicket(input: $input) {
    grievanceTickets {
      id
      category
    }
  }
}
    `;
export type CreateGrievanceMutationFn = Apollo.MutationFunction<CreateGrievanceMutation, CreateGrievanceMutationVariables>;

/**
 * __useCreateGrievanceMutation__
 *
 * To run a mutation, you first call `useCreateGrievanceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGrievanceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGrievanceMutation, { data, loading, error }] = useCreateGrievanceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGrievanceMutation(baseOptions?: Apollo.MutationHookOptions<CreateGrievanceMutation, CreateGrievanceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGrievanceMutation, CreateGrievanceMutationVariables>(CreateGrievanceDocument, options);
      }
export type CreateGrievanceMutationHookResult = ReturnType<typeof useCreateGrievanceMutation>;
export type CreateGrievanceMutationResult = Apollo.MutationResult<CreateGrievanceMutation>;
export type CreateGrievanceMutationOptions = Apollo.BaseMutationOptions<CreateGrievanceMutation, CreateGrievanceMutationVariables>;
export const CreateGrievanceTicketNoteDocument = gql`
    mutation CreateGrievanceTicketNote($noteInput: CreateTicketNoteInput!) {
  createTicketNote(noteInput: $noteInput) {
    grievanceTicketNote {
      id
      createdAt
      updatedAt
      createdBy {
        firstName
        lastName
        username
        email
      }
    }
  }
}
    `;
export type CreateGrievanceTicketNoteMutationFn = Apollo.MutationFunction<CreateGrievanceTicketNoteMutation, CreateGrievanceTicketNoteMutationVariables>;

/**
 * __useCreateGrievanceTicketNoteMutation__
 *
 * To run a mutation, you first call `useCreateGrievanceTicketNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGrievanceTicketNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGrievanceTicketNoteMutation, { data, loading, error }] = useCreateGrievanceTicketNoteMutation({
 *   variables: {
 *      noteInput: // value for 'noteInput'
 *   },
 * });
 */
export function useCreateGrievanceTicketNoteMutation(baseOptions?: Apollo.MutationHookOptions<CreateGrievanceTicketNoteMutation, CreateGrievanceTicketNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGrievanceTicketNoteMutation, CreateGrievanceTicketNoteMutationVariables>(CreateGrievanceTicketNoteDocument, options);
      }
export type CreateGrievanceTicketNoteMutationHookResult = ReturnType<typeof useCreateGrievanceTicketNoteMutation>;
export type CreateGrievanceTicketNoteMutationResult = Apollo.MutationResult<CreateGrievanceTicketNoteMutation>;
export type CreateGrievanceTicketNoteMutationOptions = Apollo.BaseMutationOptions<CreateGrievanceTicketNoteMutation, CreateGrievanceTicketNoteMutationVariables>;
export const GrievanceTicketStatusChangeDocument = gql`
    mutation GrievanceTicketStatusChange($grievanceTicketId: ID, $status: Int) {
  grievanceStatusChange(grievanceTicketId: $grievanceTicketId, status: $status) {
    grievanceTicket {
      ...grievanceTicketDetailed
    }
  }
}
    ${GrievanceTicketDetailedFragmentDoc}`;
export type GrievanceTicketStatusChangeMutationFn = Apollo.MutationFunction<GrievanceTicketStatusChangeMutation, GrievanceTicketStatusChangeMutationVariables>;

/**
 * __useGrievanceTicketStatusChangeMutation__
 *
 * To run a mutation, you first call `useGrievanceTicketStatusChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGrievanceTicketStatusChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [grievanceTicketStatusChangeMutation, { data, loading, error }] = useGrievanceTicketStatusChangeMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGrievanceTicketStatusChangeMutation(baseOptions?: Apollo.MutationHookOptions<GrievanceTicketStatusChangeMutation, GrievanceTicketStatusChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GrievanceTicketStatusChangeMutation, GrievanceTicketStatusChangeMutationVariables>(GrievanceTicketStatusChangeDocument, options);
      }
export type GrievanceTicketStatusChangeMutationHookResult = ReturnType<typeof useGrievanceTicketStatusChangeMutation>;
export type GrievanceTicketStatusChangeMutationResult = Apollo.MutationResult<GrievanceTicketStatusChangeMutation>;
export type GrievanceTicketStatusChangeMutationOptions = Apollo.BaseMutationOptions<GrievanceTicketStatusChangeMutation, GrievanceTicketStatusChangeMutationVariables>;
export const ReassignRoleGrievanceDocument = gql`
    mutation ReassignRoleGrievance($grievanceTicketId: ID!, $householdId: ID!, $individualId: ID!, $newIndividualId: ID, $role: String!) {
  reassignRole(
    grievanceTicketId: $grievanceTicketId
    householdId: $householdId
    individualId: $individualId
    newIndividualId: $newIndividualId
    role: $role
  ) {
    household {
      id
      unicefId
    }
    individual {
      id
      unicefId
    }
  }
}
    `;
export type ReassignRoleGrievanceMutationFn = Apollo.MutationFunction<ReassignRoleGrievanceMutation, ReassignRoleGrievanceMutationVariables>;

/**
 * __useReassignRoleGrievanceMutation__
 *
 * To run a mutation, you first call `useReassignRoleGrievanceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReassignRoleGrievanceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reassignRoleGrievanceMutation, { data, loading, error }] = useReassignRoleGrievanceMutation({
 *   variables: {
 *      grievanceTicketId: // value for 'grievanceTicketId'
 *      householdId: // value for 'householdId'
 *      individualId: // value for 'individualId'
 *      newIndividualId: // value for 'newIndividualId'
 *      role: // value for 'role'
 *   },
 * });
 */
export function useReassignRoleGrievanceMutation(baseOptions?: Apollo.MutationHookOptions<ReassignRoleGrievanceMutation, ReassignRoleGrievanceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReassignRoleGrievanceMutation, ReassignRoleGrievanceMutationVariables>(ReassignRoleGrievanceDocument, options);
      }
export type ReassignRoleGrievanceMutationHookResult = ReturnType<typeof useReassignRoleGrievanceMutation>;
export type ReassignRoleGrievanceMutationResult = Apollo.MutationResult<ReassignRoleGrievanceMutation>;
export type ReassignRoleGrievanceMutationOptions = Apollo.BaseMutationOptions<ReassignRoleGrievanceMutation, ReassignRoleGrievanceMutationVariables>;
export const UpdateGrievanceDocument = gql`
    mutation UpdateGrievance($input: UpdateGrievanceTicketInput!) {
  updateGrievanceTicket(input: $input) {
    grievanceTicket {
      id
    }
  }
}
    `;
export type UpdateGrievanceMutationFn = Apollo.MutationFunction<UpdateGrievanceMutation, UpdateGrievanceMutationVariables>;

/**
 * __useUpdateGrievanceMutation__
 *
 * To run a mutation, you first call `useUpdateGrievanceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGrievanceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGrievanceMutation, { data, loading, error }] = useUpdateGrievanceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateGrievanceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGrievanceMutation, UpdateGrievanceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGrievanceMutation, UpdateGrievanceMutationVariables>(UpdateGrievanceDocument, options);
      }
export type UpdateGrievanceMutationHookResult = ReturnType<typeof useUpdateGrievanceMutation>;
export type UpdateGrievanceMutationResult = Apollo.MutationResult<UpdateGrievanceMutation>;
export type UpdateGrievanceMutationOptions = Apollo.BaseMutationOptions<UpdateGrievanceMutation, UpdateGrievanceMutationVariables>;
export const ActionPpDocument = gql`
    mutation ActionPP($input: ActionPaymentPlanInput!) {
  actionPaymentPlanMutation(input: $input) {
    paymentPlan {
      id
      status
    }
  }
}
    `;
export type ActionPpMutationFn = Apollo.MutationFunction<ActionPpMutation, ActionPpMutationVariables>;

/**
 * __useActionPpMutation__
 *
 * To run a mutation, you first call `useActionPpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useActionPpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [actionPpMutation, { data, loading, error }] = useActionPpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useActionPpMutation(baseOptions?: Apollo.MutationHookOptions<ActionPpMutation, ActionPpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ActionPpMutation, ActionPpMutationVariables>(ActionPpDocument, options);
      }
export type ActionPpMutationHookResult = ReturnType<typeof useActionPpMutation>;
export type ActionPpMutationResult = Apollo.MutationResult<ActionPpMutation>;
export type ActionPpMutationOptions = Apollo.BaseMutationOptions<ActionPpMutation, ActionPpMutationVariables>;
export const AssignFspToDeliveryMechDocument = gql`
    mutation AssignFspToDeliveryMech($input: AssignFspToDeliveryMechanismInput!) {
  assignFspToDeliveryMechanism(input: $input) {
    paymentPlan {
      id
      deliveryMechanisms {
        id
        name
        fsp {
          id
          name
        }
      }
    }
  }
}
    `;
export type AssignFspToDeliveryMechMutationFn = Apollo.MutationFunction<AssignFspToDeliveryMechMutation, AssignFspToDeliveryMechMutationVariables>;

/**
 * __useAssignFspToDeliveryMechMutation__
 *
 * To run a mutation, you first call `useAssignFspToDeliveryMechMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignFspToDeliveryMechMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignFspToDeliveryMechMutation, { data, loading, error }] = useAssignFspToDeliveryMechMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAssignFspToDeliveryMechMutation(baseOptions?: Apollo.MutationHookOptions<AssignFspToDeliveryMechMutation, AssignFspToDeliveryMechMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignFspToDeliveryMechMutation, AssignFspToDeliveryMechMutationVariables>(AssignFspToDeliveryMechDocument, options);
      }
export type AssignFspToDeliveryMechMutationHookResult = ReturnType<typeof useAssignFspToDeliveryMechMutation>;
export type AssignFspToDeliveryMechMutationResult = Apollo.MutationResult<AssignFspToDeliveryMechMutation>;
export type AssignFspToDeliveryMechMutationOptions = Apollo.BaseMutationOptions<AssignFspToDeliveryMechMutation, AssignFspToDeliveryMechMutationVariables>;
export const ChooseDeliveryMechForPaymentPlanDocument = gql`
    mutation ChooseDeliveryMechForPaymentPlan($input: ChooseDeliveryMechanismsForPaymentPlanInput!) {
  chooseDeliveryMechanismsForPaymentPlan(input: $input) {
    paymentPlan {
      id
      deliveryMechanisms {
        id
        name
        fsp {
          id
          name
        }
      }
    }
  }
}
    `;
export type ChooseDeliveryMechForPaymentPlanMutationFn = Apollo.MutationFunction<ChooseDeliveryMechForPaymentPlanMutation, ChooseDeliveryMechForPaymentPlanMutationVariables>;

/**
 * __useChooseDeliveryMechForPaymentPlanMutation__
 *
 * To run a mutation, you first call `useChooseDeliveryMechForPaymentPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChooseDeliveryMechForPaymentPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chooseDeliveryMechForPaymentPlanMutation, { data, loading, error }] = useChooseDeliveryMechForPaymentPlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useChooseDeliveryMechForPaymentPlanMutation(baseOptions?: Apollo.MutationHookOptions<ChooseDeliveryMechForPaymentPlanMutation, ChooseDeliveryMechForPaymentPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChooseDeliveryMechForPaymentPlanMutation, ChooseDeliveryMechForPaymentPlanMutationVariables>(ChooseDeliveryMechForPaymentPlanDocument, options);
      }
export type ChooseDeliveryMechForPaymentPlanMutationHookResult = ReturnType<typeof useChooseDeliveryMechForPaymentPlanMutation>;
export type ChooseDeliveryMechForPaymentPlanMutationResult = Apollo.MutationResult<ChooseDeliveryMechForPaymentPlanMutation>;
export type ChooseDeliveryMechForPaymentPlanMutationOptions = Apollo.BaseMutationOptions<ChooseDeliveryMechForPaymentPlanMutation, ChooseDeliveryMechForPaymentPlanMutationVariables>;
export const CreateFollowUpPpDocument = gql`
    mutation CreateFollowUpPP($dispersionStartDate: Date!, $dispersionEndDate: Date!, $paymentPlanId: ID!) {
  createFollowUpPaymentPlan(
    dispersionStartDate: $dispersionStartDate
    dispersionEndDate: $dispersionEndDate
    paymentPlanId: $paymentPlanId
  ) {
    paymentPlan {
      id
      unicefId
    }
  }
}
    `;
export type CreateFollowUpPpMutationFn = Apollo.MutationFunction<CreateFollowUpPpMutation, CreateFollowUpPpMutationVariables>;

/**
 * __useCreateFollowUpPpMutation__
 *
 * To run a mutation, you first call `useCreateFollowUpPpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFollowUpPpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFollowUpPpMutation, { data, loading, error }] = useCreateFollowUpPpMutation({
 *   variables: {
 *      dispersionStartDate: // value for 'dispersionStartDate'
 *      dispersionEndDate: // value for 'dispersionEndDate'
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useCreateFollowUpPpMutation(baseOptions?: Apollo.MutationHookOptions<CreateFollowUpPpMutation, CreateFollowUpPpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFollowUpPpMutation, CreateFollowUpPpMutationVariables>(CreateFollowUpPpDocument, options);
      }
export type CreateFollowUpPpMutationHookResult = ReturnType<typeof useCreateFollowUpPpMutation>;
export type CreateFollowUpPpMutationResult = Apollo.MutationResult<CreateFollowUpPpMutation>;
export type CreateFollowUpPpMutationOptions = Apollo.BaseMutationOptions<CreateFollowUpPpMutation, CreateFollowUpPpMutationVariables>;
export const CreatePpDocument = gql`
    mutation CreatePP($input: CreatePaymentPlanInput!) {
  createPaymentPlan(input: $input) {
    paymentPlan {
      id
    }
  }
}
    `;
export type CreatePpMutationFn = Apollo.MutationFunction<CreatePpMutation, CreatePpMutationVariables>;

/**
 * __useCreatePpMutation__
 *
 * To run a mutation, you first call `useCreatePpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPpMutation, { data, loading, error }] = useCreatePpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePpMutation(baseOptions?: Apollo.MutationHookOptions<CreatePpMutation, CreatePpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePpMutation, CreatePpMutationVariables>(CreatePpDocument, options);
      }
export type CreatePpMutationHookResult = ReturnType<typeof useCreatePpMutation>;
export type CreatePpMutationResult = Apollo.MutationResult<CreatePpMutation>;
export type CreatePpMutationOptions = Apollo.BaseMutationOptions<CreatePpMutation, CreatePpMutationVariables>;
export const DeletePpDocument = gql`
    mutation DeletePP($paymentPlanId: ID!) {
  deletePaymentPlan(paymentPlanId: $paymentPlanId) {
    paymentPlan {
      id
      status
    }
  }
}
    `;
export type DeletePpMutationFn = Apollo.MutationFunction<DeletePpMutation, DeletePpMutationVariables>;

/**
 * __useDeletePpMutation__
 *
 * To run a mutation, you first call `useDeletePpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePpMutation, { data, loading, error }] = useDeletePpMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useDeletePpMutation(baseOptions?: Apollo.MutationHookOptions<DeletePpMutation, DeletePpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePpMutation, DeletePpMutationVariables>(DeletePpDocument, options);
      }
export type DeletePpMutationHookResult = ReturnType<typeof useDeletePpMutation>;
export type DeletePpMutationResult = Apollo.MutationResult<DeletePpMutation>;
export type DeletePpMutationOptions = Apollo.BaseMutationOptions<DeletePpMutation, DeletePpMutationVariables>;
export const UpdatePpDocument = gql`
    mutation UpdatePP($input: UpdatePaymentPlanInput!) {
  updatePaymentPlan(input: $input) {
    paymentPlan {
      id
    }
  }
}
    `;
export type UpdatePpMutationFn = Apollo.MutationFunction<UpdatePpMutation, UpdatePpMutationVariables>;

/**
 * __useUpdatePpMutation__
 *
 * To run a mutation, you first call `useUpdatePpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePpMutation, { data, loading, error }] = useUpdatePpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePpMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePpMutation, UpdatePpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePpMutation, UpdatePpMutationVariables>(UpdatePpDocument, options);
      }
export type UpdatePpMutationHookResult = ReturnType<typeof useUpdatePpMutation>;
export type UpdatePpMutationResult = Apollo.MutationResult<UpdatePpMutation>;
export type UpdatePpMutationOptions = Apollo.BaseMutationOptions<UpdatePpMutation, UpdatePpMutationVariables>;
export const ExcludeHouseholdsPpDocument = gql`
    mutation ExcludeHouseholdsPP($paymentPlanId: ID!, $excludedHouseholdsIds: [String]!, $exclusionReason: String) {
  excludeHouseholds(
    paymentPlanId: $paymentPlanId
    excludedHouseholdsIds: $excludedHouseholdsIds
    exclusionReason: $exclusionReason
  ) {
    paymentPlan {
      id
      status
      backgroundActionStatus
      excludeHouseholdError
      exclusionReason
      excludedHouseholds {
        id
        unicefId
      }
    }
  }
}
    `;
export type ExcludeHouseholdsPpMutationFn = Apollo.MutationFunction<ExcludeHouseholdsPpMutation, ExcludeHouseholdsPpMutationVariables>;

/**
 * __useExcludeHouseholdsPpMutation__
 *
 * To run a mutation, you first call `useExcludeHouseholdsPpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExcludeHouseholdsPpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [excludeHouseholdsPpMutation, { data, loading, error }] = useExcludeHouseholdsPpMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *      excludedHouseholdsIds: // value for 'excludedHouseholdsIds'
 *      exclusionReason: // value for 'exclusionReason'
 *   },
 * });
 */
export function useExcludeHouseholdsPpMutation(baseOptions?: Apollo.MutationHookOptions<ExcludeHouseholdsPpMutation, ExcludeHouseholdsPpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExcludeHouseholdsPpMutation, ExcludeHouseholdsPpMutationVariables>(ExcludeHouseholdsPpDocument, options);
      }
export type ExcludeHouseholdsPpMutationHookResult = ReturnType<typeof useExcludeHouseholdsPpMutation>;
export type ExcludeHouseholdsPpMutationResult = Apollo.MutationResult<ExcludeHouseholdsPpMutation>;
export type ExcludeHouseholdsPpMutationOptions = Apollo.BaseMutationOptions<ExcludeHouseholdsPpMutation, ExcludeHouseholdsPpMutationVariables>;
export const ExportPdfPpSummaryDocument = gql`
    mutation exportPdfPPSummary($paymentPlanId: ID!) {
  exportPdfPaymentPlanSummary(paymentPlanId: $paymentPlanId) {
    paymentPlan {
      id
    }
  }
}
    `;
export type ExportPdfPpSummaryMutationFn = Apollo.MutationFunction<ExportPdfPpSummaryMutation, ExportPdfPpSummaryMutationVariables>;

/**
 * __useExportPdfPpSummaryMutation__
 *
 * To run a mutation, you first call `useExportPdfPpSummaryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExportPdfPpSummaryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [exportPdfPpSummaryMutation, { data, loading, error }] = useExportPdfPpSummaryMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useExportPdfPpSummaryMutation(baseOptions?: Apollo.MutationHookOptions<ExportPdfPpSummaryMutation, ExportPdfPpSummaryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExportPdfPpSummaryMutation, ExportPdfPpSummaryMutationVariables>(ExportPdfPpSummaryDocument, options);
      }
export type ExportPdfPpSummaryMutationHookResult = ReturnType<typeof useExportPdfPpSummaryMutation>;
export type ExportPdfPpSummaryMutationResult = Apollo.MutationResult<ExportPdfPpSummaryMutation>;
export type ExportPdfPpSummaryMutationOptions = Apollo.BaseMutationOptions<ExportPdfPpSummaryMutation, ExportPdfPpSummaryMutationVariables>;
export const ExportXlsxPpListDocument = gql`
    mutation ExportXlsxPPList($paymentPlanId: ID!) {
  exportXlsxPaymentPlanPaymentList(paymentPlanId: $paymentPlanId) {
    paymentPlan {
      id
      status
      backgroundActionStatus
    }
  }
}
    `;
export type ExportXlsxPpListMutationFn = Apollo.MutationFunction<ExportXlsxPpListMutation, ExportXlsxPpListMutationVariables>;

/**
 * __useExportXlsxPpListMutation__
 *
 * To run a mutation, you first call `useExportXlsxPpListMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExportXlsxPpListMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [exportXlsxPpListMutation, { data, loading, error }] = useExportXlsxPpListMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useExportXlsxPpListMutation(baseOptions?: Apollo.MutationHookOptions<ExportXlsxPpListMutation, ExportXlsxPpListMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExportXlsxPpListMutation, ExportXlsxPpListMutationVariables>(ExportXlsxPpListDocument, options);
      }
export type ExportXlsxPpListMutationHookResult = ReturnType<typeof useExportXlsxPpListMutation>;
export type ExportXlsxPpListMutationResult = Apollo.MutationResult<ExportXlsxPpListMutation>;
export type ExportXlsxPpListMutationOptions = Apollo.BaseMutationOptions<ExportXlsxPpListMutation, ExportXlsxPpListMutationVariables>;
export const ExportXlsxPpListPerFspDocument = gql`
    mutation ExportXlsxPPListPerFsp($paymentPlanId: ID!) {
  exportXlsxPaymentPlanPaymentListPerFsp(paymentPlanId: $paymentPlanId) {
    paymentPlan {
      id
      status
      backgroundActionStatus
    }
  }
}
    `;
export type ExportXlsxPpListPerFspMutationFn = Apollo.MutationFunction<ExportXlsxPpListPerFspMutation, ExportXlsxPpListPerFspMutationVariables>;

/**
 * __useExportXlsxPpListPerFspMutation__
 *
 * To run a mutation, you first call `useExportXlsxPpListPerFspMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExportXlsxPpListPerFspMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [exportXlsxPpListPerFspMutation, { data, loading, error }] = useExportXlsxPpListPerFspMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useExportXlsxPpListPerFspMutation(baseOptions?: Apollo.MutationHookOptions<ExportXlsxPpListPerFspMutation, ExportXlsxPpListPerFspMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExportXlsxPpListPerFspMutation, ExportXlsxPpListPerFspMutationVariables>(ExportXlsxPpListPerFspDocument, options);
      }
export type ExportXlsxPpListPerFspMutationHookResult = ReturnType<typeof useExportXlsxPpListPerFspMutation>;
export type ExportXlsxPpListPerFspMutationResult = Apollo.MutationResult<ExportXlsxPpListPerFspMutation>;
export type ExportXlsxPpListPerFspMutationOptions = Apollo.BaseMutationOptions<ExportXlsxPpListPerFspMutation, ExportXlsxPpListPerFspMutationVariables>;
export const ImportXlsxPpListDocument = gql`
    mutation importXlsxPPList($paymentPlanId: ID!, $file: Upload!) {
  importXlsxPaymentPlanPaymentList(paymentPlanId: $paymentPlanId, file: $file) {
    paymentPlan {
      id
      status
    }
    errors {
      sheet
      coordinates
      message
    }
  }
}
    `;
export type ImportXlsxPpListMutationFn = Apollo.MutationFunction<ImportXlsxPpListMutation, ImportXlsxPpListMutationVariables>;

/**
 * __useImportXlsxPpListMutation__
 *
 * To run a mutation, you first call `useImportXlsxPpListMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportXlsxPpListMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importXlsxPpListMutation, { data, loading, error }] = useImportXlsxPpListMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useImportXlsxPpListMutation(baseOptions?: Apollo.MutationHookOptions<ImportXlsxPpListMutation, ImportXlsxPpListMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportXlsxPpListMutation, ImportXlsxPpListMutationVariables>(ImportXlsxPpListDocument, options);
      }
export type ImportXlsxPpListMutationHookResult = ReturnType<typeof useImportXlsxPpListMutation>;
export type ImportXlsxPpListMutationResult = Apollo.MutationResult<ImportXlsxPpListMutation>;
export type ImportXlsxPpListMutationOptions = Apollo.BaseMutationOptions<ImportXlsxPpListMutation, ImportXlsxPpListMutationVariables>;
export const ImportXlsxPpListPerFspDocument = gql`
    mutation importXlsxPPListPerFsp($paymentPlanId: ID!, $file: Upload!) {
  importXlsxPaymentPlanPaymentListPerFsp(
    paymentPlanId: $paymentPlanId
    file: $file
  ) {
    paymentPlan {
      id
      status
    }
    errors {
      sheet
      coordinates
      message
    }
  }
}
    `;
export type ImportXlsxPpListPerFspMutationFn = Apollo.MutationFunction<ImportXlsxPpListPerFspMutation, ImportXlsxPpListPerFspMutationVariables>;

/**
 * __useImportXlsxPpListPerFspMutation__
 *
 * To run a mutation, you first call `useImportXlsxPpListPerFspMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportXlsxPpListPerFspMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importXlsxPpListPerFspMutation, { data, loading, error }] = useImportXlsxPpListPerFspMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useImportXlsxPpListPerFspMutation(baseOptions?: Apollo.MutationHookOptions<ImportXlsxPpListPerFspMutation, ImportXlsxPpListPerFspMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportXlsxPpListPerFspMutation, ImportXlsxPpListPerFspMutationVariables>(ImportXlsxPpListPerFspDocument, options);
      }
export type ImportXlsxPpListPerFspMutationHookResult = ReturnType<typeof useImportXlsxPpListPerFspMutation>;
export type ImportXlsxPpListPerFspMutationResult = Apollo.MutationResult<ImportXlsxPpListPerFspMutation>;
export type ImportXlsxPpListPerFspMutationOptions = Apollo.BaseMutationOptions<ImportXlsxPpListPerFspMutation, ImportXlsxPpListPerFspMutationVariables>;
export const MarkPayAsFailedDocument = gql`
    mutation markPayAsFailed($paymentId: ID!) {
  markPaymentAsFailed(paymentId: $paymentId) {
    payment {
      id
      unicefId
      status
      statusDate
      deliveredQuantity
      deliveryDate
    }
  }
}
    `;
export type MarkPayAsFailedMutationFn = Apollo.MutationFunction<MarkPayAsFailedMutation, MarkPayAsFailedMutationVariables>;

/**
 * __useMarkPayAsFailedMutation__
 *
 * To run a mutation, you first call `useMarkPayAsFailedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMarkPayAsFailedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [markPayAsFailedMutation, { data, loading, error }] = useMarkPayAsFailedMutation({
 *   variables: {
 *      paymentId: // value for 'paymentId'
 *   },
 * });
 */
export function useMarkPayAsFailedMutation(baseOptions?: Apollo.MutationHookOptions<MarkPayAsFailedMutation, MarkPayAsFailedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MarkPayAsFailedMutation, MarkPayAsFailedMutationVariables>(MarkPayAsFailedDocument, options);
      }
export type MarkPayAsFailedMutationHookResult = ReturnType<typeof useMarkPayAsFailedMutation>;
export type MarkPayAsFailedMutationResult = Apollo.MutationResult<MarkPayAsFailedMutation>;
export type MarkPayAsFailedMutationOptions = Apollo.BaseMutationOptions<MarkPayAsFailedMutation, MarkPayAsFailedMutationVariables>;
export const RevertMarkPayAsFailedDocument = gql`
    mutation revertMarkPayAsFailed($paymentId: ID!, $deliveredQuantity: Decimal!, $deliveryDate: Date!) {
  revertMarkPaymentAsFailed(
    paymentId: $paymentId
    deliveredQuantity: $deliveredQuantity
    deliveryDate: $deliveryDate
  ) {
    payment {
      id
      unicefId
      status
      statusDate
      deliveredQuantity
      deliveryDate
    }
  }
}
    `;
export type RevertMarkPayAsFailedMutationFn = Apollo.MutationFunction<RevertMarkPayAsFailedMutation, RevertMarkPayAsFailedMutationVariables>;

/**
 * __useRevertMarkPayAsFailedMutation__
 *
 * To run a mutation, you first call `useRevertMarkPayAsFailedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevertMarkPayAsFailedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revertMarkPayAsFailedMutation, { data, loading, error }] = useRevertMarkPayAsFailedMutation({
 *   variables: {
 *      paymentId: // value for 'paymentId'
 *      deliveredQuantity: // value for 'deliveredQuantity'
 *      deliveryDate: // value for 'deliveryDate'
 *   },
 * });
 */
export function useRevertMarkPayAsFailedMutation(baseOptions?: Apollo.MutationHookOptions<RevertMarkPayAsFailedMutation, RevertMarkPayAsFailedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevertMarkPayAsFailedMutation, RevertMarkPayAsFailedMutationVariables>(RevertMarkPayAsFailedDocument, options);
      }
export type RevertMarkPayAsFailedMutationHookResult = ReturnType<typeof useRevertMarkPayAsFailedMutation>;
export type RevertMarkPayAsFailedMutationResult = Apollo.MutationResult<RevertMarkPayAsFailedMutation>;
export type RevertMarkPayAsFailedMutationOptions = Apollo.BaseMutationOptions<RevertMarkPayAsFailedMutation, RevertMarkPayAsFailedMutationVariables>;
export const SetSteficonRuleOnPpListDocument = gql`
    mutation SetSteficonRuleOnPPList($paymentPlanId: ID!, $steficonRuleId: ID!) {
  setSteficonRuleOnPaymentPlanPaymentList(
    paymentPlanId: $paymentPlanId
    steficonRuleId: $steficonRuleId
  ) {
    paymentPlan {
      id
      steficonRule {
        id
        rule {
          id
          name
        }
      }
    }
  }
}
    `;
export type SetSteficonRuleOnPpListMutationFn = Apollo.MutationFunction<SetSteficonRuleOnPpListMutation, SetSteficonRuleOnPpListMutationVariables>;

/**
 * __useSetSteficonRuleOnPpListMutation__
 *
 * To run a mutation, you first call `useSetSteficonRuleOnPpListMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetSteficonRuleOnPpListMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setSteficonRuleOnPpListMutation, { data, loading, error }] = useSetSteficonRuleOnPpListMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *      steficonRuleId: // value for 'steficonRuleId'
 *   },
 * });
 */
export function useSetSteficonRuleOnPpListMutation(baseOptions?: Apollo.MutationHookOptions<SetSteficonRuleOnPpListMutation, SetSteficonRuleOnPpListMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetSteficonRuleOnPpListMutation, SetSteficonRuleOnPpListMutationVariables>(SetSteficonRuleOnPpListDocument, options);
      }
export type SetSteficonRuleOnPpListMutationHookResult = ReturnType<typeof useSetSteficonRuleOnPpListMutation>;
export type SetSteficonRuleOnPpListMutationResult = Apollo.MutationResult<SetSteficonRuleOnPpListMutation>;
export type SetSteficonRuleOnPpListMutationOptions = Apollo.BaseMutationOptions<SetSteficonRuleOnPpListMutation, SetSteficonRuleOnPpListMutationVariables>;
export const ActivatePaymentVerificationPlanDocument = gql`
    mutation ActivatePaymentVerificationPlan($paymentVerificationPlanId: ID!) {
  activatePaymentVerificationPlan(
    paymentVerificationPlanId: $paymentVerificationPlanId
  ) {
    paymentPlan {
      id
      verificationPlans {
        edges {
          node {
            id
            status
            activationDate
          }
        }
      }
      paymentVerificationSummary {
        id
        status
        activationDate
      }
    }
    validationErrors
  }
}
    `;
export type ActivatePaymentVerificationPlanMutationFn = Apollo.MutationFunction<ActivatePaymentVerificationPlanMutation, ActivatePaymentVerificationPlanMutationVariables>;

/**
 * __useActivatePaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useActivatePaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useActivatePaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [activatePaymentVerificationPlanMutation, { data, loading, error }] = useActivatePaymentVerificationPlanMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *   },
 * });
 */
export function useActivatePaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<ActivatePaymentVerificationPlanMutation, ActivatePaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ActivatePaymentVerificationPlanMutation, ActivatePaymentVerificationPlanMutationVariables>(ActivatePaymentVerificationPlanDocument, options);
      }
export type ActivatePaymentVerificationPlanMutationHookResult = ReturnType<typeof useActivatePaymentVerificationPlanMutation>;
export type ActivatePaymentVerificationPlanMutationResult = Apollo.MutationResult<ActivatePaymentVerificationPlanMutation>;
export type ActivatePaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<ActivatePaymentVerificationPlanMutation, ActivatePaymentVerificationPlanMutationVariables>;
export const CreatePaymentVerificationPlanDocument = gql`
    mutation CreatePaymentVerificationPlan($input: CreatePaymentVerificationInput!, $version: BigInt) {
  createPaymentVerificationPlan(input: $input, version: $version) {
    paymentPlan {
      id
    }
  }
}
    `;
export type CreatePaymentVerificationPlanMutationFn = Apollo.MutationFunction<CreatePaymentVerificationPlanMutation, CreatePaymentVerificationPlanMutationVariables>;

/**
 * __useCreatePaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useCreatePaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPaymentVerificationPlanMutation, { data, loading, error }] = useCreatePaymentVerificationPlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useCreatePaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<CreatePaymentVerificationPlanMutation, CreatePaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePaymentVerificationPlanMutation, CreatePaymentVerificationPlanMutationVariables>(CreatePaymentVerificationPlanDocument, options);
      }
export type CreatePaymentVerificationPlanMutationHookResult = ReturnType<typeof useCreatePaymentVerificationPlanMutation>;
export type CreatePaymentVerificationPlanMutationResult = Apollo.MutationResult<CreatePaymentVerificationPlanMutation>;
export type CreatePaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<CreatePaymentVerificationPlanMutation, CreatePaymentVerificationPlanMutationVariables>;
export const DeletePaymentVerificationPlanDocument = gql`
    mutation DeletePaymentVerificationPlan($paymentVerificationPlanId: ID!) {
  deletePaymentVerificationPlan(
    paymentVerificationPlanId: $paymentVerificationPlanId
  ) {
    paymentPlan {
      id
      verificationPlans {
        totalCount
        edges {
          node {
            id
            status
            sampleSize
            receivedCount
            notReceivedCount
            respondedCount
            receivedCount
            receivedWithProblemsCount
            activationDate
          }
        }
      }
      paymentVerificationSummary {
        id
        status
      }
    }
  }
}
    `;
export type DeletePaymentVerificationPlanMutationFn = Apollo.MutationFunction<DeletePaymentVerificationPlanMutation, DeletePaymentVerificationPlanMutationVariables>;

/**
 * __useDeletePaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useDeletePaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePaymentVerificationPlanMutation, { data, loading, error }] = useDeletePaymentVerificationPlanMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *   },
 * });
 */
export function useDeletePaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<DeletePaymentVerificationPlanMutation, DeletePaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePaymentVerificationPlanMutation, DeletePaymentVerificationPlanMutationVariables>(DeletePaymentVerificationPlanDocument, options);
      }
export type DeletePaymentVerificationPlanMutationHookResult = ReturnType<typeof useDeletePaymentVerificationPlanMutation>;
export type DeletePaymentVerificationPlanMutationResult = Apollo.MutationResult<DeletePaymentVerificationPlanMutation>;
export type DeletePaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<DeletePaymentVerificationPlanMutation, DeletePaymentVerificationPlanMutationVariables>;
export const DiscardPaymentVerificationPlanDocument = gql`
    mutation DiscardPaymentVerificationPlan($paymentVerificationPlanId: ID!) {
  discardPaymentVerificationPlan(
    paymentVerificationPlanId: $paymentVerificationPlanId
  ) {
    paymentPlan {
      id
      verificationPlans {
        totalCount
        edges {
          node {
            id
            status
            sampleSize
            receivedCount
            notReceivedCount
            respondedCount
            receivedCount
            receivedWithProblemsCount
            activationDate
          }
        }
      }
      paymentVerificationSummary {
        id
        status
      }
    }
  }
}
    `;
export type DiscardPaymentVerificationPlanMutationFn = Apollo.MutationFunction<DiscardPaymentVerificationPlanMutation, DiscardPaymentVerificationPlanMutationVariables>;

/**
 * __useDiscardPaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useDiscardPaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDiscardPaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [discardPaymentVerificationPlanMutation, { data, loading, error }] = useDiscardPaymentVerificationPlanMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *   },
 * });
 */
export function useDiscardPaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<DiscardPaymentVerificationPlanMutation, DiscardPaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DiscardPaymentVerificationPlanMutation, DiscardPaymentVerificationPlanMutationVariables>(DiscardPaymentVerificationPlanDocument, options);
      }
export type DiscardPaymentVerificationPlanMutationHookResult = ReturnType<typeof useDiscardPaymentVerificationPlanMutation>;
export type DiscardPaymentVerificationPlanMutationResult = Apollo.MutationResult<DiscardPaymentVerificationPlanMutation>;
export type DiscardPaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<DiscardPaymentVerificationPlanMutation, DiscardPaymentVerificationPlanMutationVariables>;
export const EditPaymentVerificationPlanDocument = gql`
    mutation EditPaymentVerificationPlan($input: EditPaymentVerificationInput!) {
  editPaymentVerificationPlan(input: $input) {
    paymentPlan {
      id
    }
  }
}
    `;
export type EditPaymentVerificationPlanMutationFn = Apollo.MutationFunction<EditPaymentVerificationPlanMutation, EditPaymentVerificationPlanMutationVariables>;

/**
 * __useEditPaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useEditPaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPaymentVerificationPlanMutation, { data, loading, error }] = useEditPaymentVerificationPlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditPaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<EditPaymentVerificationPlanMutation, EditPaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditPaymentVerificationPlanMutation, EditPaymentVerificationPlanMutationVariables>(EditPaymentVerificationPlanDocument, options);
      }
export type EditPaymentVerificationPlanMutationHookResult = ReturnType<typeof useEditPaymentVerificationPlanMutation>;
export type EditPaymentVerificationPlanMutationResult = Apollo.MutationResult<EditPaymentVerificationPlanMutation>;
export type EditPaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<EditPaymentVerificationPlanMutation, EditPaymentVerificationPlanMutationVariables>;
export const ExportXlsxPaymentVerificationPlanFileDocument = gql`
    mutation ExportXlsxPaymentVerificationPlanFile($paymentVerificationPlanId: ID!) {
  exportXlsxPaymentVerificationPlanFile(
    paymentVerificationPlanId: $paymentVerificationPlanId
  ) {
    paymentPlan {
      id
    }
  }
}
    `;
export type ExportXlsxPaymentVerificationPlanFileMutationFn = Apollo.MutationFunction<ExportXlsxPaymentVerificationPlanFileMutation, ExportXlsxPaymentVerificationPlanFileMutationVariables>;

/**
 * __useExportXlsxPaymentVerificationPlanFileMutation__
 *
 * To run a mutation, you first call `useExportXlsxPaymentVerificationPlanFileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useExportXlsxPaymentVerificationPlanFileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [exportXlsxPaymentVerificationPlanFileMutation, { data, loading, error }] = useExportXlsxPaymentVerificationPlanFileMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *   },
 * });
 */
export function useExportXlsxPaymentVerificationPlanFileMutation(baseOptions?: Apollo.MutationHookOptions<ExportXlsxPaymentVerificationPlanFileMutation, ExportXlsxPaymentVerificationPlanFileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ExportXlsxPaymentVerificationPlanFileMutation, ExportXlsxPaymentVerificationPlanFileMutationVariables>(ExportXlsxPaymentVerificationPlanFileDocument, options);
      }
export type ExportXlsxPaymentVerificationPlanFileMutationHookResult = ReturnType<typeof useExportXlsxPaymentVerificationPlanFileMutation>;
export type ExportXlsxPaymentVerificationPlanFileMutationResult = Apollo.MutationResult<ExportXlsxPaymentVerificationPlanFileMutation>;
export type ExportXlsxPaymentVerificationPlanFileMutationOptions = Apollo.BaseMutationOptions<ExportXlsxPaymentVerificationPlanFileMutation, ExportXlsxPaymentVerificationPlanFileMutationVariables>;
export const FinishPaymentVerificationPlanDocument = gql`
    mutation FinishPaymentVerificationPlan($paymentVerificationPlanId: ID!) {
  finishPaymentVerificationPlan(
    paymentVerificationPlanId: $paymentVerificationPlanId
  ) {
    paymentPlan {
      id
      verificationPlans {
        totalCount
        edges {
          node {
            id
            status
            completionDate
          }
        }
      }
      paymentVerificationSummary {
        id
        status
      }
    }
  }
}
    `;
export type FinishPaymentVerificationPlanMutationFn = Apollo.MutationFunction<FinishPaymentVerificationPlanMutation, FinishPaymentVerificationPlanMutationVariables>;

/**
 * __useFinishPaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useFinishPaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFinishPaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [finishPaymentVerificationPlanMutation, { data, loading, error }] = useFinishPaymentVerificationPlanMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *   },
 * });
 */
export function useFinishPaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<FinishPaymentVerificationPlanMutation, FinishPaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FinishPaymentVerificationPlanMutation, FinishPaymentVerificationPlanMutationVariables>(FinishPaymentVerificationPlanDocument, options);
      }
export type FinishPaymentVerificationPlanMutationHookResult = ReturnType<typeof useFinishPaymentVerificationPlanMutation>;
export type FinishPaymentVerificationPlanMutationResult = Apollo.MutationResult<FinishPaymentVerificationPlanMutation>;
export type FinishPaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<FinishPaymentVerificationPlanMutation, FinishPaymentVerificationPlanMutationVariables>;
export const ImportXlsxPaymentVerificationPlanFileDocument = gql`
    mutation ImportXlsxPaymentVerificationPlanFile($paymentVerificationPlanId: ID!, $file: Upload!) {
  importXlsxPaymentVerificationPlanFile(
    paymentVerificationPlanId: $paymentVerificationPlanId
    file: $file
  ) {
    paymentPlan {
      id
    }
    errors {
      sheet
      coordinates
      message
    }
  }
}
    `;
export type ImportXlsxPaymentVerificationPlanFileMutationFn = Apollo.MutationFunction<ImportXlsxPaymentVerificationPlanFileMutation, ImportXlsxPaymentVerificationPlanFileMutationVariables>;

/**
 * __useImportXlsxPaymentVerificationPlanFileMutation__
 *
 * To run a mutation, you first call `useImportXlsxPaymentVerificationPlanFileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportXlsxPaymentVerificationPlanFileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importXlsxPaymentVerificationPlanFileMutation, { data, loading, error }] = useImportXlsxPaymentVerificationPlanFileMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *      file: // value for 'file'
 *   },
 * });
 */
export function useImportXlsxPaymentVerificationPlanFileMutation(baseOptions?: Apollo.MutationHookOptions<ImportXlsxPaymentVerificationPlanFileMutation, ImportXlsxPaymentVerificationPlanFileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportXlsxPaymentVerificationPlanFileMutation, ImportXlsxPaymentVerificationPlanFileMutationVariables>(ImportXlsxPaymentVerificationPlanFileDocument, options);
      }
export type ImportXlsxPaymentVerificationPlanFileMutationHookResult = ReturnType<typeof useImportXlsxPaymentVerificationPlanFileMutation>;
export type ImportXlsxPaymentVerificationPlanFileMutationResult = Apollo.MutationResult<ImportXlsxPaymentVerificationPlanFileMutation>;
export type ImportXlsxPaymentVerificationPlanFileMutationOptions = Apollo.BaseMutationOptions<ImportXlsxPaymentVerificationPlanFileMutation, ImportXlsxPaymentVerificationPlanFileMutationVariables>;
export const InvalidPaymentVerificationPlanDocument = gql`
    mutation InvalidPaymentVerificationPlan($paymentVerificationPlanId: ID!) {
  invalidPaymentVerificationPlan(
    paymentVerificationPlanId: $paymentVerificationPlanId
  ) {
    paymentPlan {
      id
      verificationPlans {
        edges {
          node {
            id
            xlsxFileExporting
            hasXlsxFile
            xlsxFileWasDownloaded
            xlsxFileImported
          }
        }
      }
    }
  }
}
    `;
export type InvalidPaymentVerificationPlanMutationFn = Apollo.MutationFunction<InvalidPaymentVerificationPlanMutation, InvalidPaymentVerificationPlanMutationVariables>;

/**
 * __useInvalidPaymentVerificationPlanMutation__
 *
 * To run a mutation, you first call `useInvalidPaymentVerificationPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvalidPaymentVerificationPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invalidPaymentVerificationPlanMutation, { data, loading, error }] = useInvalidPaymentVerificationPlanMutation({
 *   variables: {
 *      paymentVerificationPlanId: // value for 'paymentVerificationPlanId'
 *   },
 * });
 */
export function useInvalidPaymentVerificationPlanMutation(baseOptions?: Apollo.MutationHookOptions<InvalidPaymentVerificationPlanMutation, InvalidPaymentVerificationPlanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InvalidPaymentVerificationPlanMutation, InvalidPaymentVerificationPlanMutationVariables>(InvalidPaymentVerificationPlanDocument, options);
      }
export type InvalidPaymentVerificationPlanMutationHookResult = ReturnType<typeof useInvalidPaymentVerificationPlanMutation>;
export type InvalidPaymentVerificationPlanMutationResult = Apollo.MutationResult<InvalidPaymentVerificationPlanMutation>;
export type InvalidPaymentVerificationPlanMutationOptions = Apollo.BaseMutationOptions<InvalidPaymentVerificationPlanMutation, InvalidPaymentVerificationPlanMutationVariables>;
export const MarkPrAsFailedDocument = gql`
    mutation markPRAsFailed($paymentRecordId: ID!) {
  markPaymentRecordAsFailed(paymentRecordId: $paymentRecordId) {
    paymentRecord {
      ...paymentRecordDetails
    }
  }
}
    ${PaymentRecordDetailsFragmentDoc}`;
export type MarkPrAsFailedMutationFn = Apollo.MutationFunction<MarkPrAsFailedMutation, MarkPrAsFailedMutationVariables>;

/**
 * __useMarkPrAsFailedMutation__
 *
 * To run a mutation, you first call `useMarkPrAsFailedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMarkPrAsFailedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [markPrAsFailedMutation, { data, loading, error }] = useMarkPrAsFailedMutation({
 *   variables: {
 *      paymentRecordId: // value for 'paymentRecordId'
 *   },
 * });
 */
export function useMarkPrAsFailedMutation(baseOptions?: Apollo.MutationHookOptions<MarkPrAsFailedMutation, MarkPrAsFailedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MarkPrAsFailedMutation, MarkPrAsFailedMutationVariables>(MarkPrAsFailedDocument, options);
      }
export type MarkPrAsFailedMutationHookResult = ReturnType<typeof useMarkPrAsFailedMutation>;
export type MarkPrAsFailedMutationResult = Apollo.MutationResult<MarkPrAsFailedMutation>;
export type MarkPrAsFailedMutationOptions = Apollo.BaseMutationOptions<MarkPrAsFailedMutation, MarkPrAsFailedMutationVariables>;
export const RevertMarkPrAsFailedDocument = gql`
    mutation revertMarkPRAsFailed($paymentRecordId: ID!, $deliveredQuantity: Decimal!, $deliveryDate: Date!) {
  revertMarkPaymentRecordAsFailed(
    paymentRecordId: $paymentRecordId
    deliveredQuantity: $deliveredQuantity
    deliveryDate: $deliveryDate
  ) {
    paymentRecord {
      ...paymentRecordDetails
    }
  }
}
    ${PaymentRecordDetailsFragmentDoc}`;
export type RevertMarkPrAsFailedMutationFn = Apollo.MutationFunction<RevertMarkPrAsFailedMutation, RevertMarkPrAsFailedMutationVariables>;

/**
 * __useRevertMarkPrAsFailedMutation__
 *
 * To run a mutation, you first call `useRevertMarkPrAsFailedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRevertMarkPrAsFailedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [revertMarkPrAsFailedMutation, { data, loading, error }] = useRevertMarkPrAsFailedMutation({
 *   variables: {
 *      paymentRecordId: // value for 'paymentRecordId'
 *      deliveredQuantity: // value for 'deliveredQuantity'
 *      deliveryDate: // value for 'deliveryDate'
 *   },
 * });
 */
export function useRevertMarkPrAsFailedMutation(baseOptions?: Apollo.MutationHookOptions<RevertMarkPrAsFailedMutation, RevertMarkPrAsFailedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RevertMarkPrAsFailedMutation, RevertMarkPrAsFailedMutationVariables>(RevertMarkPrAsFailedDocument, options);
      }
export type RevertMarkPrAsFailedMutationHookResult = ReturnType<typeof useRevertMarkPrAsFailedMutation>;
export type RevertMarkPrAsFailedMutationResult = Apollo.MutationResult<RevertMarkPrAsFailedMutation>;
export type RevertMarkPrAsFailedMutationOptions = Apollo.BaseMutationOptions<RevertMarkPrAsFailedMutation, RevertMarkPrAsFailedMutationVariables>;
export const SplitPpDocument = gql`
    mutation SplitPP($paymentPlanId: ID!, $splitType: String!, $paymentsNo: Int!) {
  splitPaymentPlan(
    paymentPlanId: $paymentPlanId
    splitType: $splitType
    paymentsNo: $paymentsNo
  ) {
    paymentPlan {
      id
    }
  }
}
    `;
export type SplitPpMutationFn = Apollo.MutationFunction<SplitPpMutation, SplitPpMutationVariables>;

/**
 * __useSplitPpMutation__
 *
 * To run a mutation, you first call `useSplitPpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSplitPpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [splitPpMutation, { data, loading, error }] = useSplitPpMutation({
 *   variables: {
 *      paymentPlanId: // value for 'paymentPlanId'
 *      splitType: // value for 'splitType'
 *      paymentsNo: // value for 'paymentsNo'
 *   },
 * });
 */
export function useSplitPpMutation(baseOptions?: Apollo.MutationHookOptions<SplitPpMutation, SplitPpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SplitPpMutation, SplitPpMutationVariables>(SplitPpDocument, options);
      }
export type SplitPpMutationHookResult = ReturnType<typeof useSplitPpMutation>;
export type SplitPpMutationResult = Apollo.MutationResult<SplitPpMutation>;
export type SplitPpMutationOptions = Apollo.BaseMutationOptions<SplitPpMutation, SplitPpMutationVariables>;
export const UpdatePaymentVerificationReceivedAndReceivedAmountDocument = gql`
    mutation updatePaymentVerificationReceivedAndReceivedAmount($paymentVerificationId: ID!, $receivedAmount: Decimal!, $received: Boolean!) {
  updatePaymentVerificationReceivedAndReceivedAmount(
    paymentVerificationId: $paymentVerificationId
    receivedAmount: $receivedAmount
    received: $received
  ) {
    paymentVerification {
      id
      status
      receivedAmount
      paymentVerificationPlan {
        id
        receivedCount
        notReceivedCount
        respondedCount
        receivedCount
        receivedWithProblemsCount
      }
    }
  }
}
    `;
export type UpdatePaymentVerificationReceivedAndReceivedAmountMutationFn = Apollo.MutationFunction<UpdatePaymentVerificationReceivedAndReceivedAmountMutation, UpdatePaymentVerificationReceivedAndReceivedAmountMutationVariables>;

/**
 * __useUpdatePaymentVerificationReceivedAndReceivedAmountMutation__
 *
 * To run a mutation, you first call `useUpdatePaymentVerificationReceivedAndReceivedAmountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePaymentVerificationReceivedAndReceivedAmountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePaymentVerificationReceivedAndReceivedAmountMutation, { data, loading, error }] = useUpdatePaymentVerificationReceivedAndReceivedAmountMutation({
 *   variables: {
 *      paymentVerificationId: // value for 'paymentVerificationId'
 *      receivedAmount: // value for 'receivedAmount'
 *      received: // value for 'received'
 *   },
 * });
 */
export function useUpdatePaymentVerificationReceivedAndReceivedAmountMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePaymentVerificationReceivedAndReceivedAmountMutation, UpdatePaymentVerificationReceivedAndReceivedAmountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePaymentVerificationReceivedAndReceivedAmountMutation, UpdatePaymentVerificationReceivedAndReceivedAmountMutationVariables>(UpdatePaymentVerificationReceivedAndReceivedAmountDocument, options);
      }
export type UpdatePaymentVerificationReceivedAndReceivedAmountMutationHookResult = ReturnType<typeof useUpdatePaymentVerificationReceivedAndReceivedAmountMutation>;
export type UpdatePaymentVerificationReceivedAndReceivedAmountMutationResult = Apollo.MutationResult<UpdatePaymentVerificationReceivedAndReceivedAmountMutation>;
export type UpdatePaymentVerificationReceivedAndReceivedAmountMutationOptions = Apollo.BaseMutationOptions<UpdatePaymentVerificationReceivedAndReceivedAmountMutation, UpdatePaymentVerificationReceivedAndReceivedAmountMutationVariables>;
export const UpdatePaymentVerificationStatusAndReceivedAmountDocument = gql`
    mutation updatePaymentVerificationStatusAndReceivedAmount($paymentVerificationId: ID!, $receivedAmount: Decimal!, $status: PaymentVerificationStatusForUpdate) {
  updatePaymentVerificationStatusAndReceivedAmount(
    paymentVerificationId: $paymentVerificationId
    receivedAmount: $receivedAmount
    status: $status
  ) {
    paymentVerification {
      id
      status
      receivedAmount
    }
  }
}
    `;
export type UpdatePaymentVerificationStatusAndReceivedAmountMutationFn = Apollo.MutationFunction<UpdatePaymentVerificationStatusAndReceivedAmountMutation, UpdatePaymentVerificationStatusAndReceivedAmountMutationVariables>;

/**
 * __useUpdatePaymentVerificationStatusAndReceivedAmountMutation__
 *
 * To run a mutation, you first call `useUpdatePaymentVerificationStatusAndReceivedAmountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePaymentVerificationStatusAndReceivedAmountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePaymentVerificationStatusAndReceivedAmountMutation, { data, loading, error }] = useUpdatePaymentVerificationStatusAndReceivedAmountMutation({
 *   variables: {
 *      paymentVerificationId: // value for 'paymentVerificationId'
 *      receivedAmount: // value for 'receivedAmount'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useUpdatePaymentVerificationStatusAndReceivedAmountMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePaymentVerificationStatusAndReceivedAmountMutation, UpdatePaymentVerificationStatusAndReceivedAmountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePaymentVerificationStatusAndReceivedAmountMutation, UpdatePaymentVerificationStatusAndReceivedAmountMutationVariables>(UpdatePaymentVerificationStatusAndReceivedAmountDocument, options);
      }
export type UpdatePaymentVerificationStatusAndReceivedAmountMutationHookResult = ReturnType<typeof useUpdatePaymentVerificationStatusAndReceivedAmountMutation>;
export type UpdatePaymentVerificationStatusAndReceivedAmountMutationResult = Apollo.MutationResult<UpdatePaymentVerificationStatusAndReceivedAmountMutation>;
export type UpdatePaymentVerificationStatusAndReceivedAmountMutationOptions = Apollo.BaseMutationOptions<UpdatePaymentVerificationStatusAndReceivedAmountMutation, UpdatePaymentVerificationStatusAndReceivedAmountMutationVariables>;
export const CopyProgramDocument = gql`
    mutation CopyProgram($programData: CopyProgramInput!) {
  copyProgram(programData: $programData) {
    program {
      id
    }
    validationErrors
  }
}
    `;
export type CopyProgramMutationFn = Apollo.MutationFunction<CopyProgramMutation, CopyProgramMutationVariables>;

/**
 * __useCopyProgramMutation__
 *
 * To run a mutation, you first call `useCopyProgramMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCopyProgramMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [copyProgramMutation, { data, loading, error }] = useCopyProgramMutation({
 *   variables: {
 *      programData: // value for 'programData'
 *   },
 * });
 */
export function useCopyProgramMutation(baseOptions?: Apollo.MutationHookOptions<CopyProgramMutation, CopyProgramMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CopyProgramMutation, CopyProgramMutationVariables>(CopyProgramDocument, options);
      }
export type CopyProgramMutationHookResult = ReturnType<typeof useCopyProgramMutation>;
export type CopyProgramMutationResult = Apollo.MutationResult<CopyProgramMutation>;
export type CopyProgramMutationOptions = Apollo.BaseMutationOptions<CopyProgramMutation, CopyProgramMutationVariables>;
export const CreateProgramDocument = gql`
    mutation CreateProgram($programData: CreateProgramInput!) {
  createProgram(programData: $programData) {
    program {
      id
      name
      programmeCode
      status
      startDate
      endDate
      caId
      budget
      description
      frequencyOfPayments
      sector
      scope
      cashPlus
      populationGoal
      dataCollectingType {
        id
        code
        label
        active
        individualFiltersAvailable
      }
    }
    validationErrors
  }
}
    `;
export type CreateProgramMutationFn = Apollo.MutationFunction<CreateProgramMutation, CreateProgramMutationVariables>;

/**
 * __useCreateProgramMutation__
 *
 * To run a mutation, you first call `useCreateProgramMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProgramMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProgramMutation, { data, loading, error }] = useCreateProgramMutation({
 *   variables: {
 *      programData: // value for 'programData'
 *   },
 * });
 */
export function useCreateProgramMutation(baseOptions?: Apollo.MutationHookOptions<CreateProgramMutation, CreateProgramMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProgramMutation, CreateProgramMutationVariables>(CreateProgramDocument, options);
      }
export type CreateProgramMutationHookResult = ReturnType<typeof useCreateProgramMutation>;
export type CreateProgramMutationResult = Apollo.MutationResult<CreateProgramMutation>;
export type CreateProgramMutationOptions = Apollo.BaseMutationOptions<CreateProgramMutation, CreateProgramMutationVariables>;
export const DeleteProgramDocument = gql`
    mutation DeleteProgram($programId: String!) {
  deleteProgram(programId: $programId) {
    ok
  }
}
    `;
export type DeleteProgramMutationFn = Apollo.MutationFunction<DeleteProgramMutation, DeleteProgramMutationVariables>;

/**
 * __useDeleteProgramMutation__
 *
 * To run a mutation, you first call `useDeleteProgramMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProgramMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProgramMutation, { data, loading, error }] = useDeleteProgramMutation({
 *   variables: {
 *      programId: // value for 'programId'
 *   },
 * });
 */
export function useDeleteProgramMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProgramMutation, DeleteProgramMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProgramMutation, DeleteProgramMutationVariables>(DeleteProgramDocument, options);
      }
export type DeleteProgramMutationHookResult = ReturnType<typeof useDeleteProgramMutation>;
export type DeleteProgramMutationResult = Apollo.MutationResult<DeleteProgramMutation>;
export type DeleteProgramMutationOptions = Apollo.BaseMutationOptions<DeleteProgramMutation, DeleteProgramMutationVariables>;
export const UpdateProgramDocument = gql`
    mutation UpdateProgram($programData: UpdateProgramInput!, $version: BigInt!) {
  updateProgram(programData: $programData, version: $version) {
    program {
      id
      name
      programmeCode
      startDate
      endDate
      status
      caId
      caHashId
      description
      budget
      frequencyOfPayments
      cashPlus
      populationGoal
      scope
      sector
      totalNumberOfHouseholds
      totalNumberOfHouseholdsWithTpInProgram
      administrativeAreasOfImplementation
      version
      dataCollectingType {
        id
        code
        label
        active
        individualFiltersAvailable
        householdFiltersAvailable
        description
      }
      partners {
        id
        name
        areaAccess
        adminAreas {
          ids
          level
          totalCount
        }
      }
    }
    validationErrors
  }
}
    `;
export type UpdateProgramMutationFn = Apollo.MutationFunction<UpdateProgramMutation, UpdateProgramMutationVariables>;

/**
 * __useUpdateProgramMutation__
 *
 * To run a mutation, you first call `useUpdateProgramMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProgramMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProgramMutation, { data, loading, error }] = useUpdateProgramMutation({
 *   variables: {
 *      programData: // value for 'programData'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useUpdateProgramMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProgramMutation, UpdateProgramMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProgramMutation, UpdateProgramMutationVariables>(UpdateProgramDocument, options);
      }
export type UpdateProgramMutationHookResult = ReturnType<typeof useUpdateProgramMutation>;
export type UpdateProgramMutationResult = Apollo.MutationResult<UpdateProgramMutation>;
export type UpdateProgramMutationOptions = Apollo.BaseMutationOptions<UpdateProgramMutation, UpdateProgramMutationVariables>;
export const CreateRegistrationKoboImportDocument = gql`
    mutation CreateRegistrationKoboImport($registrationDataImportData: RegistrationKoboImportMutationInput!) {
  registrationKoboImport(registrationDataImportData: $registrationDataImportData) {
    registrationDataImport {
      id
      name
      dataSource
      datahubId
      screenBeneficiary
    }
    validationErrors
  }
}
    `;
export type CreateRegistrationKoboImportMutationFn = Apollo.MutationFunction<CreateRegistrationKoboImportMutation, CreateRegistrationKoboImportMutationVariables>;

/**
 * __useCreateRegistrationKoboImportMutation__
 *
 * To run a mutation, you first call `useCreateRegistrationKoboImportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRegistrationKoboImportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRegistrationKoboImportMutation, { data, loading, error }] = useCreateRegistrationKoboImportMutation({
 *   variables: {
 *      registrationDataImportData: // value for 'registrationDataImportData'
 *   },
 * });
 */
export function useCreateRegistrationKoboImportMutation(baseOptions?: Apollo.MutationHookOptions<CreateRegistrationKoboImportMutation, CreateRegistrationKoboImportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRegistrationKoboImportMutation, CreateRegistrationKoboImportMutationVariables>(CreateRegistrationKoboImportDocument, options);
      }
export type CreateRegistrationKoboImportMutationHookResult = ReturnType<typeof useCreateRegistrationKoboImportMutation>;
export type CreateRegistrationKoboImportMutationResult = Apollo.MutationResult<CreateRegistrationKoboImportMutation>;
export type CreateRegistrationKoboImportMutationOptions = Apollo.BaseMutationOptions<CreateRegistrationKoboImportMutation, CreateRegistrationKoboImportMutationVariables>;
export const CreateRegistrationXlsxImportDocument = gql`
    mutation CreateRegistrationXlsxImport($registrationDataImportData: RegistrationXlsxImportMutationInput!) {
  registrationXlsxImport(registrationDataImportData: $registrationDataImportData) {
    registrationDataImport {
      id
      name
      dataSource
      datahubId
      screenBeneficiary
    }
    validationErrors
  }
}
    `;
export type CreateRegistrationXlsxImportMutationFn = Apollo.MutationFunction<CreateRegistrationXlsxImportMutation, CreateRegistrationXlsxImportMutationVariables>;

/**
 * __useCreateRegistrationXlsxImportMutation__
 *
 * To run a mutation, you first call `useCreateRegistrationXlsxImportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRegistrationXlsxImportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRegistrationXlsxImportMutation, { data, loading, error }] = useCreateRegistrationXlsxImportMutation({
 *   variables: {
 *      registrationDataImportData: // value for 'registrationDataImportData'
 *   },
 * });
 */
export function useCreateRegistrationXlsxImportMutation(baseOptions?: Apollo.MutationHookOptions<CreateRegistrationXlsxImportMutation, CreateRegistrationXlsxImportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRegistrationXlsxImportMutation, CreateRegistrationXlsxImportMutationVariables>(CreateRegistrationXlsxImportDocument, options);
      }
export type CreateRegistrationXlsxImportMutationHookResult = ReturnType<typeof useCreateRegistrationXlsxImportMutation>;
export type CreateRegistrationXlsxImportMutationResult = Apollo.MutationResult<CreateRegistrationXlsxImportMutation>;
export type CreateRegistrationXlsxImportMutationOptions = Apollo.BaseMutationOptions<CreateRegistrationXlsxImportMutation, CreateRegistrationXlsxImportMutationVariables>;
export const EraseRdiDocument = gql`
    mutation eraseRDI($id: ID!) {
  eraseRegistrationDataImport(id: $id) {
    registrationDataImport {
      id
      status
      erased
    }
  }
}
    `;
export type EraseRdiMutationFn = Apollo.MutationFunction<EraseRdiMutation, EraseRdiMutationVariables>;

/**
 * __useEraseRdiMutation__
 *
 * To run a mutation, you first call `useEraseRdiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEraseRdiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [eraseRdiMutation, { data, loading, error }] = useEraseRdiMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEraseRdiMutation(baseOptions?: Apollo.MutationHookOptions<EraseRdiMutation, EraseRdiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EraseRdiMutation, EraseRdiMutationVariables>(EraseRdiDocument, options);
      }
export type EraseRdiMutationHookResult = ReturnType<typeof useEraseRdiMutation>;
export type EraseRdiMutationResult = Apollo.MutationResult<EraseRdiMutation>;
export type EraseRdiMutationOptions = Apollo.BaseMutationOptions<EraseRdiMutation, EraseRdiMutationVariables>;
export const MergeRdiDocument = gql`
    mutation MergeRDI($id: ID!) {
  mergeRegistrationDataImport(id: $id) {
    registrationDataImport {
      ...registrationDetailed
    }
  }
}
    ${RegistrationDetailedFragmentDoc}`;
export type MergeRdiMutationFn = Apollo.MutationFunction<MergeRdiMutation, MergeRdiMutationVariables>;

/**
 * __useMergeRdiMutation__
 *
 * To run a mutation, you first call `useMergeRdiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMergeRdiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [mergeRdiMutation, { data, loading, error }] = useMergeRdiMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMergeRdiMutation(baseOptions?: Apollo.MutationHookOptions<MergeRdiMutation, MergeRdiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MergeRdiMutation, MergeRdiMutationVariables>(MergeRdiDocument, options);
      }
export type MergeRdiMutationHookResult = ReturnType<typeof useMergeRdiMutation>;
export type MergeRdiMutationResult = Apollo.MutationResult<MergeRdiMutation>;
export type MergeRdiMutationOptions = Apollo.BaseMutationOptions<MergeRdiMutation, MergeRdiMutationVariables>;
export const RefuseRdiDocument = gql`
    mutation RefuseRDI($id: ID!, $refuseReason: String) {
  refuseRegistrationDataImport(id: $id, refuseReason: $refuseReason) {
    registrationDataImport {
      id
      status
      refuseReason
    }
  }
}
    `;
export type RefuseRdiMutationFn = Apollo.MutationFunction<RefuseRdiMutation, RefuseRdiMutationVariables>;

/**
 * __useRefuseRdiMutation__
 *
 * To run a mutation, you first call `useRefuseRdiMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefuseRdiMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refuseRdiMutation, { data, loading, error }] = useRefuseRdiMutation({
 *   variables: {
 *      id: // value for 'id'
 *      refuseReason: // value for 'refuseReason'
 *   },
 * });
 */
export function useRefuseRdiMutation(baseOptions?: Apollo.MutationHookOptions<RefuseRdiMutation, RefuseRdiMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefuseRdiMutation, RefuseRdiMutationVariables>(RefuseRdiDocument, options);
      }
export type RefuseRdiMutationHookResult = ReturnType<typeof useRefuseRdiMutation>;
export type RefuseRdiMutationResult = Apollo.MutationResult<RefuseRdiMutation>;
export type RefuseRdiMutationOptions = Apollo.BaseMutationOptions<RefuseRdiMutation, RefuseRdiMutationVariables>;
export const RerunDedupeDocument = gql`
    mutation RerunDedupe($registrationDataImportDatahubId: ID!) {
  rerunDedupe(registrationDataImportDatahubId: $registrationDataImportDatahubId) {
    ok
  }
}
    `;
export type RerunDedupeMutationFn = Apollo.MutationFunction<RerunDedupeMutation, RerunDedupeMutationVariables>;

/**
 * __useRerunDedupeMutation__
 *
 * To run a mutation, you first call `useRerunDedupeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRerunDedupeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rerunDedupeMutation, { data, loading, error }] = useRerunDedupeMutation({
 *   variables: {
 *      registrationDataImportDatahubId: // value for 'registrationDataImportDatahubId'
 *   },
 * });
 */
export function useRerunDedupeMutation(baseOptions?: Apollo.MutationHookOptions<RerunDedupeMutation, RerunDedupeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RerunDedupeMutation, RerunDedupeMutationVariables>(RerunDedupeDocument, options);
      }
export type RerunDedupeMutationHookResult = ReturnType<typeof useRerunDedupeMutation>;
export type RerunDedupeMutationResult = Apollo.MutationResult<RerunDedupeMutation>;
export type RerunDedupeMutationOptions = Apollo.BaseMutationOptions<RerunDedupeMutation, RerunDedupeMutationVariables>;
export const SaveKoboImportDataDocument = gql`
    mutation SaveKoboImportData($businessAreaSlug: String!, $projectId: Upload!, $onlyActiveSubmissions: Boolean!) {
  saveKoboImportDataAsync(
    businessAreaSlug: $businessAreaSlug
    uid: $projectId
    onlyActiveSubmissions: $onlyActiveSubmissions
  ) {
    importData {
      id
    }
  }
}
    `;
export type SaveKoboImportDataMutationFn = Apollo.MutationFunction<SaveKoboImportDataMutation, SaveKoboImportDataMutationVariables>;

/**
 * __useSaveKoboImportDataMutation__
 *
 * To run a mutation, you first call `useSaveKoboImportDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveKoboImportDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveKoboImportDataMutation, { data, loading, error }] = useSaveKoboImportDataMutation({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *      projectId: // value for 'projectId'
 *      onlyActiveSubmissions: // value for 'onlyActiveSubmissions'
 *   },
 * });
 */
export function useSaveKoboImportDataMutation(baseOptions?: Apollo.MutationHookOptions<SaveKoboImportDataMutation, SaveKoboImportDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveKoboImportDataMutation, SaveKoboImportDataMutationVariables>(SaveKoboImportDataDocument, options);
      }
export type SaveKoboImportDataMutationHookResult = ReturnType<typeof useSaveKoboImportDataMutation>;
export type SaveKoboImportDataMutationResult = Apollo.MutationResult<SaveKoboImportDataMutation>;
export type SaveKoboImportDataMutationOptions = Apollo.BaseMutationOptions<SaveKoboImportDataMutation, SaveKoboImportDataMutationVariables>;
export const SaveKoboImportDataAsyncDocument = gql`
    mutation SaveKoboImportDataAsync($businessAreaSlug: String!, $koboAssetId: Upload!, $onlyActiveSubmissions: Boolean!) {
  saveKoboImportDataAsync(
    businessAreaSlug: $businessAreaSlug
    uid: $koboAssetId
    onlyActiveSubmissions: $onlyActiveSubmissions
  ) {
    importData {
      id
      status
    }
  }
}
    `;
export type SaveKoboImportDataAsyncMutationFn = Apollo.MutationFunction<SaveKoboImportDataAsyncMutation, SaveKoboImportDataAsyncMutationVariables>;

/**
 * __useSaveKoboImportDataAsyncMutation__
 *
 * To run a mutation, you first call `useSaveKoboImportDataAsyncMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveKoboImportDataAsyncMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveKoboImportDataAsyncMutation, { data, loading, error }] = useSaveKoboImportDataAsyncMutation({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *      koboAssetId: // value for 'koboAssetId'
 *      onlyActiveSubmissions: // value for 'onlyActiveSubmissions'
 *   },
 * });
 */
export function useSaveKoboImportDataAsyncMutation(baseOptions?: Apollo.MutationHookOptions<SaveKoboImportDataAsyncMutation, SaveKoboImportDataAsyncMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveKoboImportDataAsyncMutation, SaveKoboImportDataAsyncMutationVariables>(SaveKoboImportDataAsyncDocument, options);
      }
export type SaveKoboImportDataAsyncMutationHookResult = ReturnType<typeof useSaveKoboImportDataAsyncMutation>;
export type SaveKoboImportDataAsyncMutationResult = Apollo.MutationResult<SaveKoboImportDataAsyncMutation>;
export type SaveKoboImportDataAsyncMutationOptions = Apollo.BaseMutationOptions<SaveKoboImportDataAsyncMutation, SaveKoboImportDataAsyncMutationVariables>;
export const UploadImportDataXlsxFileAsyncDocument = gql`
    mutation UploadImportDataXlsxFileAsync($file: Upload!, $businessAreaSlug: String!) {
  uploadImportDataXlsxFileAsync(file: $file, businessAreaSlug: $businessAreaSlug) {
    errors {
      header
      message
      rowNumber
    }
    importData {
      id
      numberOfIndividuals
      numberOfHouseholds
      registrationDataImport {
        id
      }
    }
  }
}
    `;
export type UploadImportDataXlsxFileAsyncMutationFn = Apollo.MutationFunction<UploadImportDataXlsxFileAsyncMutation, UploadImportDataXlsxFileAsyncMutationVariables>;

/**
 * __useUploadImportDataXlsxFileAsyncMutation__
 *
 * To run a mutation, you first call `useUploadImportDataXlsxFileAsyncMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadImportDataXlsxFileAsyncMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadImportDataXlsxFileAsyncMutation, { data, loading, error }] = useUploadImportDataXlsxFileAsyncMutation({
 *   variables: {
 *      file: // value for 'file'
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useUploadImportDataXlsxFileAsyncMutation(baseOptions?: Apollo.MutationHookOptions<UploadImportDataXlsxFileAsyncMutation, UploadImportDataXlsxFileAsyncMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadImportDataXlsxFileAsyncMutation, UploadImportDataXlsxFileAsyncMutationVariables>(UploadImportDataXlsxFileAsyncDocument, options);
      }
export type UploadImportDataXlsxFileAsyncMutationHookResult = ReturnType<typeof useUploadImportDataXlsxFileAsyncMutation>;
export type UploadImportDataXlsxFileAsyncMutationResult = Apollo.MutationResult<UploadImportDataXlsxFileAsyncMutation>;
export type UploadImportDataXlsxFileAsyncMutationOptions = Apollo.BaseMutationOptions<UploadImportDataXlsxFileAsyncMutation, UploadImportDataXlsxFileAsyncMutationVariables>;
export const CreateDashboardReportDocument = gql`
    mutation CreateDashboardReport($reportData: CreateDashboardReportInput!) {
  createDashboardReport(reportData: $reportData) {
    success
  }
}
    `;
export type CreateDashboardReportMutationFn = Apollo.MutationFunction<CreateDashboardReportMutation, CreateDashboardReportMutationVariables>;

/**
 * __useCreateDashboardReportMutation__
 *
 * To run a mutation, you first call `useCreateDashboardReportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDashboardReportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDashboardReportMutation, { data, loading, error }] = useCreateDashboardReportMutation({
 *   variables: {
 *      reportData: // value for 'reportData'
 *   },
 * });
 */
export function useCreateDashboardReportMutation(baseOptions?: Apollo.MutationHookOptions<CreateDashboardReportMutation, CreateDashboardReportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDashboardReportMutation, CreateDashboardReportMutationVariables>(CreateDashboardReportDocument, options);
      }
export type CreateDashboardReportMutationHookResult = ReturnType<typeof useCreateDashboardReportMutation>;
export type CreateDashboardReportMutationResult = Apollo.MutationResult<CreateDashboardReportMutation>;
export type CreateDashboardReportMutationOptions = Apollo.BaseMutationOptions<CreateDashboardReportMutation, CreateDashboardReportMutationVariables>;
export const CreateReportDocument = gql`
    mutation CreateReport($reportData: CreateReportInput!) {
  createReport(reportData: $reportData) {
    report {
      id
    }
  }
}
    `;
export type CreateReportMutationFn = Apollo.MutationFunction<CreateReportMutation, CreateReportMutationVariables>;

/**
 * __useCreateReportMutation__
 *
 * To run a mutation, you first call `useCreateReportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateReportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createReportMutation, { data, loading, error }] = useCreateReportMutation({
 *   variables: {
 *      reportData: // value for 'reportData'
 *   },
 * });
 */
export function useCreateReportMutation(baseOptions?: Apollo.MutationHookOptions<CreateReportMutation, CreateReportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateReportMutation, CreateReportMutationVariables>(CreateReportDocument, options);
      }
export type CreateReportMutationHookResult = ReturnType<typeof useCreateReportMutation>;
export type CreateReportMutationResult = Apollo.MutationResult<CreateReportMutation>;
export type CreateReportMutationOptions = Apollo.BaseMutationOptions<CreateReportMutation, CreateReportMutationVariables>;
export const RestartCreateReportDocument = gql`
    mutation RestartCreateReport($reportData: RestartCreateReportInput!) {
  restartCreateReport(reportData: $reportData) {
    report {
      id
      status
      reportType
      createdAt
      dateFrom
      dateTo
      fileUrl
      createdBy {
        firstName
        lastName
      }
      adminArea {
        edges {
          node {
            name
          }
        }
      }
      program {
        name
      }
    }
  }
}
    `;
export type RestartCreateReportMutationFn = Apollo.MutationFunction<RestartCreateReportMutation, RestartCreateReportMutationVariables>;

/**
 * __useRestartCreateReportMutation__
 *
 * To run a mutation, you first call `useRestartCreateReportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestartCreateReportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restartCreateReportMutation, { data, loading, error }] = useRestartCreateReportMutation({
 *   variables: {
 *      reportData: // value for 'reportData'
 *   },
 * });
 */
export function useRestartCreateReportMutation(baseOptions?: Apollo.MutationHookOptions<RestartCreateReportMutation, RestartCreateReportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestartCreateReportMutation, RestartCreateReportMutationVariables>(RestartCreateReportDocument, options);
      }
export type RestartCreateReportMutationHookResult = ReturnType<typeof useRestartCreateReportMutation>;
export type RestartCreateReportMutationResult = Apollo.MutationResult<RestartCreateReportMutation>;
export type RestartCreateReportMutationOptions = Apollo.BaseMutationOptions<RestartCreateReportMutation, RestartCreateReportMutationVariables>;
export const CreateTpDocument = gql`
    mutation CreateTP($input: CreateTargetPopulationInput!) {
  createTargetPopulation(input: $input) {
    targetPopulation {
      id
      status
      totalHouseholdsCount
      totalIndividualsCount
    }
    validationErrors
  }
}
    `;
export type CreateTpMutationFn = Apollo.MutationFunction<CreateTpMutation, CreateTpMutationVariables>;

/**
 * __useCreateTpMutation__
 *
 * To run a mutation, you first call `useCreateTpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTpMutation, { data, loading, error }] = useCreateTpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTpMutation(baseOptions?: Apollo.MutationHookOptions<CreateTpMutation, CreateTpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTpMutation, CreateTpMutationVariables>(CreateTpDocument, options);
      }
export type CreateTpMutationHookResult = ReturnType<typeof useCreateTpMutation>;
export type CreateTpMutationResult = Apollo.MutationResult<CreateTpMutation>;
export type CreateTpMutationOptions = Apollo.BaseMutationOptions<CreateTpMutation, CreateTpMutationVariables>;
export const DeleteTargetPopulationDocument = gql`
    mutation DeleteTargetPopulation($input: DeleteTargetPopulationMutationInput!) {
  deleteTargetPopulation(input: $input) {
    clientMutationId
  }
}
    `;
export type DeleteTargetPopulationMutationFn = Apollo.MutationFunction<DeleteTargetPopulationMutation, DeleteTargetPopulationMutationVariables>;

/**
 * __useDeleteTargetPopulationMutation__
 *
 * To run a mutation, you first call `useDeleteTargetPopulationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTargetPopulationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTargetPopulationMutation, { data, loading, error }] = useDeleteTargetPopulationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeleteTargetPopulationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTargetPopulationMutation, DeleteTargetPopulationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTargetPopulationMutation, DeleteTargetPopulationMutationVariables>(DeleteTargetPopulationDocument, options);
      }
export type DeleteTargetPopulationMutationHookResult = ReturnType<typeof useDeleteTargetPopulationMutation>;
export type DeleteTargetPopulationMutationResult = Apollo.MutationResult<DeleteTargetPopulationMutation>;
export type DeleteTargetPopulationMutationOptions = Apollo.BaseMutationOptions<DeleteTargetPopulationMutation, DeleteTargetPopulationMutationVariables>;
export const CopyTargetPopulationDocument = gql`
    mutation CopyTargetPopulation($input: CopyTargetPopulationMutationInput!) {
  copyTargetPopulation(input: $input) {
    clientMutationId
    targetPopulation {
      id
    }
    validationErrors
  }
}
    `;
export type CopyTargetPopulationMutationFn = Apollo.MutationFunction<CopyTargetPopulationMutation, CopyTargetPopulationMutationVariables>;

/**
 * __useCopyTargetPopulationMutation__
 *
 * To run a mutation, you first call `useCopyTargetPopulationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCopyTargetPopulationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [copyTargetPopulationMutation, { data, loading, error }] = useCopyTargetPopulationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCopyTargetPopulationMutation(baseOptions?: Apollo.MutationHookOptions<CopyTargetPopulationMutation, CopyTargetPopulationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CopyTargetPopulationMutation, CopyTargetPopulationMutationVariables>(CopyTargetPopulationDocument, options);
      }
export type CopyTargetPopulationMutationHookResult = ReturnType<typeof useCopyTargetPopulationMutation>;
export type CopyTargetPopulationMutationResult = Apollo.MutationResult<CopyTargetPopulationMutation>;
export type CopyTargetPopulationMutationOptions = Apollo.BaseMutationOptions<CopyTargetPopulationMutation, CopyTargetPopulationMutationVariables>;
export const FinalizeTpDocument = gql`
    mutation FinalizeTP($id: ID!) {
  finalizeTargetPopulation(id: $id) {
    targetPopulation {
      ...targetPopulationDetailed
    }
  }
}
    ${TargetPopulationDetailedFragmentDoc}`;
export type FinalizeTpMutationFn = Apollo.MutationFunction<FinalizeTpMutation, FinalizeTpMutationVariables>;

/**
 * __useFinalizeTpMutation__
 *
 * To run a mutation, you first call `useFinalizeTpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFinalizeTpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [finalizeTpMutation, { data, loading, error }] = useFinalizeTpMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFinalizeTpMutation(baseOptions?: Apollo.MutationHookOptions<FinalizeTpMutation, FinalizeTpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FinalizeTpMutation, FinalizeTpMutationVariables>(FinalizeTpDocument, options);
      }
export type FinalizeTpMutationHookResult = ReturnType<typeof useFinalizeTpMutation>;
export type FinalizeTpMutationResult = Apollo.MutationResult<FinalizeTpMutation>;
export type FinalizeTpMutationOptions = Apollo.BaseMutationOptions<FinalizeTpMutation, FinalizeTpMutationVariables>;
export const LockTpDocument = gql`
    mutation LockTP($id: ID!) {
  lockTargetPopulation(id: $id) {
    targetPopulation {
      ...targetPopulationDetailed
    }
  }
}
    ${TargetPopulationDetailedFragmentDoc}`;
export type LockTpMutationFn = Apollo.MutationFunction<LockTpMutation, LockTpMutationVariables>;

/**
 * __useLockTpMutation__
 *
 * To run a mutation, you first call `useLockTpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLockTpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lockTpMutation, { data, loading, error }] = useLockTpMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useLockTpMutation(baseOptions?: Apollo.MutationHookOptions<LockTpMutation, LockTpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LockTpMutation, LockTpMutationVariables>(LockTpDocument, options);
      }
export type LockTpMutationHookResult = ReturnType<typeof useLockTpMutation>;
export type LockTpMutationResult = Apollo.MutationResult<LockTpMutation>;
export type LockTpMutationOptions = Apollo.BaseMutationOptions<LockTpMutation, LockTpMutationVariables>;
export const RebuildTpDocument = gql`
    mutation RebuildTP($id: ID!) {
  targetPopulationRebuild(id: $id) {
    targetPopulation {
      ...targetPopulationDetailed
    }
  }
}
    ${TargetPopulationDetailedFragmentDoc}`;
export type RebuildTpMutationFn = Apollo.MutationFunction<RebuildTpMutation, RebuildTpMutationVariables>;

/**
 * __useRebuildTpMutation__
 *
 * To run a mutation, you first call `useRebuildTpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRebuildTpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rebuildTpMutation, { data, loading, error }] = useRebuildTpMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRebuildTpMutation(baseOptions?: Apollo.MutationHookOptions<RebuildTpMutation, RebuildTpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RebuildTpMutation, RebuildTpMutationVariables>(RebuildTpDocument, options);
      }
export type RebuildTpMutationHookResult = ReturnType<typeof useRebuildTpMutation>;
export type RebuildTpMutationResult = Apollo.MutationResult<RebuildTpMutation>;
export type RebuildTpMutationOptions = Apollo.BaseMutationOptions<RebuildTpMutation, RebuildTpMutationVariables>;
export const SetSteficonRuleOnTargetPopulationDocument = gql`
    mutation setSteficonRuleOnTargetPopulation($input: SetSteficonRuleOnTargetPopulationMutationInput!) {
  setSteficonRuleOnTargetPopulation(input: $input) {
    targetPopulation {
      ...targetPopulationDetailed
    }
  }
}
    ${TargetPopulationDetailedFragmentDoc}`;
export type SetSteficonRuleOnTargetPopulationMutationFn = Apollo.MutationFunction<SetSteficonRuleOnTargetPopulationMutation, SetSteficonRuleOnTargetPopulationMutationVariables>;

/**
 * __useSetSteficonRuleOnTargetPopulationMutation__
 *
 * To run a mutation, you first call `useSetSteficonRuleOnTargetPopulationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetSteficonRuleOnTargetPopulationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setSteficonRuleOnTargetPopulationMutation, { data, loading, error }] = useSetSteficonRuleOnTargetPopulationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSetSteficonRuleOnTargetPopulationMutation(baseOptions?: Apollo.MutationHookOptions<SetSteficonRuleOnTargetPopulationMutation, SetSteficonRuleOnTargetPopulationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetSteficonRuleOnTargetPopulationMutation, SetSteficonRuleOnTargetPopulationMutationVariables>(SetSteficonRuleOnTargetPopulationDocument, options);
      }
export type SetSteficonRuleOnTargetPopulationMutationHookResult = ReturnType<typeof useSetSteficonRuleOnTargetPopulationMutation>;
export type SetSteficonRuleOnTargetPopulationMutationResult = Apollo.MutationResult<SetSteficonRuleOnTargetPopulationMutation>;
export type SetSteficonRuleOnTargetPopulationMutationOptions = Apollo.BaseMutationOptions<SetSteficonRuleOnTargetPopulationMutation, SetSteficonRuleOnTargetPopulationMutationVariables>;
export const UnlockTpDocument = gql`
    mutation UnlockTP($id: ID!) {
  unlockTargetPopulation(id: $id) {
    targetPopulation {
      ...targetPopulationDetailed
    }
  }
}
    ${TargetPopulationDetailedFragmentDoc}`;
export type UnlockTpMutationFn = Apollo.MutationFunction<UnlockTpMutation, UnlockTpMutationVariables>;

/**
 * __useUnlockTpMutation__
 *
 * To run a mutation, you first call `useUnlockTpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnlockTpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unlockTpMutation, { data, loading, error }] = useUnlockTpMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnlockTpMutation(baseOptions?: Apollo.MutationHookOptions<UnlockTpMutation, UnlockTpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnlockTpMutation, UnlockTpMutationVariables>(UnlockTpDocument, options);
      }
export type UnlockTpMutationHookResult = ReturnType<typeof useUnlockTpMutation>;
export type UnlockTpMutationResult = Apollo.MutationResult<UnlockTpMutation>;
export type UnlockTpMutationOptions = Apollo.BaseMutationOptions<UnlockTpMutation, UnlockTpMutationVariables>;
export const UpdateTpDocument = gql`
    mutation UpdateTP($input: UpdateTargetPopulationInput!) {
  updateTargetPopulation(input: $input) {
    targetPopulation {
      id
      status
      totalHouseholdsCount
      totalIndividualsCount
    }
    validationErrors
  }
}
    `;
export type UpdateTpMutationFn = Apollo.MutationFunction<UpdateTpMutation, UpdateTpMutationVariables>;

/**
 * __useUpdateTpMutation__
 *
 * To run a mutation, you first call `useUpdateTpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTpMutation, { data, loading, error }] = useUpdateTpMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTpMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTpMutation, UpdateTpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTpMutation, UpdateTpMutationVariables>(UpdateTpDocument, options);
      }
export type UpdateTpMutationHookResult = ReturnType<typeof useUpdateTpMutation>;
export type UpdateTpMutationResult = Apollo.MutationResult<UpdateTpMutation>;
export type UpdateTpMutationOptions = Apollo.BaseMutationOptions<UpdateTpMutation, UpdateTpMutationVariables>;
export const AccountabilityCommunicationMessageDocument = gql`
    query AccountabilityCommunicationMessage($id: ID!) {
  accountabilityCommunicationMessage(id: $id) {
    id
    unicefId
    adminUrl
    createdBy {
      id
      firstName
      lastName
      email
    }
    createdAt
    targetPopulation {
      id
      name
    }
    registrationDataImport {
      id
      name
    }
    title
    body
  }
}
    `;

/**
 * __useAccountabilityCommunicationMessageQuery__
 *
 * To run a query within a React component, call `useAccountabilityCommunicationMessageQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountabilityCommunicationMessageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountabilityCommunicationMessageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAccountabilityCommunicationMessageQuery(baseOptions: Apollo.QueryHookOptions<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables> & ({ variables: AccountabilityCommunicationMessageQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables>(AccountabilityCommunicationMessageDocument, options);
      }
export function useAccountabilityCommunicationMessageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables>(AccountabilityCommunicationMessageDocument, options);
        }
export function useAccountabilityCommunicationMessageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables>(AccountabilityCommunicationMessageDocument, options);
        }
export type AccountabilityCommunicationMessageQueryHookResult = ReturnType<typeof useAccountabilityCommunicationMessageQuery>;
export type AccountabilityCommunicationMessageLazyQueryHookResult = ReturnType<typeof useAccountabilityCommunicationMessageLazyQuery>;
export type AccountabilityCommunicationMessageSuspenseQueryHookResult = ReturnType<typeof useAccountabilityCommunicationMessageSuspenseQuery>;
export type AccountabilityCommunicationMessageQueryResult = Apollo.QueryResult<AccountabilityCommunicationMessageQuery, AccountabilityCommunicationMessageQueryVariables>;
export const AccountabilityCommunicationMessageSampleSizeDocument = gql`
    query AccountabilityCommunicationMessageSampleSize($input: GetAccountabilityCommunicationMessageSampleSizeInput!) {
  accountabilityCommunicationMessageSampleSize(input: $input) {
    numberOfRecipients
    sampleSize
  }
}
    `;

/**
 * __useAccountabilityCommunicationMessageSampleSizeQuery__
 *
 * To run a query within a React component, call `useAccountabilityCommunicationMessageSampleSizeQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountabilityCommunicationMessageSampleSizeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountabilityCommunicationMessageSampleSizeQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountabilityCommunicationMessageSampleSizeQuery(baseOptions: Apollo.QueryHookOptions<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables> & ({ variables: AccountabilityCommunicationMessageSampleSizeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables>(AccountabilityCommunicationMessageSampleSizeDocument, options);
      }
export function useAccountabilityCommunicationMessageSampleSizeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables>(AccountabilityCommunicationMessageSampleSizeDocument, options);
        }
export function useAccountabilityCommunicationMessageSampleSizeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables>(AccountabilityCommunicationMessageSampleSizeDocument, options);
        }
export type AccountabilityCommunicationMessageSampleSizeQueryHookResult = ReturnType<typeof useAccountabilityCommunicationMessageSampleSizeQuery>;
export type AccountabilityCommunicationMessageSampleSizeLazyQueryHookResult = ReturnType<typeof useAccountabilityCommunicationMessageSampleSizeLazyQuery>;
export type AccountabilityCommunicationMessageSampleSizeSuspenseQueryHookResult = ReturnType<typeof useAccountabilityCommunicationMessageSampleSizeSuspenseQuery>;
export type AccountabilityCommunicationMessageSampleSizeQueryResult = Apollo.QueryResult<AccountabilityCommunicationMessageSampleSizeQuery, AccountabilityCommunicationMessageSampleSizeQueryVariables>;
export const AccountabilitySampleSizeDocument = gql`
    query AccountabilitySampleSize($input: AccountabilitySampleSizeInput!) {
  accountabilitySampleSize(input: $input) {
    numberOfRecipients
    sampleSize
  }
}
    `;

/**
 * __useAccountabilitySampleSizeQuery__
 *
 * To run a query within a React component, call `useAccountabilitySampleSizeQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountabilitySampleSizeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountabilitySampleSizeQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountabilitySampleSizeQuery(baseOptions: Apollo.QueryHookOptions<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables> & ({ variables: AccountabilitySampleSizeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables>(AccountabilitySampleSizeDocument, options);
      }
export function useAccountabilitySampleSizeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables>(AccountabilitySampleSizeDocument, options);
        }
export function useAccountabilitySampleSizeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables>(AccountabilitySampleSizeDocument, options);
        }
export type AccountabilitySampleSizeQueryHookResult = ReturnType<typeof useAccountabilitySampleSizeQuery>;
export type AccountabilitySampleSizeLazyQueryHookResult = ReturnType<typeof useAccountabilitySampleSizeLazyQuery>;
export type AccountabilitySampleSizeSuspenseQueryHookResult = ReturnType<typeof useAccountabilitySampleSizeSuspenseQuery>;
export type AccountabilitySampleSizeQueryResult = Apollo.QueryResult<AccountabilitySampleSizeQuery, AccountabilitySampleSizeQueryVariables>;
export const AllAccountabilityCommunicationMessageRecipientsDocument = gql`
    query AllAccountabilityCommunicationMessageRecipients($offset: Int, $before: String, $after: String, $first: Int, $last: Int, $messageId: String!, $recipientId: String, $fullName: String, $phoneNo: String, $sex: String, $orderBy: String) {
  allAccountabilityCommunicationMessageRecipients(
    offset: $offset
    before: $before
    after: $after
    first: $first
    last: $last
    messageId: $messageId
    recipientId: $recipientId
    fullName: $fullName
    phoneNo: $phoneNo
    sex: $sex
    orderBy: $orderBy
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edgeCount
    edges {
      cursor
      node {
        id
        headOfHousehold {
          id
          fullName
          household {
            id
            unicefId
            size
            status
            admin2 {
              id
              name
            }
            residenceStatus
            lastRegistrationDate
          }
        }
      }
    }
  }
}
    `;

/**
 * __useAllAccountabilityCommunicationMessageRecipientsQuery__
 *
 * To run a query within a React component, call `useAllAccountabilityCommunicationMessageRecipientsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllAccountabilityCommunicationMessageRecipientsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllAccountabilityCommunicationMessageRecipientsQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      messageId: // value for 'messageId'
 *      recipientId: // value for 'recipientId'
 *      fullName: // value for 'fullName'
 *      phoneNo: // value for 'phoneNo'
 *      sex: // value for 'sex'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useAllAccountabilityCommunicationMessageRecipientsQuery(baseOptions: Apollo.QueryHookOptions<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables> & ({ variables: AllAccountabilityCommunicationMessageRecipientsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables>(AllAccountabilityCommunicationMessageRecipientsDocument, options);
      }
export function useAllAccountabilityCommunicationMessageRecipientsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables>(AllAccountabilityCommunicationMessageRecipientsDocument, options);
        }
export function useAllAccountabilityCommunicationMessageRecipientsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables>(AllAccountabilityCommunicationMessageRecipientsDocument, options);
        }
export type AllAccountabilityCommunicationMessageRecipientsQueryHookResult = ReturnType<typeof useAllAccountabilityCommunicationMessageRecipientsQuery>;
export type AllAccountabilityCommunicationMessageRecipientsLazyQueryHookResult = ReturnType<typeof useAllAccountabilityCommunicationMessageRecipientsLazyQuery>;
export type AllAccountabilityCommunicationMessageRecipientsSuspenseQueryHookResult = ReturnType<typeof useAllAccountabilityCommunicationMessageRecipientsSuspenseQuery>;
export type AllAccountabilityCommunicationMessageRecipientsQueryResult = Apollo.QueryResult<AllAccountabilityCommunicationMessageRecipientsQuery, AllAccountabilityCommunicationMessageRecipientsQueryVariables>;
export const AllAccountabilityCommunicationMessagesDocument = gql`
    query allAccountabilityCommunicationMessages($offset: Int, $before: String, $after: String, $first: Int, $last: Int, $numberOfRecipients: Int, $numberOfRecipients_Gte: Int, $numberOfRecipients_Lte: Int, $targetPopulation: ID, $createdBy: ID, $program: String, $createdAtRange: String, $title: String, $body: String, $samplingType: String, $orderBy: String) {
  allAccountabilityCommunicationMessages(
    offset: $offset
    before: $before
    after: $after
    first: $first
    last: $last
    numberOfRecipients: $numberOfRecipients
    numberOfRecipients_Gte: $numberOfRecipients_Gte
    numberOfRecipients_Lte: $numberOfRecipients_Lte
    targetPopulation: $targetPopulation
    createdBy: $createdBy
    program: $program
    createdAtRange: $createdAtRange
    title: $title
    body: $body
    samplingType: $samplingType
    orderBy: $orderBy
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        unicefId
        title
        numberOfRecipients
        createdBy {
          id
          firstName
          lastName
          email
        }
        createdAt
      }
    }
  }
}
    `;

/**
 * __useAllAccountabilityCommunicationMessagesQuery__
 *
 * To run a query within a React component, call `useAllAccountabilityCommunicationMessagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllAccountabilityCommunicationMessagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllAccountabilityCommunicationMessagesQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      numberOfRecipients: // value for 'numberOfRecipients'
 *      numberOfRecipients_Gte: // value for 'numberOfRecipients_Gte'
 *      numberOfRecipients_Lte: // value for 'numberOfRecipients_Lte'
 *      targetPopulation: // value for 'targetPopulation'
 *      createdBy: // value for 'createdBy'
 *      program: // value for 'program'
 *      createdAtRange: // value for 'createdAtRange'
 *      title: // value for 'title'
 *      body: // value for 'body'
 *      samplingType: // value for 'samplingType'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useAllAccountabilityCommunicationMessagesQuery(baseOptions?: Apollo.QueryHookOptions<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>(AllAccountabilityCommunicationMessagesDocument, options);
      }
export function useAllAccountabilityCommunicationMessagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>(AllAccountabilityCommunicationMessagesDocument, options);
        }
export function useAllAccountabilityCommunicationMessagesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>(AllAccountabilityCommunicationMessagesDocument, options);
        }
export type AllAccountabilityCommunicationMessagesQueryHookResult = ReturnType<typeof useAllAccountabilityCommunicationMessagesQuery>;
export type AllAccountabilityCommunicationMessagesLazyQueryHookResult = ReturnType<typeof useAllAccountabilityCommunicationMessagesLazyQuery>;
export type AllAccountabilityCommunicationMessagesSuspenseQueryHookResult = ReturnType<typeof useAllAccountabilityCommunicationMessagesSuspenseQuery>;
export type AllAccountabilityCommunicationMessagesQueryResult = Apollo.QueryResult<AllAccountabilityCommunicationMessagesQuery, AllAccountabilityCommunicationMessagesQueryVariables>;
export const AllAdminAreasDocument = gql`
    query AllAdminAreas($name: String, $businessArea: String, $level: Int, $first: Int, $parentId: String) {
  allAdminAreas(
    name_Istartswith: $name
    businessArea: $businessArea
    first: $first
    level: $level
    parentId: $parentId
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    edges {
      node {
        id
        name
        pCode
      }
    }
  }
}
    `;

/**
 * __useAllAdminAreasQuery__
 *
 * To run a query within a React component, call `useAllAdminAreasQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllAdminAreasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllAdminAreasQuery({
 *   variables: {
 *      name: // value for 'name'
 *      businessArea: // value for 'businessArea'
 *      level: // value for 'level'
 *      first: // value for 'first'
 *      parentId: // value for 'parentId'
 *   },
 * });
 */
export function useAllAdminAreasQuery(baseOptions?: Apollo.QueryHookOptions<AllAdminAreasQuery, AllAdminAreasQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllAdminAreasQuery, AllAdminAreasQueryVariables>(AllAdminAreasDocument, options);
      }
export function useAllAdminAreasLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllAdminAreasQuery, AllAdminAreasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllAdminAreasQuery, AllAdminAreasQueryVariables>(AllAdminAreasDocument, options);
        }
export function useAllAdminAreasSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllAdminAreasQuery, AllAdminAreasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllAdminAreasQuery, AllAdminAreasQueryVariables>(AllAdminAreasDocument, options);
        }
export type AllAdminAreasQueryHookResult = ReturnType<typeof useAllAdminAreasQuery>;
export type AllAdminAreasLazyQueryHookResult = ReturnType<typeof useAllAdminAreasLazyQuery>;
export type AllAdminAreasSuspenseQueryHookResult = ReturnType<typeof useAllAdminAreasSuspenseQuery>;
export type AllAdminAreasQueryResult = Apollo.QueryResult<AllAdminAreasQuery, AllAdminAreasQueryVariables>;
export const AllAreasTreeDocument = gql`
    query AllAreasTree($businessArea: String!) {
  allAreasTree(businessArea: $businessArea) {
    id
    pCode
    name
    level
    areas {
      id
      name
      level
      pCode
      areas {
        id
        name
        pCode
        areas {
          id
          name
          pCode
        }
      }
    }
  }
}
    `;

/**
 * __useAllAreasTreeQuery__
 *
 * To run a query within a React component, call `useAllAreasTreeQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllAreasTreeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllAreasTreeQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllAreasTreeQuery(baseOptions: Apollo.QueryHookOptions<AllAreasTreeQuery, AllAreasTreeQueryVariables> & ({ variables: AllAreasTreeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllAreasTreeQuery, AllAreasTreeQueryVariables>(AllAreasTreeDocument, options);
      }
export function useAllAreasTreeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllAreasTreeQuery, AllAreasTreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllAreasTreeQuery, AllAreasTreeQueryVariables>(AllAreasTreeDocument, options);
        }
export function useAllAreasTreeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllAreasTreeQuery, AllAreasTreeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllAreasTreeQuery, AllAreasTreeQueryVariables>(AllAreasTreeDocument, options);
        }
export type AllAreasTreeQueryHookResult = ReturnType<typeof useAllAreasTreeQuery>;
export type AllAreasTreeLazyQueryHookResult = ReturnType<typeof useAllAreasTreeLazyQuery>;
export type AllAreasTreeSuspenseQueryHookResult = ReturnType<typeof useAllAreasTreeSuspenseQuery>;
export type AllAreasTreeQueryResult = Apollo.QueryResult<AllAreasTreeQuery, AllAreasTreeQueryVariables>;
export const AllBusinessAreasDocument = gql`
    query AllBusinessAreas($slug: String) {
  allBusinessAreas(slug: $slug) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    edges {
      node {
        id
        name
        slug
      }
    }
  }
}
    `;

/**
 * __useAllBusinessAreasQuery__
 *
 * To run a query within a React component, call `useAllBusinessAreasQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllBusinessAreasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllBusinessAreasQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useAllBusinessAreasQuery(baseOptions?: Apollo.QueryHookOptions<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>(AllBusinessAreasDocument, options);
      }
export function useAllBusinessAreasLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>(AllBusinessAreasDocument, options);
        }
export function useAllBusinessAreasSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>(AllBusinessAreasDocument, options);
        }
export type AllBusinessAreasQueryHookResult = ReturnType<typeof useAllBusinessAreasQuery>;
export type AllBusinessAreasLazyQueryHookResult = ReturnType<typeof useAllBusinessAreasLazyQuery>;
export type AllBusinessAreasSuspenseQueryHookResult = ReturnType<typeof useAllBusinessAreasSuspenseQuery>;
export type AllBusinessAreasQueryResult = Apollo.QueryResult<AllBusinessAreasQuery, AllBusinessAreasQueryVariables>;
export const AllLogEntriesDocument = gql`
    query AllLogEntries($businessArea: String!, $objectId: UUID, $after: String, $before: String, $first: Int, $last: Int, $search: String, $module: String, $userId: String, $programId: String) {
  allLogEntries(
    after: $after
    before: $before
    first: $first
    last: $last
    objectId: $objectId
    businessArea: $businessArea
    search: $search
    module: $module
    userId: $userId
    programId: $programId
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        action
        changes
        objectRepr
        objectId
        timestamp
        isUserGenerated
        contentType {
          id
          appLabel
          model
          name
        }
        user {
          id
          firstName
          lastName
        }
      }
    }
  }
  logEntryActionChoices {
    name
    value
  }
}
    `;

/**
 * __useAllLogEntriesQuery__
 *
 * To run a query within a React component, call `useAllLogEntriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllLogEntriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllLogEntriesQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *      objectId: // value for 'objectId'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      search: // value for 'search'
 *      module: // value for 'module'
 *      userId: // value for 'userId'
 *      programId: // value for 'programId'
 *   },
 * });
 */
export function useAllLogEntriesQuery(baseOptions: Apollo.QueryHookOptions<AllLogEntriesQuery, AllLogEntriesQueryVariables> & ({ variables: AllLogEntriesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllLogEntriesQuery, AllLogEntriesQueryVariables>(AllLogEntriesDocument, options);
      }
export function useAllLogEntriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllLogEntriesQuery, AllLogEntriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllLogEntriesQuery, AllLogEntriesQueryVariables>(AllLogEntriesDocument, options);
        }
export function useAllLogEntriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllLogEntriesQuery, AllLogEntriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllLogEntriesQuery, AllLogEntriesQueryVariables>(AllLogEntriesDocument, options);
        }
export type AllLogEntriesQueryHookResult = ReturnType<typeof useAllLogEntriesQuery>;
export type AllLogEntriesLazyQueryHookResult = ReturnType<typeof useAllLogEntriesLazyQuery>;
export type AllLogEntriesSuspenseQueryHookResult = ReturnType<typeof useAllLogEntriesSuspenseQuery>;
export type AllLogEntriesQueryResult = Apollo.QueryResult<AllLogEntriesQuery, AllLogEntriesQueryVariables>;
export const AllSanctionListIndividualsDocument = gql`
    query AllSanctionListIndividuals($referenceNumber: String!, $first: Int, $last: Int, $after: String, $before: String, $orderBy: String, $fullNameContains: String) {
  allSanctionListIndividuals(
    fullName_Startswith: $fullNameContains
    referenceNumber: $referenceNumber
    first: $first
    last: $last
    after: $after
    before: $before
    orderBy: $orderBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    edges {
      cursor
      node {
        id
        referenceNumber
        fullName
        listedOn
        documents {
          edges {
            node {
              id
              documentNumber
              typeOfDocument
              issuingCountry
            }
          }
        }
        aliasNames {
          edges {
            node {
              id
              name
            }
          }
        }
        datesOfBirth {
          edges {
            node {
              id
              date
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useAllSanctionListIndividualsQuery__
 *
 * To run a query within a React component, call `useAllSanctionListIndividualsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllSanctionListIndividualsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllSanctionListIndividualsQuery({
 *   variables: {
 *      referenceNumber: // value for 'referenceNumber'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      orderBy: // value for 'orderBy'
 *      fullNameContains: // value for 'fullNameContains'
 *   },
 * });
 */
export function useAllSanctionListIndividualsQuery(baseOptions: Apollo.QueryHookOptions<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables> & ({ variables: AllSanctionListIndividualsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables>(AllSanctionListIndividualsDocument, options);
      }
export function useAllSanctionListIndividualsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables>(AllSanctionListIndividualsDocument, options);
        }
export function useAllSanctionListIndividualsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables>(AllSanctionListIndividualsDocument, options);
        }
export type AllSanctionListIndividualsQueryHookResult = ReturnType<typeof useAllSanctionListIndividualsQuery>;
export type AllSanctionListIndividualsLazyQueryHookResult = ReturnType<typeof useAllSanctionListIndividualsLazyQuery>;
export type AllSanctionListIndividualsSuspenseQueryHookResult = ReturnType<typeof useAllSanctionListIndividualsSuspenseQuery>;
export type AllSanctionListIndividualsQueryResult = Apollo.QueryResult<AllSanctionListIndividualsQuery, AllSanctionListIndividualsQueryVariables>;
export const AllUsersDocument = gql`
    query AllUsers($search: String, $status: [String], $partner: [String], $roles: [String], $businessArea: String!, $first: Int, $last: Int, $after: String, $before: String, $orderBy: String) {
  allUsers(
    search: $search
    status: $status
    partner: $partner
    roles: $roles
    businessArea: $businessArea
    first: $first
    last: $last
    after: $after
    before: $before
    orderBy: $orderBy
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    edges {
      node {
        id
        firstName
        lastName
        username
        email
        isActive
        lastLogin
        status
        partner {
          name
        }
        userRoles {
          businessArea {
            name
          }
          role {
            name
            permissions
          }
        }
      }
      cursor
    }
    totalCount
    edgeCount
  }
}
    `;

/**
 * __useAllUsersQuery__
 *
 * To run a query within a React component, call `useAllUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllUsersQuery({
 *   variables: {
 *      search: // value for 'search'
 *      status: // value for 'status'
 *      partner: // value for 'partner'
 *      roles: // value for 'roles'
 *      businessArea: // value for 'businessArea'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useAllUsersQuery(baseOptions: Apollo.QueryHookOptions<AllUsersQuery, AllUsersQueryVariables> & ({ variables: AllUsersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllUsersQuery, AllUsersQueryVariables>(AllUsersDocument, options);
      }
export function useAllUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllUsersQuery, AllUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllUsersQuery, AllUsersQueryVariables>(AllUsersDocument, options);
        }
export function useAllUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllUsersQuery, AllUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllUsersQuery, AllUsersQueryVariables>(AllUsersDocument, options);
        }
export type AllUsersQueryHookResult = ReturnType<typeof useAllUsersQuery>;
export type AllUsersLazyQueryHookResult = ReturnType<typeof useAllUsersLazyQuery>;
export type AllUsersSuspenseQueryHookResult = ReturnType<typeof useAllUsersSuspenseQuery>;
export type AllUsersQueryResult = Apollo.QueryResult<AllUsersQuery, AllUsersQueryVariables>;
export const AllUsersForFiltersDocument = gql`
    query AllUsersForFilters($businessArea: String!, $first: Int, $last: Int, $after: String, $before: String, $orderBy: String, $search: String, $isTicketCreator: Boolean, $isSurveyCreator: Boolean, $isMessageCreator: Boolean, $isFeedbackCreator: Boolean) {
  allUsers(
    businessArea: $businessArea
    first: $first
    last: $last
    after: $after
    before: $before
    orderBy: $orderBy
    search: $search
    isTicketCreator: $isTicketCreator
    isSurveyCreator: $isSurveyCreator
    isMessageCreator: $isMessageCreator
    isFeedbackCreator: $isFeedbackCreator
  ) {
    edges {
      node {
        id
        firstName
        lastName
        email
      }
    }
  }
}
    `;

/**
 * __useAllUsersForFiltersQuery__
 *
 * To run a query within a React component, call `useAllUsersForFiltersQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllUsersForFiltersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllUsersForFiltersQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      orderBy: // value for 'orderBy'
 *      search: // value for 'search'
 *      isTicketCreator: // value for 'isTicketCreator'
 *      isSurveyCreator: // value for 'isSurveyCreator'
 *      isMessageCreator: // value for 'isMessageCreator'
 *      isFeedbackCreator: // value for 'isFeedbackCreator'
 *   },
 * });
 */
export function useAllUsersForFiltersQuery(baseOptions: Apollo.QueryHookOptions<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables> & ({ variables: AllUsersForFiltersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables>(AllUsersForFiltersDocument, options);
      }
export function useAllUsersForFiltersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables>(AllUsersForFiltersDocument, options);
        }
export function useAllUsersForFiltersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables>(AllUsersForFiltersDocument, options);
        }
export type AllUsersForFiltersQueryHookResult = ReturnType<typeof useAllUsersForFiltersQuery>;
export type AllUsersForFiltersLazyQueryHookResult = ReturnType<typeof useAllUsersForFiltersLazyQuery>;
export type AllUsersForFiltersSuspenseQueryHookResult = ReturnType<typeof useAllUsersForFiltersSuspenseQuery>;
export type AllUsersForFiltersQueryResult = Apollo.QueryResult<AllUsersForFiltersQuery, AllUsersForFiltersQueryVariables>;
export const BusinessAreaDataDocument = gql`
    query BusinessAreaData($businessAreaSlug: String!) {
  businessArea(businessAreaSlug: $businessAreaSlug) {
    id
    screenBeneficiary
    isPaymentPlanApplicable
    isAccountabilityApplicable
  }
}
    `;

/**
 * __useBusinessAreaDataQuery__
 *
 * To run a query within a React component, call `useBusinessAreaDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useBusinessAreaDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBusinessAreaDataQuery({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useBusinessAreaDataQuery(baseOptions: Apollo.QueryHookOptions<BusinessAreaDataQuery, BusinessAreaDataQueryVariables> & ({ variables: BusinessAreaDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BusinessAreaDataQuery, BusinessAreaDataQueryVariables>(BusinessAreaDataDocument, options);
      }
export function useBusinessAreaDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BusinessAreaDataQuery, BusinessAreaDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BusinessAreaDataQuery, BusinessAreaDataQueryVariables>(BusinessAreaDataDocument, options);
        }
export function useBusinessAreaDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BusinessAreaDataQuery, BusinessAreaDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BusinessAreaDataQuery, BusinessAreaDataQueryVariables>(BusinessAreaDataDocument, options);
        }
export type BusinessAreaDataQueryHookResult = ReturnType<typeof useBusinessAreaDataQuery>;
export type BusinessAreaDataLazyQueryHookResult = ReturnType<typeof useBusinessAreaDataLazyQuery>;
export type BusinessAreaDataSuspenseQueryHookResult = ReturnType<typeof useBusinessAreaDataSuspenseQuery>;
export type BusinessAreaDataQueryResult = Apollo.QueryResult<BusinessAreaDataQuery, BusinessAreaDataQueryVariables>;
export const CashAssistUrlPrefixDocument = gql`
    query CashAssistUrlPrefix {
  cashAssistUrlPrefix
}
    `;

/**
 * __useCashAssistUrlPrefixQuery__
 *
 * To run a query within a React component, call `useCashAssistUrlPrefixQuery` and pass it any options that fit your needs.
 * When your component renders, `useCashAssistUrlPrefixQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCashAssistUrlPrefixQuery({
 *   variables: {
 *   },
 * });
 */
export function useCashAssistUrlPrefixQuery(baseOptions?: Apollo.QueryHookOptions<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>(CashAssistUrlPrefixDocument, options);
      }
export function useCashAssistUrlPrefixLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>(CashAssistUrlPrefixDocument, options);
        }
export function useCashAssistUrlPrefixSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>(CashAssistUrlPrefixDocument, options);
        }
export type CashAssistUrlPrefixQueryHookResult = ReturnType<typeof useCashAssistUrlPrefixQuery>;
export type CashAssistUrlPrefixLazyQueryHookResult = ReturnType<typeof useCashAssistUrlPrefixLazyQuery>;
export type CashAssistUrlPrefixSuspenseQueryHookResult = ReturnType<typeof useCashAssistUrlPrefixSuspenseQuery>;
export type CashAssistUrlPrefixQueryResult = Apollo.QueryResult<CashAssistUrlPrefixQuery, CashAssistUrlPrefixQueryVariables>;
export const CurrencyChoicesDocument = gql`
    query currencyChoices {
  currencyChoices {
    name
    value
  }
}
    `;

/**
 * __useCurrencyChoicesQuery__
 *
 * To run a query within a React component, call `useCurrencyChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrencyChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrencyChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrencyChoicesQuery(baseOptions?: Apollo.QueryHookOptions<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>(CurrencyChoicesDocument, options);
      }
export function useCurrencyChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>(CurrencyChoicesDocument, options);
        }
export function useCurrencyChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>(CurrencyChoicesDocument, options);
        }
export type CurrencyChoicesQueryHookResult = ReturnType<typeof useCurrencyChoicesQuery>;
export type CurrencyChoicesLazyQueryHookResult = ReturnType<typeof useCurrencyChoicesLazyQuery>;
export type CurrencyChoicesSuspenseQueryHookResult = ReturnType<typeof useCurrencyChoicesSuspenseQuery>;
export type CurrencyChoicesQueryResult = Apollo.QueryResult<CurrencyChoicesQuery, CurrencyChoicesQueryVariables>;
export const DataCollectionTypeChoiceDataDocument = gql`
    query dataCollectionTypeChoiceData {
  dataCollectionTypeChoices {
    name
    value
    description
  }
}
    `;

/**
 * __useDataCollectionTypeChoiceDataQuery__
 *
 * To run a query within a React component, call `useDataCollectionTypeChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useDataCollectionTypeChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDataCollectionTypeChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useDataCollectionTypeChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>(DataCollectionTypeChoiceDataDocument, options);
      }
export function useDataCollectionTypeChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>(DataCollectionTypeChoiceDataDocument, options);
        }
export function useDataCollectionTypeChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>(DataCollectionTypeChoiceDataDocument, options);
        }
export type DataCollectionTypeChoiceDataQueryHookResult = ReturnType<typeof useDataCollectionTypeChoiceDataQuery>;
export type DataCollectionTypeChoiceDataLazyQueryHookResult = ReturnType<typeof useDataCollectionTypeChoiceDataLazyQuery>;
export type DataCollectionTypeChoiceDataSuspenseQueryHookResult = ReturnType<typeof useDataCollectionTypeChoiceDataSuspenseQuery>;
export type DataCollectionTypeChoiceDataQueryResult = Apollo.QueryResult<DataCollectionTypeChoiceDataQuery, DataCollectionTypeChoiceDataQueryVariables>;
export const LoggedCheckerDocument = gql`
    query LoggedChecker {
  me {
    id
  }
}
    `;

/**
 * __useLoggedCheckerQuery__
 *
 * To run a query within a React component, call `useLoggedCheckerQuery` and pass it any options that fit your needs.
 * When your component renders, `useLoggedCheckerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLoggedCheckerQuery({
 *   variables: {
 *   },
 * });
 */
export function useLoggedCheckerQuery(baseOptions?: Apollo.QueryHookOptions<LoggedCheckerQuery, LoggedCheckerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LoggedCheckerQuery, LoggedCheckerQueryVariables>(LoggedCheckerDocument, options);
      }
export function useLoggedCheckerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LoggedCheckerQuery, LoggedCheckerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LoggedCheckerQuery, LoggedCheckerQueryVariables>(LoggedCheckerDocument, options);
        }
export function useLoggedCheckerSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LoggedCheckerQuery, LoggedCheckerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LoggedCheckerQuery, LoggedCheckerQueryVariables>(LoggedCheckerDocument, options);
        }
export type LoggedCheckerQueryHookResult = ReturnType<typeof useLoggedCheckerQuery>;
export type LoggedCheckerLazyQueryHookResult = ReturnType<typeof useLoggedCheckerLazyQuery>;
export type LoggedCheckerSuspenseQueryHookResult = ReturnType<typeof useLoggedCheckerSuspenseQuery>;
export type LoggedCheckerQueryResult = Apollo.QueryResult<LoggedCheckerQuery, LoggedCheckerQueryVariables>;
export const MeDocument = gql`
    query Me {
  me {
    id
    username
    email
    firstName
    lastName
    isSuperuser
    businessAreas {
      edges {
        node {
          id
          name
          slug
          permissions
        }
      }
    }
  }
}
    `;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
      }
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export function useMeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeSuspenseQueryHookResult = ReturnType<typeof useMeSuspenseQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const UserChoiceDataDocument = gql`
    query userChoiceData {
  userRolesChoices {
    name
    value
    subsystem
  }
  userStatusChoices {
    name
    value
  }
  userPartnerChoices {
    name
    value
  }
}
    `;

/**
 * __useUserChoiceDataQuery__
 *
 * To run a query within a React component, call `useUserChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<UserChoiceDataQuery, UserChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserChoiceDataQuery, UserChoiceDataQueryVariables>(UserChoiceDataDocument, options);
      }
export function useUserChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserChoiceDataQuery, UserChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserChoiceDataQuery, UserChoiceDataQueryVariables>(UserChoiceDataDocument, options);
        }
export function useUserChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UserChoiceDataQuery, UserChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserChoiceDataQuery, UserChoiceDataQueryVariables>(UserChoiceDataDocument, options);
        }
export type UserChoiceDataQueryHookResult = ReturnType<typeof useUserChoiceDataQuery>;
export type UserChoiceDataLazyQueryHookResult = ReturnType<typeof useUserChoiceDataLazyQuery>;
export type UserChoiceDataSuspenseQueryHookResult = ReturnType<typeof useUserChoiceDataSuspenseQuery>;
export type UserChoiceDataQueryResult = Apollo.QueryResult<UserChoiceDataQuery, UserChoiceDataQueryVariables>;
export const AllAddIndividualFieldsDocument = gql`
    query AllAddIndividualFields {
  allAddIndividualsFieldsAttributes {
    isFlexField
    id
    type
    name
    required
    associatedWith
    labels {
      language
      label
    }
    labelEn
    hint
    choices {
      labels {
        label
        language
      }
      labelEn
      value
      admin
      listName
    }
  }
  countriesChoices {
    name
    value
  }
  documentTypeChoices {
    name
    value
  }
  identityTypeChoices {
    name
    value
  }
}
    `;

/**
 * __useAllAddIndividualFieldsQuery__
 *
 * To run a query within a React component, call `useAllAddIndividualFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllAddIndividualFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllAddIndividualFieldsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllAddIndividualFieldsQuery(baseOptions?: Apollo.QueryHookOptions<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>(AllAddIndividualFieldsDocument, options);
      }
export function useAllAddIndividualFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>(AllAddIndividualFieldsDocument, options);
        }
export function useAllAddIndividualFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>(AllAddIndividualFieldsDocument, options);
        }
export type AllAddIndividualFieldsQueryHookResult = ReturnType<typeof useAllAddIndividualFieldsQuery>;
export type AllAddIndividualFieldsLazyQueryHookResult = ReturnType<typeof useAllAddIndividualFieldsLazyQuery>;
export type AllAddIndividualFieldsSuspenseQueryHookResult = ReturnType<typeof useAllAddIndividualFieldsSuspenseQuery>;
export type AllAddIndividualFieldsQueryResult = Apollo.QueryResult<AllAddIndividualFieldsQuery, AllAddIndividualFieldsQueryVariables>;
export const AllEditHouseholdFieldsDocument = gql`
    query AllEditHouseholdFields {
  allEditHouseholdFieldsAttributes {
    isFlexField
    id
    type
    name
    required
    associatedWith
    labels {
      language
      label
    }
    labelEn
    hint
    choices {
      labels {
        label
        language
      }
      labelEn
      value
      admin
      listName
    }
  }
  countriesChoices {
    name
    value
  }
}
    `;

/**
 * __useAllEditHouseholdFieldsQuery__
 *
 * To run a query within a React component, call `useAllEditHouseholdFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllEditHouseholdFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllEditHouseholdFieldsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllEditHouseholdFieldsQuery(baseOptions?: Apollo.QueryHookOptions<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>(AllEditHouseholdFieldsDocument, options);
      }
export function useAllEditHouseholdFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>(AllEditHouseholdFieldsDocument, options);
        }
export function useAllEditHouseholdFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>(AllEditHouseholdFieldsDocument, options);
        }
export type AllEditHouseholdFieldsQueryHookResult = ReturnType<typeof useAllEditHouseholdFieldsQuery>;
export type AllEditHouseholdFieldsLazyQueryHookResult = ReturnType<typeof useAllEditHouseholdFieldsLazyQuery>;
export type AllEditHouseholdFieldsSuspenseQueryHookResult = ReturnType<typeof useAllEditHouseholdFieldsSuspenseQuery>;
export type AllEditHouseholdFieldsQueryResult = Apollo.QueryResult<AllEditHouseholdFieldsQuery, AllEditHouseholdFieldsQueryVariables>;
export const AllHouseholdsFlexFieldsAttributesDocument = gql`
    query AllHouseholdsFlexFieldsAttributes {
  allHouseholdsFlexFieldsAttributes {
    isFlexField
    id
    type
    name
    required
    associatedWith
    labels {
      language
      label
    }
    labelEn
    hint
    choices {
      labels {
        label
        language
      }
      labelEn
      value
      admin
      listName
    }
  }
}
    `;

/**
 * __useAllHouseholdsFlexFieldsAttributesQuery__
 *
 * To run a query within a React component, call `useAllHouseholdsFlexFieldsAttributesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllHouseholdsFlexFieldsAttributesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllHouseholdsFlexFieldsAttributesQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllHouseholdsFlexFieldsAttributesQuery(baseOptions?: Apollo.QueryHookOptions<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>(AllHouseholdsFlexFieldsAttributesDocument, options);
      }
export function useAllHouseholdsFlexFieldsAttributesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>(AllHouseholdsFlexFieldsAttributesDocument, options);
        }
export function useAllHouseholdsFlexFieldsAttributesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>(AllHouseholdsFlexFieldsAttributesDocument, options);
        }
export type AllHouseholdsFlexFieldsAttributesQueryHookResult = ReturnType<typeof useAllHouseholdsFlexFieldsAttributesQuery>;
export type AllHouseholdsFlexFieldsAttributesLazyQueryHookResult = ReturnType<typeof useAllHouseholdsFlexFieldsAttributesLazyQuery>;
export type AllHouseholdsFlexFieldsAttributesSuspenseQueryHookResult = ReturnType<typeof useAllHouseholdsFlexFieldsAttributesSuspenseQuery>;
export type AllHouseholdsFlexFieldsAttributesQueryResult = Apollo.QueryResult<AllHouseholdsFlexFieldsAttributesQuery, AllHouseholdsFlexFieldsAttributesQueryVariables>;
export const AllIndividualsFlexFieldsAttributesDocument = gql`
    query AllIndividualsFlexFieldsAttributes {
  allIndividualsFlexFieldsAttributes {
    isFlexField
    id
    type
    name
    required
    associatedWith
    labels {
      language
      label
    }
    labelEn
    hint
    choices {
      labels {
        label
        language
      }
      labelEn
      value
      admin
      listName
    }
  }
}
    `;

/**
 * __useAllIndividualsFlexFieldsAttributesQuery__
 *
 * To run a query within a React component, call `useAllIndividualsFlexFieldsAttributesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllIndividualsFlexFieldsAttributesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllIndividualsFlexFieldsAttributesQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllIndividualsFlexFieldsAttributesQuery(baseOptions?: Apollo.QueryHookOptions<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>(AllIndividualsFlexFieldsAttributesDocument, options);
      }
export function useAllIndividualsFlexFieldsAttributesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>(AllIndividualsFlexFieldsAttributesDocument, options);
        }
export function useAllIndividualsFlexFieldsAttributesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>(AllIndividualsFlexFieldsAttributesDocument, options);
        }
export type AllIndividualsFlexFieldsAttributesQueryHookResult = ReturnType<typeof useAllIndividualsFlexFieldsAttributesQuery>;
export type AllIndividualsFlexFieldsAttributesLazyQueryHookResult = ReturnType<typeof useAllIndividualsFlexFieldsAttributesLazyQuery>;
export type AllIndividualsFlexFieldsAttributesSuspenseQueryHookResult = ReturnType<typeof useAllIndividualsFlexFieldsAttributesSuspenseQuery>;
export type AllIndividualsFlexFieldsAttributesQueryResult = Apollo.QueryResult<AllIndividualsFlexFieldsAttributesQuery, AllIndividualsFlexFieldsAttributesQueryVariables>;
export const FlexFieldsDocument = gql`
    query FlexFields {
  allGroupsWithFields {
    name
    labelEn
    flexAttributes {
      id
      labelEn
      associatedWith
    }
  }
}
    `;

/**
 * __useFlexFieldsQuery__
 *
 * To run a query within a React component, call `useFlexFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFlexFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFlexFieldsQuery({
 *   variables: {
 *   },
 * });
 */
export function useFlexFieldsQuery(baseOptions?: Apollo.QueryHookOptions<FlexFieldsQuery, FlexFieldsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FlexFieldsQuery, FlexFieldsQueryVariables>(FlexFieldsDocument, options);
      }
export function useFlexFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FlexFieldsQuery, FlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FlexFieldsQuery, FlexFieldsQueryVariables>(FlexFieldsDocument, options);
        }
export function useFlexFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FlexFieldsQuery, FlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FlexFieldsQuery, FlexFieldsQueryVariables>(FlexFieldsDocument, options);
        }
export type FlexFieldsQueryHookResult = ReturnType<typeof useFlexFieldsQuery>;
export type FlexFieldsLazyQueryHookResult = ReturnType<typeof useFlexFieldsLazyQuery>;
export type FlexFieldsSuspenseQueryHookResult = ReturnType<typeof useFlexFieldsSuspenseQuery>;
export type FlexFieldsQueryResult = Apollo.QueryResult<FlexFieldsQuery, FlexFieldsQueryVariables>;
export const ImportedIndividualFieldsDocument = gql`
    query ImportedIndividualFields($businessAreaSlug: String, $programId: String) {
  allFieldsAttributes(businessAreaSlug: $businessAreaSlug, programId: $programId) {
    isFlexField
    id
    type
    name
    associatedWith
    labels {
      language
      label
    }
    labelEn
    hint
    choices {
      labels {
        label
        language
      }
      labelEn
      value
      admin
      listName
    }
  }
}
    `;

/**
 * __useImportedIndividualFieldsQuery__
 *
 * To run a query within a React component, call `useImportedIndividualFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedIndividualFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedIndividualFieldsQuery({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *      programId: // value for 'programId'
 *   },
 * });
 */
export function useImportedIndividualFieldsQuery(baseOptions?: Apollo.QueryHookOptions<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>(ImportedIndividualFieldsDocument, options);
      }
export function useImportedIndividualFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>(ImportedIndividualFieldsDocument, options);
        }
export function useImportedIndividualFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>(ImportedIndividualFieldsDocument, options);
        }
export type ImportedIndividualFieldsQueryHookResult = ReturnType<typeof useImportedIndividualFieldsQuery>;
export type ImportedIndividualFieldsLazyQueryHookResult = ReturnType<typeof useImportedIndividualFieldsLazyQuery>;
export type ImportedIndividualFieldsSuspenseQueryHookResult = ReturnType<typeof useImportedIndividualFieldsSuspenseQuery>;
export type ImportedIndividualFieldsQueryResult = Apollo.QueryResult<ImportedIndividualFieldsQuery, ImportedIndividualFieldsQueryVariables>;
export const AllFeedbacksDocument = gql`
    query AllFeedbacks($offset: Int, $before: String, $after: String, $first: Int, $last: Int, $issueType: String, $createdAtRange: String, $createdBy: String, $feedbackId: String, $orderBy: String, $program: String, $isActiveProgram: String) {
  allFeedbacks(
    offset: $offset
    before: $before
    after: $after
    first: $first
    last: $last
    issueType: $issueType
    createdAtRange: $createdAtRange
    createdBy: $createdBy
    feedbackId: $feedbackId
    orderBy: $orderBy
    program: $program
    isActiveProgram: $isActiveProgram
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        unicefId
        issueType
        householdLookup {
          id
          unicefId
        }
        createdAt
        createdBy {
          id
          firstName
          lastName
          email
        }
        linkedGrievance {
          id
          unicefId
          category
        }
        program {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useAllFeedbacksQuery__
 *
 * To run a query within a React component, call `useAllFeedbacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllFeedbacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllFeedbacksQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      issueType: // value for 'issueType'
 *      createdAtRange: // value for 'createdAtRange'
 *      createdBy: // value for 'createdBy'
 *      feedbackId: // value for 'feedbackId'
 *      orderBy: // value for 'orderBy'
 *      program: // value for 'program'
 *      isActiveProgram: // value for 'isActiveProgram'
 *   },
 * });
 */
export function useAllFeedbacksQuery(baseOptions?: Apollo.QueryHookOptions<AllFeedbacksQuery, AllFeedbacksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllFeedbacksQuery, AllFeedbacksQueryVariables>(AllFeedbacksDocument, options);
      }
export function useAllFeedbacksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllFeedbacksQuery, AllFeedbacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllFeedbacksQuery, AllFeedbacksQueryVariables>(AllFeedbacksDocument, options);
        }
export function useAllFeedbacksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllFeedbacksQuery, AllFeedbacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllFeedbacksQuery, AllFeedbacksQueryVariables>(AllFeedbacksDocument, options);
        }
export type AllFeedbacksQueryHookResult = ReturnType<typeof useAllFeedbacksQuery>;
export type AllFeedbacksLazyQueryHookResult = ReturnType<typeof useAllFeedbacksLazyQuery>;
export type AllFeedbacksSuspenseQueryHookResult = ReturnType<typeof useAllFeedbacksSuspenseQuery>;
export type AllFeedbacksQueryResult = Apollo.QueryResult<AllFeedbacksQuery, AllFeedbacksQueryVariables>;
export const FeedbackDocument = gql`
    query Feedback($id: ID!) {
  feedback(id: $id) {
    id
    unicefId
    issueType
    adminUrl
    householdLookup {
      id
      unicefId
      admin2 {
        id
        name
        pCode
      }
      headOfHousehold {
        id
        fullName
      }
    }
    individualLookup {
      id
      unicefId
    }
    program {
      id
      name
    }
    createdBy {
      id
      firstName
      lastName
      username
      email
    }
    createdAt
    updatedAt
    admin2 {
      id
      name
    }
    area
    language
    description
    comments
    linkedGrievance {
      id
      unicefId
      category
    }
    feedbackMessages {
      edges {
        node {
          id
          createdAt
          updatedAt
          description
          createdBy {
            id
            firstName
            lastName
            username
            email
          }
        }
      }
    }
  }
}
    `;

/**
 * __useFeedbackQuery__
 *
 * To run a query within a React component, call `useFeedbackQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeedbackQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeedbackQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useFeedbackQuery(baseOptions: Apollo.QueryHookOptions<FeedbackQuery, FeedbackQueryVariables> & ({ variables: FeedbackQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeedbackQuery, FeedbackQueryVariables>(FeedbackDocument, options);
      }
export function useFeedbackLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeedbackQuery, FeedbackQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeedbackQuery, FeedbackQueryVariables>(FeedbackDocument, options);
        }
export function useFeedbackSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FeedbackQuery, FeedbackQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FeedbackQuery, FeedbackQueryVariables>(FeedbackDocument, options);
        }
export type FeedbackQueryHookResult = ReturnType<typeof useFeedbackQuery>;
export type FeedbackLazyQueryHookResult = ReturnType<typeof useFeedbackLazyQuery>;
export type FeedbackSuspenseQueryHookResult = ReturnType<typeof useFeedbackSuspenseQuery>;
export type FeedbackQueryResult = Apollo.QueryResult<FeedbackQuery, FeedbackQueryVariables>;
export const FeedbackIssueTypeChoicesDocument = gql`
    query FeedbackIssueTypeChoices {
  feedbackIssueTypeChoices {
    name
    value
  }
}
    `;

/**
 * __useFeedbackIssueTypeChoicesQuery__
 *
 * To run a query within a React component, call `useFeedbackIssueTypeChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeedbackIssueTypeChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeedbackIssueTypeChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useFeedbackIssueTypeChoicesQuery(baseOptions?: Apollo.QueryHookOptions<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>(FeedbackIssueTypeChoicesDocument, options);
      }
export function useFeedbackIssueTypeChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>(FeedbackIssueTypeChoicesDocument, options);
        }
export function useFeedbackIssueTypeChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>(FeedbackIssueTypeChoicesDocument, options);
        }
export type FeedbackIssueTypeChoicesQueryHookResult = ReturnType<typeof useFeedbackIssueTypeChoicesQuery>;
export type FeedbackIssueTypeChoicesLazyQueryHookResult = ReturnType<typeof useFeedbackIssueTypeChoicesLazyQuery>;
export type FeedbackIssueTypeChoicesSuspenseQueryHookResult = ReturnType<typeof useFeedbackIssueTypeChoicesSuspenseQuery>;
export type FeedbackIssueTypeChoicesQueryResult = Apollo.QueryResult<FeedbackIssueTypeChoicesQuery, FeedbackIssueTypeChoicesQueryVariables>;
export const AllGrievanceDashboardChartsDocument = gql`
    query AllGrievanceDashboardCharts($businessAreaSlug: String!) {
  ticketsByType(businessAreaSlug: $businessAreaSlug) {
    userGeneratedCount
    systemGeneratedCount
    closedUserGeneratedCount
    closedSystemGeneratedCount
    userGeneratedAvgResolution
    systemGeneratedAvgResolution
  }
  ticketsByStatus(businessAreaSlug: $businessAreaSlug) {
    datasets {
      data
    }
    labels
  }
  ticketsByCategory(businessAreaSlug: $businessAreaSlug) {
    datasets {
      data
    }
    labels
  }
  ticketsByLocationAndCategory(businessAreaSlug: $businessAreaSlug) {
    datasets {
      data
      label
    }
    labels
  }
}
    `;

/**
 * __useAllGrievanceDashboardChartsQuery__
 *
 * To run a query within a React component, call `useAllGrievanceDashboardChartsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllGrievanceDashboardChartsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllGrievanceDashboardChartsQuery({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useAllGrievanceDashboardChartsQuery(baseOptions: Apollo.QueryHookOptions<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables> & ({ variables: AllGrievanceDashboardChartsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables>(AllGrievanceDashboardChartsDocument, options);
      }
export function useAllGrievanceDashboardChartsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables>(AllGrievanceDashboardChartsDocument, options);
        }
export function useAllGrievanceDashboardChartsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables>(AllGrievanceDashboardChartsDocument, options);
        }
export type AllGrievanceDashboardChartsQueryHookResult = ReturnType<typeof useAllGrievanceDashboardChartsQuery>;
export type AllGrievanceDashboardChartsLazyQueryHookResult = ReturnType<typeof useAllGrievanceDashboardChartsLazyQuery>;
export type AllGrievanceDashboardChartsSuspenseQueryHookResult = ReturnType<typeof useAllGrievanceDashboardChartsSuspenseQuery>;
export type AllGrievanceDashboardChartsQueryResult = Apollo.QueryResult<AllGrievanceDashboardChartsQuery, AllGrievanceDashboardChartsQueryVariables>;
export const AllGrievanceTicketDocument = gql`
    query AllGrievanceTicket($before: String, $after: String, $first: Int, $last: Int, $id: UUID, $category: String, $issueType: String, $businessArea: String!, $search: String, $searchType: String, $status: [String], $fsp: String, $createdAtRange: String, $admin2: ID, $orderBy: String, $registrationDataImport: ID, $assignedTo: ID, $createdBy: ID, $cashPlan: String, $scoreMin: String, $scoreMax: String, $household: String, $grievanceType: String, $grievanceStatus: String, $priority: String, $urgency: String, $preferredLanguage: String, $program: String, $isActiveProgram: Boolean, $isCrossArea: Boolean) {
  allGrievanceTicket(
    before: $before
    after: $after
    first: $first
    last: $last
    id: $id
    category: $category
    issueType: $issueType
    businessArea: $businessArea
    search: $search
    searchType: $searchType
    status: $status
    fsp: $fsp
    createdAtRange: $createdAtRange
    orderBy: $orderBy
    admin2: $admin2
    registrationDataImport: $registrationDataImport
    assignedTo: $assignedTo
    createdBy: $createdBy
    cashPlan: $cashPlan
    scoreMin: $scoreMin
    scoreMax: $scoreMax
    household: $household
    grievanceType: $grievanceType
    grievanceStatus: $grievanceStatus
    priority: $priority
    urgency: $urgency
    preferredLanguage: $preferredLanguage
    program: $program
    isActiveProgram: $isActiveProgram
    isCrossArea: $isCrossArea
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        status
        assignedTo {
          id
          firstName
          lastName
          email
        }
        createdBy {
          id
        }
        category
        issueType
        createdAt
        userModified
        admin
        household {
          unicefId
          id
        }
        unicefId
        relatedTickets {
          id
        }
        priority
        urgency
        updatedAt
        totalDays
        programs {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useAllGrievanceTicketQuery__
 *
 * To run a query within a React component, call `useAllGrievanceTicketQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllGrievanceTicketQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllGrievanceTicketQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      id: // value for 'id'
 *      category: // value for 'category'
 *      issueType: // value for 'issueType'
 *      businessArea: // value for 'businessArea'
 *      search: // value for 'search'
 *      searchType: // value for 'searchType'
 *      status: // value for 'status'
 *      fsp: // value for 'fsp'
 *      createdAtRange: // value for 'createdAtRange'
 *      admin2: // value for 'admin2'
 *      orderBy: // value for 'orderBy'
 *      registrationDataImport: // value for 'registrationDataImport'
 *      assignedTo: // value for 'assignedTo'
 *      createdBy: // value for 'createdBy'
 *      cashPlan: // value for 'cashPlan'
 *      scoreMin: // value for 'scoreMin'
 *      scoreMax: // value for 'scoreMax'
 *      household: // value for 'household'
 *      grievanceType: // value for 'grievanceType'
 *      grievanceStatus: // value for 'grievanceStatus'
 *      priority: // value for 'priority'
 *      urgency: // value for 'urgency'
 *      preferredLanguage: // value for 'preferredLanguage'
 *      program: // value for 'program'
 *      isActiveProgram: // value for 'isActiveProgram'
 *      isCrossArea: // value for 'isCrossArea'
 *   },
 * });
 */
export function useAllGrievanceTicketQuery(baseOptions: Apollo.QueryHookOptions<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables> & ({ variables: AllGrievanceTicketQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables>(AllGrievanceTicketDocument, options);
      }
export function useAllGrievanceTicketLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables>(AllGrievanceTicketDocument, options);
        }
export function useAllGrievanceTicketSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables>(AllGrievanceTicketDocument, options);
        }
export type AllGrievanceTicketQueryHookResult = ReturnType<typeof useAllGrievanceTicketQuery>;
export type AllGrievanceTicketLazyQueryHookResult = ReturnType<typeof useAllGrievanceTicketLazyQuery>;
export type AllGrievanceTicketSuspenseQueryHookResult = ReturnType<typeof useAllGrievanceTicketSuspenseQuery>;
export type AllGrievanceTicketQueryResult = Apollo.QueryResult<AllGrievanceTicketQuery, AllGrievanceTicketQueryVariables>;
export const GrievanceTicketAreaScopeDocument = gql`
    query GrievanceTicketAreaScope {
  crossAreaFilterAvailable
}
    `;

/**
 * __useGrievanceTicketAreaScopeQuery__
 *
 * To run a query within a React component, call `useGrievanceTicketAreaScopeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGrievanceTicketAreaScopeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGrievanceTicketAreaScopeQuery({
 *   variables: {
 *   },
 * });
 */
export function useGrievanceTicketAreaScopeQuery(baseOptions?: Apollo.QueryHookOptions<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>(GrievanceTicketAreaScopeDocument, options);
      }
export function useGrievanceTicketAreaScopeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>(GrievanceTicketAreaScopeDocument, options);
        }
export function useGrievanceTicketAreaScopeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>(GrievanceTicketAreaScopeDocument, options);
        }
export type GrievanceTicketAreaScopeQueryHookResult = ReturnType<typeof useGrievanceTicketAreaScopeQuery>;
export type GrievanceTicketAreaScopeLazyQueryHookResult = ReturnType<typeof useGrievanceTicketAreaScopeLazyQuery>;
export type GrievanceTicketAreaScopeSuspenseQueryHookResult = ReturnType<typeof useGrievanceTicketAreaScopeSuspenseQuery>;
export type GrievanceTicketAreaScopeQueryResult = Apollo.QueryResult<GrievanceTicketAreaScopeQuery, GrievanceTicketAreaScopeQueryVariables>;
export const ExistingGrievanceTicketsDocument = gql`
    query ExistingGrievanceTickets($before: String, $after: String, $first: Int, $last: Int, $id: UUID, $businessArea: String!, $household: ID, $individual: ID, $paymentRecord: [ID], $category: String, $issueType: String, $orderBy: String) {
  existingGrievanceTickets(
    before: $before
    after: $after
    first: $first
    last: $last
    id: $id
    businessArea: $businessArea
    household: $household
    individual: $individual
    paymentRecord: $paymentRecord
    category: $category
    issueType: $issueType
    orderBy: $orderBy
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        unicefId
        status
        assignedTo {
          id
          firstName
          lastName
          email
        }
        category
        createdAt
        issueType
        userModified
        admin
        household {
          unicefId
          id
        }
        individual {
          unicefId
          id
        }
      }
    }
  }
}
    `;

/**
 * __useExistingGrievanceTicketsQuery__
 *
 * To run a query within a React component, call `useExistingGrievanceTicketsQuery` and pass it any options that fit your needs.
 * When your component renders, `useExistingGrievanceTicketsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useExistingGrievanceTicketsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      id: // value for 'id'
 *      businessArea: // value for 'businessArea'
 *      household: // value for 'household'
 *      individual: // value for 'individual'
 *      paymentRecord: // value for 'paymentRecord'
 *      category: // value for 'category'
 *      issueType: // value for 'issueType'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useExistingGrievanceTicketsQuery(baseOptions: Apollo.QueryHookOptions<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables> & ({ variables: ExistingGrievanceTicketsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables>(ExistingGrievanceTicketsDocument, options);
      }
export function useExistingGrievanceTicketsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables>(ExistingGrievanceTicketsDocument, options);
        }
export function useExistingGrievanceTicketsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables>(ExistingGrievanceTicketsDocument, options);
        }
export type ExistingGrievanceTicketsQueryHookResult = ReturnType<typeof useExistingGrievanceTicketsQuery>;
export type ExistingGrievanceTicketsLazyQueryHookResult = ReturnType<typeof useExistingGrievanceTicketsLazyQuery>;
export type ExistingGrievanceTicketsSuspenseQueryHookResult = ReturnType<typeof useExistingGrievanceTicketsSuspenseQuery>;
export type ExistingGrievanceTicketsQueryResult = Apollo.QueryResult<ExistingGrievanceTicketsQuery, ExistingGrievanceTicketsQueryVariables>;
export const GrievanceTicketDocument = gql`
    query GrievanceTicket($id: ID!) {
  grievanceTicket(id: $id) {
    ...grievanceTicketDetailed
  }
}
    ${GrievanceTicketDetailedFragmentDoc}`;

/**
 * __useGrievanceTicketQuery__
 *
 * To run a query within a React component, call `useGrievanceTicketQuery` and pass it any options that fit your needs.
 * When your component renders, `useGrievanceTicketQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGrievanceTicketQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGrievanceTicketQuery(baseOptions: Apollo.QueryHookOptions<GrievanceTicketQuery, GrievanceTicketQueryVariables> & ({ variables: GrievanceTicketQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GrievanceTicketQuery, GrievanceTicketQueryVariables>(GrievanceTicketDocument, options);
      }
export function useGrievanceTicketLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GrievanceTicketQuery, GrievanceTicketQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GrievanceTicketQuery, GrievanceTicketQueryVariables>(GrievanceTicketDocument, options);
        }
export function useGrievanceTicketSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GrievanceTicketQuery, GrievanceTicketQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GrievanceTicketQuery, GrievanceTicketQueryVariables>(GrievanceTicketDocument, options);
        }
export type GrievanceTicketQueryHookResult = ReturnType<typeof useGrievanceTicketQuery>;
export type GrievanceTicketLazyQueryHookResult = ReturnType<typeof useGrievanceTicketLazyQuery>;
export type GrievanceTicketSuspenseQueryHookResult = ReturnType<typeof useGrievanceTicketSuspenseQuery>;
export type GrievanceTicketQueryResult = Apollo.QueryResult<GrievanceTicketQuery, GrievanceTicketQueryVariables>;
export const GrievanceTicketFlexFieldsDocument = gql`
    query GrievanceTicketFlexFields($id: ID!) {
  grievanceTicket(id: $id) {
    id
    individualDataUpdateTicketDetails {
      id
      individualData
    }
    householdDataUpdateTicketDetails {
      id
      householdData
    }
  }
}
    `;

/**
 * __useGrievanceTicketFlexFieldsQuery__
 *
 * To run a query within a React component, call `useGrievanceTicketFlexFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGrievanceTicketFlexFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGrievanceTicketFlexFieldsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGrievanceTicketFlexFieldsQuery(baseOptions: Apollo.QueryHookOptions<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables> & ({ variables: GrievanceTicketFlexFieldsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables>(GrievanceTicketFlexFieldsDocument, options);
      }
export function useGrievanceTicketFlexFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables>(GrievanceTicketFlexFieldsDocument, options);
        }
export function useGrievanceTicketFlexFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables>(GrievanceTicketFlexFieldsDocument, options);
        }
export type GrievanceTicketFlexFieldsQueryHookResult = ReturnType<typeof useGrievanceTicketFlexFieldsQuery>;
export type GrievanceTicketFlexFieldsLazyQueryHookResult = ReturnType<typeof useGrievanceTicketFlexFieldsLazyQuery>;
export type GrievanceTicketFlexFieldsSuspenseQueryHookResult = ReturnType<typeof useGrievanceTicketFlexFieldsSuspenseQuery>;
export type GrievanceTicketFlexFieldsQueryResult = Apollo.QueryResult<GrievanceTicketFlexFieldsQuery, GrievanceTicketFlexFieldsQueryVariables>;
export const GrievanceTicketUnicefIdDocument = gql`
    query GrievanceTicketUnicefId($id: ID!) {
  grievanceTicket(id: $id) {
    id
    unicefId
  }
}
    `;

/**
 * __useGrievanceTicketUnicefIdQuery__
 *
 * To run a query within a React component, call `useGrievanceTicketUnicefIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGrievanceTicketUnicefIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGrievanceTicketUnicefIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGrievanceTicketUnicefIdQuery(baseOptions: Apollo.QueryHookOptions<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables> & ({ variables: GrievanceTicketUnicefIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables>(GrievanceTicketUnicefIdDocument, options);
      }
export function useGrievanceTicketUnicefIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables>(GrievanceTicketUnicefIdDocument, options);
        }
export function useGrievanceTicketUnicefIdSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables>(GrievanceTicketUnicefIdDocument, options);
        }
export type GrievanceTicketUnicefIdQueryHookResult = ReturnType<typeof useGrievanceTicketUnicefIdQuery>;
export type GrievanceTicketUnicefIdLazyQueryHookResult = ReturnType<typeof useGrievanceTicketUnicefIdLazyQuery>;
export type GrievanceTicketUnicefIdSuspenseQueryHookResult = ReturnType<typeof useGrievanceTicketUnicefIdSuspenseQuery>;
export type GrievanceTicketUnicefIdQueryResult = Apollo.QueryResult<GrievanceTicketUnicefIdQuery, GrievanceTicketUnicefIdQueryVariables>;
export const GrievancesChoiceDataDocument = gql`
    query GrievancesChoiceData {
  grievanceTicketStatusChoices {
    name
    value
  }
  grievanceTicketCategoryChoices {
    name
    value
  }
  grievanceTicketManualCategoryChoices {
    name
    value
  }
  grievanceTicketSystemCategoryChoices {
    name
    value
  }
  grievanceTicketPriorityChoices {
    name
    value
  }
  grievanceTicketUrgencyChoices {
    name
    value
  }
  grievanceTicketIssueTypeChoices {
    category
    label
    subCategories {
      name
      value
    }
  }
  grievanceTicketSearchTypesChoices {
    name
    value
  }
}
    `;

/**
 * __useGrievancesChoiceDataQuery__
 *
 * To run a query within a React component, call `useGrievancesChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGrievancesChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGrievancesChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useGrievancesChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>(GrievancesChoiceDataDocument, options);
      }
export function useGrievancesChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>(GrievancesChoiceDataDocument, options);
        }
export function useGrievancesChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>(GrievancesChoiceDataDocument, options);
        }
export type GrievancesChoiceDataQueryHookResult = ReturnType<typeof useGrievancesChoiceDataQuery>;
export type GrievancesChoiceDataLazyQueryHookResult = ReturnType<typeof useGrievancesChoiceDataLazyQuery>;
export type GrievancesChoiceDataSuspenseQueryHookResult = ReturnType<typeof useGrievancesChoiceDataSuspenseQuery>;
export type GrievancesChoiceDataQueryResult = Apollo.QueryResult<GrievancesChoiceDataQuery, GrievancesChoiceDataQueryVariables>;
export const PartnerForGrievanceChoicesDocument = gql`
    query partnerForGrievanceChoices($householdId: ID, $individualId: ID) {
  partnerForGrievanceChoices(
    householdId: $householdId
    individualId: $individualId
  ) {
    name
    value
  }
}
    `;

/**
 * __usePartnerForGrievanceChoicesQuery__
 *
 * To run a query within a React component, call `usePartnerForGrievanceChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePartnerForGrievanceChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePartnerForGrievanceChoicesQuery({
 *   variables: {
 *      householdId: // value for 'householdId'
 *      individualId: // value for 'individualId'
 *   },
 * });
 */
export function usePartnerForGrievanceChoicesQuery(baseOptions?: Apollo.QueryHookOptions<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>(PartnerForGrievanceChoicesDocument, options);
      }
export function usePartnerForGrievanceChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>(PartnerForGrievanceChoicesDocument, options);
        }
export function usePartnerForGrievanceChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>(PartnerForGrievanceChoicesDocument, options);
        }
export type PartnerForGrievanceChoicesQueryHookResult = ReturnType<typeof usePartnerForGrievanceChoicesQuery>;
export type PartnerForGrievanceChoicesLazyQueryHookResult = ReturnType<typeof usePartnerForGrievanceChoicesLazyQuery>;
export type PartnerForGrievanceChoicesSuspenseQueryHookResult = ReturnType<typeof usePartnerForGrievanceChoicesSuspenseQuery>;
export type PartnerForGrievanceChoicesQueryResult = Apollo.QueryResult<PartnerForGrievanceChoicesQuery, PartnerForGrievanceChoicesQueryVariables>;
export const RelatedGrievanceTicketsDocument = gql`
    query RelatedGrievanceTickets($id: ID!) {
  grievanceTicket(id: $id) {
    relatedTickets {
      id
      status
      category
      issueType
      unicefId
    }
  }
}
    `;

/**
 * __useRelatedGrievanceTicketsQuery__
 *
 * To run a query within a React component, call `useRelatedGrievanceTicketsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRelatedGrievanceTicketsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRelatedGrievanceTicketsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRelatedGrievanceTicketsQuery(baseOptions: Apollo.QueryHookOptions<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables> & ({ variables: RelatedGrievanceTicketsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables>(RelatedGrievanceTicketsDocument, options);
      }
export function useRelatedGrievanceTicketsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables>(RelatedGrievanceTicketsDocument, options);
        }
export function useRelatedGrievanceTicketsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables>(RelatedGrievanceTicketsDocument, options);
        }
export type RelatedGrievanceTicketsQueryHookResult = ReturnType<typeof useRelatedGrievanceTicketsQuery>;
export type RelatedGrievanceTicketsLazyQueryHookResult = ReturnType<typeof useRelatedGrievanceTicketsLazyQuery>;
export type RelatedGrievanceTicketsSuspenseQueryHookResult = ReturnType<typeof useRelatedGrievanceTicketsSuspenseQuery>;
export type RelatedGrievanceTicketsQueryResult = Apollo.QueryResult<RelatedGrievanceTicketsQuery, RelatedGrievanceTicketsQueryVariables>;
export const AllDeliveryMechanismsDocument = gql`
    query AllDeliveryMechanisms {
  allDeliveryMechanisms {
    name
    value
  }
}
    `;

/**
 * __useAllDeliveryMechanismsQuery__
 *
 * To run a query within a React component, call `useAllDeliveryMechanismsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllDeliveryMechanismsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllDeliveryMechanismsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllDeliveryMechanismsQuery(baseOptions?: Apollo.QueryHookOptions<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>(AllDeliveryMechanismsDocument, options);
      }
export function useAllDeliveryMechanismsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>(AllDeliveryMechanismsDocument, options);
        }
export function useAllDeliveryMechanismsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>(AllDeliveryMechanismsDocument, options);
        }
export type AllDeliveryMechanismsQueryHookResult = ReturnType<typeof useAllDeliveryMechanismsQuery>;
export type AllDeliveryMechanismsLazyQueryHookResult = ReturnType<typeof useAllDeliveryMechanismsLazyQuery>;
export type AllDeliveryMechanismsSuspenseQueryHookResult = ReturnType<typeof useAllDeliveryMechanismsSuspenseQuery>;
export type AllDeliveryMechanismsQueryResult = Apollo.QueryResult<AllDeliveryMechanismsQuery, AllDeliveryMechanismsQueryVariables>;
export const AllPaymentPlansForTableDocument = gql`
    query AllPaymentPlansForTable($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $businessArea: String!, $search: String, $status: [String], $totalEntitledQuantityFrom: Float, $totalEntitledQuantityTo: Float, $dispersionStartDate: Date, $dispersionEndDate: Date, $isFollowUp: Boolean, $program: String) {
  allPaymentPlans(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    businessArea: $businessArea
    search: $search
    status: $status
    totalEntitledQuantityFrom: $totalEntitledQuantityFrom
    totalEntitledQuantityTo: $totalEntitledQuantityTo
    dispersionStartDate: $dispersionStartDate
    dispersionEndDate: $dispersionEndDate
    isFollowUp: $isFollowUp
    program: $program
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        unicefId
        name
        isFollowUp
        followUps {
          totalCount
          edges {
            node {
              id
              unicefId
            }
          }
        }
        status
        createdBy {
          id
          firstName
          lastName
          email
        }
        program {
          id
          name
        }
        targetPopulation {
          id
          name
        }
        currency
        currencyName
        startDate
        endDate
        dispersionStartDate
        dispersionEndDate
        femaleChildrenCount
        femaleAdultsCount
        maleChildrenCount
        maleAdultsCount
        totalHouseholdsCount
        totalIndividualsCount
        totalEntitledQuantity
        totalDeliveredQuantity
        totalUndeliveredQuantity
      }
    }
  }
}
    `;

/**
 * __useAllPaymentPlansForTableQuery__
 *
 * To run a query within a React component, call `useAllPaymentPlansForTableQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllPaymentPlansForTableQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllPaymentPlansForTableQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      businessArea: // value for 'businessArea'
 *      search: // value for 'search'
 *      status: // value for 'status'
 *      totalEntitledQuantityFrom: // value for 'totalEntitledQuantityFrom'
 *      totalEntitledQuantityTo: // value for 'totalEntitledQuantityTo'
 *      dispersionStartDate: // value for 'dispersionStartDate'
 *      dispersionEndDate: // value for 'dispersionEndDate'
 *      isFollowUp: // value for 'isFollowUp'
 *      program: // value for 'program'
 *   },
 * });
 */
export function useAllPaymentPlansForTableQuery(baseOptions: Apollo.QueryHookOptions<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables> & ({ variables: AllPaymentPlansForTableQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables>(AllPaymentPlansForTableDocument, options);
      }
export function useAllPaymentPlansForTableLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables>(AllPaymentPlansForTableDocument, options);
        }
export function useAllPaymentPlansForTableSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables>(AllPaymentPlansForTableDocument, options);
        }
export type AllPaymentPlansForTableQueryHookResult = ReturnType<typeof useAllPaymentPlansForTableQuery>;
export type AllPaymentPlansForTableLazyQueryHookResult = ReturnType<typeof useAllPaymentPlansForTableLazyQuery>;
export type AllPaymentPlansForTableSuspenseQueryHookResult = ReturnType<typeof useAllPaymentPlansForTableSuspenseQuery>;
export type AllPaymentPlansForTableQueryResult = Apollo.QueryResult<AllPaymentPlansForTableQuery, AllPaymentPlansForTableQueryVariables>;
export const AvailableFspsForDeliveryMechanismsDocument = gql`
    query AvailableFspsForDeliveryMechanisms($input: AvailableFspsForDeliveryMechanismsInput!) {
  availableFspsForDeliveryMechanisms(input: $input) {
    deliveryMechanism
    fsps {
      id
      name
      configurations {
        id
        key
        label
      }
    }
  }
}
    `;

/**
 * __useAvailableFspsForDeliveryMechanismsQuery__
 *
 * To run a query within a React component, call `useAvailableFspsForDeliveryMechanismsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAvailableFspsForDeliveryMechanismsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAvailableFspsForDeliveryMechanismsQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAvailableFspsForDeliveryMechanismsQuery(baseOptions: Apollo.QueryHookOptions<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables> & ({ variables: AvailableFspsForDeliveryMechanismsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables>(AvailableFspsForDeliveryMechanismsDocument, options);
      }
export function useAvailableFspsForDeliveryMechanismsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables>(AvailableFspsForDeliveryMechanismsDocument, options);
        }
export function useAvailableFspsForDeliveryMechanismsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables>(AvailableFspsForDeliveryMechanismsDocument, options);
        }
export type AvailableFspsForDeliveryMechanismsQueryHookResult = ReturnType<typeof useAvailableFspsForDeliveryMechanismsQuery>;
export type AvailableFspsForDeliveryMechanismsLazyQueryHookResult = ReturnType<typeof useAvailableFspsForDeliveryMechanismsLazyQuery>;
export type AvailableFspsForDeliveryMechanismsSuspenseQueryHookResult = ReturnType<typeof useAvailableFspsForDeliveryMechanismsSuspenseQuery>;
export type AvailableFspsForDeliveryMechanismsQueryResult = Apollo.QueryResult<AvailableFspsForDeliveryMechanismsQuery, AvailableFspsForDeliveryMechanismsQueryVariables>;
export const PaymentDocument = gql`
    query Payment($id: ID!) {
  payment(id: $id) {
    id
    unicefId
    distributionModality
    status
    statusDate
    snapshotCollectorBankName
    snapshotCollectorBankAccountNumber
    debitCardNumber
    debitCardIssuer
    targetPopulation {
      id
      name
    }
    sourcePayment {
      id
      unicefId
    }
    verification {
      id
      status
      statusDate
      receivedAmount
      isManuallyEditable
      adminUrl
    }
    currency
    entitlementQuantity
    deliveredQuantity
    deliveryDate
    household {
      id
      size
      status
      unicefId
      headOfHousehold {
        id
        phoneNo
        phoneNoAlternative
        phoneNoValid
        phoneNoAlternativeValid
        fullName
      }
    }
    collector {
      id
      unicefId
      fullName
      email
      phoneNo
      phoneNoValid
      phoneNoAlternative
      phoneNoAlternativeValid
    }
    parent {
      id
      status
      isFollowUp
      unicefId
      program {
        id
        name
      }
      verificationPlans {
        edges {
          node {
            id
            status
            verificationChannel
          }
        }
      }
    }
    deliveredQuantityUsd
    deliveryType
    transactionReferenceId
    serviceProvider {
      id
      fullName
    }
    additionalCollectorName
    additionalDocumentType
    additionalDocumentNumber
    reasonForUnsuccessfulPayment
    snapshotCollectorFullName
    adminUrl
  }
}
    `;

/**
 * __usePaymentQuery__
 *
 * To run a query within a React component, call `usePaymentQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePaymentQuery(baseOptions: Apollo.QueryHookOptions<PaymentQuery, PaymentQueryVariables> & ({ variables: PaymentQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentQuery, PaymentQueryVariables>(PaymentDocument, options);
      }
export function usePaymentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentQuery, PaymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentQuery, PaymentQueryVariables>(PaymentDocument, options);
        }
export function usePaymentSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentQuery, PaymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentQuery, PaymentQueryVariables>(PaymentDocument, options);
        }
export type PaymentQueryHookResult = ReturnType<typeof usePaymentQuery>;
export type PaymentLazyQueryHookResult = ReturnType<typeof usePaymentLazyQuery>;
export type PaymentSuspenseQueryHookResult = ReturnType<typeof usePaymentSuspenseQuery>;
export type PaymentQueryResult = Apollo.QueryResult<PaymentQuery, PaymentQueryVariables>;
export const PaymentPlanDocument = gql`
    query PaymentPlan($id: ID!) {
  paymentPlan(id: $id) {
    id
    version
    unicefId
    status
    canCreateFollowUp
    backgroundActionStatus
    canCreatePaymentVerificationPlan
    availablePaymentRecordsCount
    bankReconciliationSuccess
    bankReconciliationError
    createdBy {
      id
      firstName
      lastName
      email
    }
    program {
      id
      name
      caId
    }
    targetPopulation {
      id
      name
    }
    adminUrl
    currency
    currencyName
    startDate
    endDate
    dispersionStartDate
    dispersionEndDate
    femaleChildrenCount
    femaleAdultsCount
    maleChildrenCount
    maleAdultsCount
    totalHouseholdsCount
    totalIndividualsCount
    totalEntitledQuantity
    totalDeliveredQuantity
    totalUndeliveredQuantity
    totalWithdrawnHouseholdsCount
    approvalProcess {
      totalCount
      edgeCount
      edges {
        node {
          id
          sentForApprovalBy {
            id
            firstName
            lastName
            email
          }
          sentForApprovalDate
          sentForAuthorizationBy {
            id
            firstName
            lastName
            email
          }
          sentForAuthorizationDate
          sentForFinanceReleaseBy {
            id
            firstName
            lastName
            email
          }
          sentForFinanceReleaseDate
          approvalNumberRequired
          authorizationNumberRequired
          financeReleaseNumberRequired
          actions {
            approval {
              createdAt
              comment
              info
              createdBy {
                id
                firstName
                lastName
                email
              }
            }
            authorization {
              createdAt
              comment
              info
              createdBy {
                id
                firstName
                lastName
                email
              }
            }
            financeRelease {
              createdAt
              comment
              info
              createdBy {
                id
                firstName
                lastName
                email
              }
            }
            reject {
              createdAt
              comment
              info
              createdBy {
                id
                firstName
                lastName
                email
              }
            }
          }
          rejectedOn
        }
      }
    }
    steficonRule {
      id
      rule {
        id
        name
      }
    }
    hasPaymentListExportFile
    hasFspDeliveryMechanismXlsxTemplate
    importedFileDate
    importedFileName
    totalEntitledQuantityUsd
    paymentsConflictsCount
    deliveryMechanisms {
      id
      name
      order
      sentToPaymentGateway
      chosenConfiguration
      fsp {
        id
        name
        communicationChannel
        isPaymentGateway
      }
    }
    canSendToPaymentGateway
    canSplit
    splitChoices {
      name
      value
    }
    volumeByDeliveryMechanism {
      deliveryMechanism {
        id
        name
        order
        fsp {
          id
          name
        }
      }
      volume
      volumeUsd
    }
    verificationPlans {
      totalCount
      edges {
        node {
          id
          unicefId
          adminUrl
          status
          sampleSize
          receivedCount
          notReceivedCount
          respondedCount
          verificationChannel
          sampling
          receivedCount
          receivedWithProblemsCount
          rapidProFlowId
          confidenceInterval
          marginOfError
          activationDate
          completionDate
          ageFilter {
            min
            max
          }
          excludedAdminAreasFilter
          sexFilter
          xlsxFileExporting
          hasXlsxFile
          xlsxFileWasDownloaded
          xlsxFileImported
        }
      }
    }
    paymentVerificationSummary {
      id
      createdAt
      updatedAt
      status
      activationDate
      completionDate
    }
    paymentItems {
      totalCount
      edgeCount
      edges {
        node {
          id
          status
        }
      }
    }
    reconciliationSummary {
      deliveredFully
      deliveredPartially
      notDelivered
      unsuccessful
      pending
      numberOfPayments
      reconciled
    }
    excludedHouseholds {
      id
      unicefId
    }
    exclusionReason
    excludeHouseholdError
    isFollowUp
    followUps {
      totalCount
      edges {
        node {
          id
          unicefId
          createdAt
          paymentItems {
            totalCount
          }
        }
      }
    }
    sourcePaymentPlan {
      id
      unicefId
    }
    unsuccessfulPaymentsCount
  }
}
    `;

/**
 * __usePaymentPlanQuery__
 *
 * To run a query within a React component, call `usePaymentPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentPlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePaymentPlanQuery(baseOptions: Apollo.QueryHookOptions<PaymentPlanQuery, PaymentPlanQueryVariables> & ({ variables: PaymentPlanQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentPlanQuery, PaymentPlanQueryVariables>(PaymentPlanDocument, options);
      }
export function usePaymentPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentPlanQuery, PaymentPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentPlanQuery, PaymentPlanQueryVariables>(PaymentPlanDocument, options);
        }
export function usePaymentPlanSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentPlanQuery, PaymentPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentPlanQuery, PaymentPlanQueryVariables>(PaymentPlanDocument, options);
        }
export type PaymentPlanQueryHookResult = ReturnType<typeof usePaymentPlanQuery>;
export type PaymentPlanLazyQueryHookResult = ReturnType<typeof usePaymentPlanLazyQuery>;
export type PaymentPlanSuspenseQueryHookResult = ReturnType<typeof usePaymentPlanSuspenseQuery>;
export type PaymentPlanQueryResult = Apollo.QueryResult<PaymentPlanQuery, PaymentPlanQueryVariables>;
export const AllCashPlansDocument = gql`
    query AllCashPlans($program: ID, $after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $search: String, $serviceProvider: String, $deliveryType: [String], $verificationStatus: [String], $startDateGte: DateTime, $endDateLte: DateTime, $businessArea: String) {
  allCashPlans(
    program: $program
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    search: $search
    serviceProvider_FullName_Startswith: $serviceProvider
    deliveryType: $deliveryType
    verificationStatus: $verificationStatus
    startDate_Gte: $startDateGte
    endDate_Lte: $endDateLte
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        caId
        assistanceThrough
        totalNumberOfHouseholds
        serviceProvider {
          id
          caId
          fullName
        }
        deliveryType
        startDate
        endDate
        program {
          id
          name
        }
        totalPersonsCovered
        dispersionDate
        assistanceMeasurement
        status
        currency
        totalEntitledQuantity
        totalDeliveredQuantity
        totalUndeliveredQuantity
        updatedAt
        paymentVerificationSummary {
          id
          status
        }
      }
    }
  }
}
    `;

/**
 * __useAllCashPlansQuery__
 *
 * To run a query within a React component, call `useAllCashPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllCashPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllCashPlansQuery({
 *   variables: {
 *      program: // value for 'program'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      search: // value for 'search'
 *      serviceProvider: // value for 'serviceProvider'
 *      deliveryType: // value for 'deliveryType'
 *      verificationStatus: // value for 'verificationStatus'
 *      startDateGte: // value for 'startDateGte'
 *      endDateLte: // value for 'endDateLte'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllCashPlansQuery(baseOptions?: Apollo.QueryHookOptions<AllCashPlansQuery, AllCashPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllCashPlansQuery, AllCashPlansQueryVariables>(AllCashPlansDocument, options);
      }
export function useAllCashPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllCashPlansQuery, AllCashPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllCashPlansQuery, AllCashPlansQueryVariables>(AllCashPlansDocument, options);
        }
export function useAllCashPlansSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllCashPlansQuery, AllCashPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllCashPlansQuery, AllCashPlansQueryVariables>(AllCashPlansDocument, options);
        }
export type AllCashPlansQueryHookResult = ReturnType<typeof useAllCashPlansQuery>;
export type AllCashPlansLazyQueryHookResult = ReturnType<typeof useAllCashPlansLazyQuery>;
export type AllCashPlansSuspenseQueryHookResult = ReturnType<typeof useAllCashPlansSuspenseQuery>;
export type AllCashPlansQueryResult = Apollo.QueryResult<AllCashPlansQuery, AllCashPlansQueryVariables>;
export const AllCashPlansAndPaymentPlansDocument = gql`
    query allCashPlansAndPaymentPlans($businessArea: String!, $program: String, $search: String, $serviceProvider: String, $deliveryType: [String], $verificationStatus: [String], $startDateGte: String, $endDateLte: String, $orderBy: String, $first: Int, $last: Int, $before: String, $after: String, $isPaymentVerificationPage: Boolean) {
  allCashPlansAndPaymentPlans(
    businessArea: $businessArea
    program: $program
    search: $search
    serviceProvider: $serviceProvider
    deliveryType: $deliveryType
    verificationStatus: $verificationStatus
    startDateGte: $startDateGte
    endDateLte: $endDateLte
    orderBy: $orderBy
    first: $first
    last: $last
    before: $before
    after: $after
    isPaymentVerificationPage: $isPaymentVerificationPage
  ) {
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
    edges {
      cursor
      node {
        objType
        id
        unicefId
        verificationStatus
        status
        currency
        totalDeliveredQuantity
        startDate
        endDate
        programName
        updatedAt
        verificationPlans {
          id
          createdAt
          unicefId
        }
        totalNumberOfHouseholds
        assistanceMeasurement
        totalEntitledQuantity
        totalUndeliveredQuantity
        dispersionDate
        serviceProviderFullName
      }
    }
  }
}
    `;

/**
 * __useAllCashPlansAndPaymentPlansQuery__
 *
 * To run a query within a React component, call `useAllCashPlansAndPaymentPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllCashPlansAndPaymentPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllCashPlansAndPaymentPlansQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *      program: // value for 'program'
 *      search: // value for 'search'
 *      serviceProvider: // value for 'serviceProvider'
 *      deliveryType: // value for 'deliveryType'
 *      verificationStatus: // value for 'verificationStatus'
 *      startDateGte: // value for 'startDateGte'
 *      endDateLte: // value for 'endDateLte'
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      isPaymentVerificationPage: // value for 'isPaymentVerificationPage'
 *   },
 * });
 */
export function useAllCashPlansAndPaymentPlansQuery(baseOptions: Apollo.QueryHookOptions<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables> & ({ variables: AllCashPlansAndPaymentPlansQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables>(AllCashPlansAndPaymentPlansDocument, options);
      }
export function useAllCashPlansAndPaymentPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables>(AllCashPlansAndPaymentPlansDocument, options);
        }
export function useAllCashPlansAndPaymentPlansSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables>(AllCashPlansAndPaymentPlansDocument, options);
        }
export type AllCashPlansAndPaymentPlansQueryHookResult = ReturnType<typeof useAllCashPlansAndPaymentPlansQuery>;
export type AllCashPlansAndPaymentPlansLazyQueryHookResult = ReturnType<typeof useAllCashPlansAndPaymentPlansLazyQuery>;
export type AllCashPlansAndPaymentPlansSuspenseQueryHookResult = ReturnType<typeof useAllCashPlansAndPaymentPlansSuspenseQuery>;
export type AllCashPlansAndPaymentPlansQueryResult = Apollo.QueryResult<AllCashPlansAndPaymentPlansQuery, AllCashPlansAndPaymentPlansQueryVariables>;
export const AllPaymentRecordsDocument = gql`
    query AllPaymentRecords($parent: ID, $household: ID, $after: String, $before: String, $orderBy: String, $first: Int, $last: Int, $businessArea: String) {
  allPaymentRecords(
    parent: $parent
    household: $household
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        createdAt
        updatedAt
        fullName
        statusDate
        status
        caId
        totalPersonsCovered
        household {
          id
          unicefId
          size
        }
        headOfHousehold {
          id
          fullName
        }
        currency
        entitlementQuantity
        deliveredQuantity
        deliveredQuantityUsd
        deliveryDate
        parent {
          id
          program {
            id
            name
          }
        }
      }
    }
    totalCount
    edgeCount
  }
}
    `;

/**
 * __useAllPaymentRecordsQuery__
 *
 * To run a query within a React component, call `useAllPaymentRecordsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllPaymentRecordsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllPaymentRecordsQuery({
 *   variables: {
 *      parent: // value for 'parent'
 *      household: // value for 'household'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllPaymentRecordsQuery(baseOptions?: Apollo.QueryHookOptions<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>(AllPaymentRecordsDocument, options);
      }
export function useAllPaymentRecordsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>(AllPaymentRecordsDocument, options);
        }
export function useAllPaymentRecordsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>(AllPaymentRecordsDocument, options);
        }
export type AllPaymentRecordsQueryHookResult = ReturnType<typeof useAllPaymentRecordsQuery>;
export type AllPaymentRecordsLazyQueryHookResult = ReturnType<typeof useAllPaymentRecordsLazyQuery>;
export type AllPaymentRecordsSuspenseQueryHookResult = ReturnType<typeof useAllPaymentRecordsSuspenseQuery>;
export type AllPaymentRecordsQueryResult = Apollo.QueryResult<AllPaymentRecordsQuery, AllPaymentRecordsQueryVariables>;
export const AllPaymentRecordsAndPaymentsDocument = gql`
    query AllPaymentRecordsAndPayments($household: ID, $after: String, $before: String, $orderBy: String, $first: Int, $last: Int, $businessArea: String!) {
  allPaymentRecordsAndPayments(
    household: $household
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        objType
        id
        fullName
        status
        caId
        currency
        entitlementQuantity
        deliveredQuantity
        deliveredQuantityUsd
        deliveryDate
        parent {
          id
          programName
        }
        verification {
          id
          receivedAmount
        }
      }
    }
    totalCount
  }
}
    `;

/**
 * __useAllPaymentRecordsAndPaymentsQuery__
 *
 * To run a query within a React component, call `useAllPaymentRecordsAndPaymentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllPaymentRecordsAndPaymentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllPaymentRecordsAndPaymentsQuery({
 *   variables: {
 *      household: // value for 'household'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllPaymentRecordsAndPaymentsQuery(baseOptions: Apollo.QueryHookOptions<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables> & ({ variables: AllPaymentRecordsAndPaymentsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables>(AllPaymentRecordsAndPaymentsDocument, options);
      }
export function useAllPaymentRecordsAndPaymentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables>(AllPaymentRecordsAndPaymentsDocument, options);
        }
export function useAllPaymentRecordsAndPaymentsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables>(AllPaymentRecordsAndPaymentsDocument, options);
        }
export type AllPaymentRecordsAndPaymentsQueryHookResult = ReturnType<typeof useAllPaymentRecordsAndPaymentsQuery>;
export type AllPaymentRecordsAndPaymentsLazyQueryHookResult = ReturnType<typeof useAllPaymentRecordsAndPaymentsLazyQuery>;
export type AllPaymentRecordsAndPaymentsSuspenseQueryHookResult = ReturnType<typeof useAllPaymentRecordsAndPaymentsSuspenseQuery>;
export type AllPaymentRecordsAndPaymentsQueryResult = Apollo.QueryResult<AllPaymentRecordsAndPaymentsQuery, AllPaymentRecordsAndPaymentsQueryVariables>;
export const AllPaymentsForTableDocument = gql`
    query AllPaymentsForTable($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $businessArea: String!, $paymentPlanId: String!) {
  allPayments(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    businessArea: $businessArea
    paymentPlanId: $paymentPlanId
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        unicefId
        status
        household {
          id
          unicefId
          size
          admin2 {
            id
            name
          }
          individuals {
            edges {
              node {
                id
                unicefId
                fullName
              }
            }
          }
        }
        entitlementQuantity
        entitlementQuantityUsd
        currency
        deliveredQuantity
        deliveredQuantityUsd
        paymentPlanHardConflicted
        paymentPlanSoftConflicted
        paymentPlanHardConflictedData {
          paymentPlanUnicefId
          paymentPlanId
          paymentPlanStartDate
          paymentPlanEndDate
          paymentPlanStatus
          paymentId
          paymentUnicefId
        }
        paymentPlanSoftConflictedData {
          paymentPlanUnicefId
          paymentPlanId
          paymentPlanStartDate
          paymentPlanEndDate
          paymentPlanStatus
          paymentId
          paymentUnicefId
        }
        collector {
          id
          unicefId
          fullName
        }
        financialServiceProvider {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useAllPaymentsForTableQuery__
 *
 * To run a query within a React component, call `useAllPaymentsForTableQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllPaymentsForTableQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllPaymentsForTableQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      businessArea: // value for 'businessArea'
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useAllPaymentsForTableQuery(baseOptions: Apollo.QueryHookOptions<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables> & ({ variables: AllPaymentsForTableQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables>(AllPaymentsForTableDocument, options);
      }
export function useAllPaymentsForTableLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables>(AllPaymentsForTableDocument, options);
        }
export function useAllPaymentsForTableSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables>(AllPaymentsForTableDocument, options);
        }
export type AllPaymentsForTableQueryHookResult = ReturnType<typeof useAllPaymentsForTableQuery>;
export type AllPaymentsForTableLazyQueryHookResult = ReturnType<typeof useAllPaymentsForTableLazyQuery>;
export type AllPaymentsForTableSuspenseQueryHookResult = ReturnType<typeof useAllPaymentsForTableSuspenseQuery>;
export type AllPaymentsForTableQueryResult = Apollo.QueryResult<AllPaymentsForTableQuery, AllPaymentsForTableQueryVariables>;
export const CashPlanDocument = gql`
    query CashPlan($id: ID!) {
  cashPlan(id: $id) {
    id
    version
    canCreatePaymentVerificationPlan
    availablePaymentRecordsCount
    name
    startDate
    endDate
    updatedAt
    status
    deliveryType
    fundsCommitment
    downPayment
    dispersionDate
    assistanceThrough
    serviceProvider {
      id
      caId
      fullName
    }
    caId
    caHashId
    dispersionDate
    bankReconciliationSuccess
    bankReconciliationError
    totalNumberOfHouseholds
    verificationPlans {
      totalCount
      edges {
        node {
          id
          unicefId
          adminUrl
          status
          sampleSize
          receivedCount
          notReceivedCount
          respondedCount
          verificationChannel
          sampling
          receivedCount
          receivedWithProblemsCount
          rapidProFlowId
          confidenceInterval
          marginOfError
          activationDate
          completionDate
          ageFilter {
            min
            max
          }
          excludedAdminAreasFilter
          sexFilter
          xlsxFileExporting
          hasXlsxFile
          xlsxFileWasDownloaded
          xlsxFileImported
        }
      }
    }
    paymentVerificationSummary {
      id
      createdAt
      updatedAt
      status
      activationDate
      completionDate
    }
    program {
      id
      name
      caId
    }
    paymentItems {
      totalCount
      edgeCount
      edges {
        node {
          targetPopulation {
            id
            name
          }
        }
      }
    }
  }
}
    `;

/**
 * __useCashPlanQuery__
 *
 * To run a query within a React component, call `useCashPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useCashPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCashPlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCashPlanQuery(baseOptions: Apollo.QueryHookOptions<CashPlanQuery, CashPlanQueryVariables> & ({ variables: CashPlanQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CashPlanQuery, CashPlanQueryVariables>(CashPlanDocument, options);
      }
export function useCashPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CashPlanQuery, CashPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CashPlanQuery, CashPlanQueryVariables>(CashPlanDocument, options);
        }
export function useCashPlanSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CashPlanQuery, CashPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CashPlanQuery, CashPlanQueryVariables>(CashPlanDocument, options);
        }
export type CashPlanQueryHookResult = ReturnType<typeof useCashPlanQuery>;
export type CashPlanLazyQueryHookResult = ReturnType<typeof useCashPlanLazyQuery>;
export type CashPlanSuspenseQueryHookResult = ReturnType<typeof useCashPlanSuspenseQuery>;
export type CashPlanQueryResult = Apollo.QueryResult<CashPlanQuery, CashPlanQueryVariables>;
export const IndividualPhotosDocument = gql`
    query IndividualPhotos($id: ID!) {
  individual(id: $id) {
    id
    photo
    documents {
      edges {
        node {
          id
          documentNumber
          photo
        }
      }
    }
  }
}
    `;

/**
 * __useIndividualPhotosQuery__
 *
 * To run a query within a React component, call `useIndividualPhotosQuery` and pass it any options that fit your needs.
 * When your component renders, `useIndividualPhotosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIndividualPhotosQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useIndividualPhotosQuery(baseOptions: Apollo.QueryHookOptions<IndividualPhotosQuery, IndividualPhotosQueryVariables> & ({ variables: IndividualPhotosQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IndividualPhotosQuery, IndividualPhotosQueryVariables>(IndividualPhotosDocument, options);
      }
export function useIndividualPhotosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IndividualPhotosQuery, IndividualPhotosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IndividualPhotosQuery, IndividualPhotosQueryVariables>(IndividualPhotosDocument, options);
        }
export function useIndividualPhotosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IndividualPhotosQuery, IndividualPhotosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IndividualPhotosQuery, IndividualPhotosQueryVariables>(IndividualPhotosDocument, options);
        }
export type IndividualPhotosQueryHookResult = ReturnType<typeof useIndividualPhotosQuery>;
export type IndividualPhotosLazyQueryHookResult = ReturnType<typeof useIndividualPhotosLazyQuery>;
export type IndividualPhotosSuspenseQueryHookResult = ReturnType<typeof useIndividualPhotosSuspenseQuery>;
export type IndividualPhotosQueryResult = Apollo.QueryResult<IndividualPhotosQuery, IndividualPhotosQueryVariables>;
export const ImportedIndividualPhotosDocument = gql`
    query ImportedIndividualPhotos($id: ID!) {
  importedIndividual(id: $id) {
    id
    photo
    documents {
      edges {
        node {
          id
          photo
        }
      }
    }
  }
}
    `;

/**
 * __useImportedIndividualPhotosQuery__
 *
 * To run a query within a React component, call `useImportedIndividualPhotosQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedIndividualPhotosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedIndividualPhotosQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useImportedIndividualPhotosQuery(baseOptions: Apollo.QueryHookOptions<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables> & ({ variables: ImportedIndividualPhotosQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables>(ImportedIndividualPhotosDocument, options);
      }
export function useImportedIndividualPhotosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables>(ImportedIndividualPhotosDocument, options);
        }
export function useImportedIndividualPhotosSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables>(ImportedIndividualPhotosDocument, options);
        }
export type ImportedIndividualPhotosQueryHookResult = ReturnType<typeof useImportedIndividualPhotosQuery>;
export type ImportedIndividualPhotosLazyQueryHookResult = ReturnType<typeof useImportedIndividualPhotosLazyQuery>;
export type ImportedIndividualPhotosSuspenseQueryHookResult = ReturnType<typeof useImportedIndividualPhotosSuspenseQuery>;
export type ImportedIndividualPhotosQueryResult = Apollo.QueryResult<ImportedIndividualPhotosQuery, ImportedIndividualPhotosQueryVariables>;
export const LookUpPaymentRecordsDocument = gql`
    query LookUpPaymentRecords($parent: ID, $household: ID, $after: String, $before: String, $orderBy: String, $first: Int, $last: Int, $businessArea: String) {
  allPaymentRecords(
    parent: $parent
    household: $household
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        caId
        parent {
          id
          name
        }
        deliveredQuantity
      }
    }
    totalCount
    edgeCount
  }
}
    `;

/**
 * __useLookUpPaymentRecordsQuery__
 *
 * To run a query within a React component, call `useLookUpPaymentRecordsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLookUpPaymentRecordsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLookUpPaymentRecordsQuery({
 *   variables: {
 *      parent: // value for 'parent'
 *      household: // value for 'household'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useLookUpPaymentRecordsQuery(baseOptions?: Apollo.QueryHookOptions<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>(LookUpPaymentRecordsDocument, options);
      }
export function useLookUpPaymentRecordsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>(LookUpPaymentRecordsDocument, options);
        }
export function useLookUpPaymentRecordsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>(LookUpPaymentRecordsDocument, options);
        }
export type LookUpPaymentRecordsQueryHookResult = ReturnType<typeof useLookUpPaymentRecordsQuery>;
export type LookUpPaymentRecordsLazyQueryHookResult = ReturnType<typeof useLookUpPaymentRecordsLazyQuery>;
export type LookUpPaymentRecordsSuspenseQueryHookResult = ReturnType<typeof useLookUpPaymentRecordsSuspenseQuery>;
export type LookUpPaymentRecordsQueryResult = Apollo.QueryResult<LookUpPaymentRecordsQuery, LookUpPaymentRecordsQueryVariables>;
export const PaymentRecordDocument = gql`
    query PaymentRecord($id: ID!) {
  paymentRecord(id: $id) {
    id
    status
    statusDate
    caId
    caHashId
    registrationCaId
    fullName
    distributionModality
    totalPersonsCovered
    targetPopulation {
      id
      name
    }
    verification {
      id
      status
      statusDate
      receivedAmount
      isManuallyEditable
      adminUrl
    }
    currency
    entitlementQuantity
    deliveredQuantity
    deliveryDate
    entitlementCardIssueDate
    entitlementCardNumber
    household {
      id
      size
      status
      unicefId
      headOfHousehold {
        id
        phoneNo
        phoneNoAlternative
        phoneNoValid
        phoneNoAlternativeValid
      }
    }
    parent {
      id
      unicefId
      caId
      program {
        id
        name
      }
      verificationPlans {
        edges {
          node {
            id
            status
            verificationChannel
          }
        }
      }
    }
    deliveredQuantityUsd
    deliveryType
    transactionReferenceId
    serviceProvider {
      id
      fullName
      shortName
    }
  }
}
    `;

/**
 * __usePaymentRecordQuery__
 *
 * To run a query within a React component, call `usePaymentRecordQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentRecordQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentRecordQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePaymentRecordQuery(baseOptions: Apollo.QueryHookOptions<PaymentRecordQuery, PaymentRecordQueryVariables> & ({ variables: PaymentRecordQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentRecordQuery, PaymentRecordQueryVariables>(PaymentRecordDocument, options);
      }
export function usePaymentRecordLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentRecordQuery, PaymentRecordQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentRecordQuery, PaymentRecordQueryVariables>(PaymentRecordDocument, options);
        }
export function usePaymentRecordSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentRecordQuery, PaymentRecordQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentRecordQuery, PaymentRecordQueryVariables>(PaymentRecordDocument, options);
        }
export type PaymentRecordQueryHookResult = ReturnType<typeof usePaymentRecordQuery>;
export type PaymentRecordLazyQueryHookResult = ReturnType<typeof usePaymentRecordLazyQuery>;
export type PaymentRecordSuspenseQueryHookResult = ReturnType<typeof usePaymentRecordSuspenseQuery>;
export type PaymentRecordQueryResult = Apollo.QueryResult<PaymentRecordQuery, PaymentRecordQueryVariables>;
export const AllPaymentVerificationLogEntriesDocument = gql`
    query AllPaymentVerificationLogEntries($businessArea: String!, $objectId: UUID, $objectType: String, $after: String, $before: String, $first: Int, $last: Int, $search: String, $module: String) {
  allPaymentVerificationLogEntries(
    after: $after
    before: $before
    first: $first
    last: $last
    objectId: $objectId
    objectType: $objectType
    businessArea: $businessArea
    search: $search
    module: $module
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        action
        changes
        objectRepr
        objectId
        timestamp
        contentType {
          id
          appLabel
          model
          name
        }
        user {
          id
          firstName
          lastName
        }
        contentObject {
          id
          unicefId
        }
      }
    }
  }
  logEntryActionChoices {
    name
    value
  }
}
    `;

/**
 * __useAllPaymentVerificationLogEntriesQuery__
 *
 * To run a query within a React component, call `useAllPaymentVerificationLogEntriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllPaymentVerificationLogEntriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllPaymentVerificationLogEntriesQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *      objectId: // value for 'objectId'
 *      objectType: // value for 'objectType'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      search: // value for 'search'
 *      module: // value for 'module'
 *   },
 * });
 */
export function useAllPaymentVerificationLogEntriesQuery(baseOptions: Apollo.QueryHookOptions<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables> & ({ variables: AllPaymentVerificationLogEntriesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables>(AllPaymentVerificationLogEntriesDocument, options);
      }
export function useAllPaymentVerificationLogEntriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables>(AllPaymentVerificationLogEntriesDocument, options);
        }
export function useAllPaymentVerificationLogEntriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables>(AllPaymentVerificationLogEntriesDocument, options);
        }
export type AllPaymentVerificationLogEntriesQueryHookResult = ReturnType<typeof useAllPaymentVerificationLogEntriesQuery>;
export type AllPaymentVerificationLogEntriesLazyQueryHookResult = ReturnType<typeof useAllPaymentVerificationLogEntriesLazyQuery>;
export type AllPaymentVerificationLogEntriesSuspenseQueryHookResult = ReturnType<typeof useAllPaymentVerificationLogEntriesSuspenseQuery>;
export type AllPaymentVerificationLogEntriesQueryResult = Apollo.QueryResult<AllPaymentVerificationLogEntriesQuery, AllPaymentVerificationLogEntriesQueryVariables>;
export const AllPaymentVerificationsDocument = gql`
    query AllPaymentVerifications($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $paymentVerificationPlan: ID, $search: String, $status: String, $businessArea: String!, $verificationChannel: String, $paymentPlanId: String) {
  allPaymentVerifications(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    paymentVerificationPlan: $paymentVerificationPlan
    search: $search
    status: $status
    businessArea: $businessArea
    verificationChannel: $verificationChannel
    paymentPlanId: $paymentPlanId
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        paymentVerificationPlan {
          id
          unicefId
          verificationChannel
        }
        payment {
          id
          unicefId
          deliveredQuantity
          currency
          household {
            status
            unicefId
            id
            headOfHousehold {
              id
              fullName
              familyName
              phoneNo
              phoneNoAlternative
            }
          }
        }
        status
        receivedAmount
      }
    }
  }
}
    `;

/**
 * __useAllPaymentVerificationsQuery__
 *
 * To run a query within a React component, call `useAllPaymentVerificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllPaymentVerificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllPaymentVerificationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      paymentVerificationPlan: // value for 'paymentVerificationPlan'
 *      search: // value for 'search'
 *      status: // value for 'status'
 *      businessArea: // value for 'businessArea'
 *      verificationChannel: // value for 'verificationChannel'
 *      paymentPlanId: // value for 'paymentPlanId'
 *   },
 * });
 */
export function useAllPaymentVerificationsQuery(baseOptions: Apollo.QueryHookOptions<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables> & ({ variables: AllPaymentVerificationsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables>(AllPaymentVerificationsDocument, options);
      }
export function useAllPaymentVerificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables>(AllPaymentVerificationsDocument, options);
        }
export function useAllPaymentVerificationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables>(AllPaymentVerificationsDocument, options);
        }
export type AllPaymentVerificationsQueryHookResult = ReturnType<typeof useAllPaymentVerificationsQuery>;
export type AllPaymentVerificationsLazyQueryHookResult = ReturnType<typeof useAllPaymentVerificationsLazyQuery>;
export type AllPaymentVerificationsSuspenseQueryHookResult = ReturnType<typeof useAllPaymentVerificationsSuspenseQuery>;
export type AllPaymentVerificationsQueryResult = Apollo.QueryResult<AllPaymentVerificationsQuery, AllPaymentVerificationsQueryVariables>;
export const AllRapidProFlowsDocument = gql`
    query AllRapidProFlows($businessAreaSlug: String!) {
  allRapidProFlows(businessAreaSlug: $businessAreaSlug) {
    id
    name
  }
}
    `;

/**
 * __useAllRapidProFlowsQuery__
 *
 * To run a query within a React component, call `useAllRapidProFlowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllRapidProFlowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllRapidProFlowsQuery({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useAllRapidProFlowsQuery(baseOptions: Apollo.QueryHookOptions<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables> & ({ variables: AllRapidProFlowsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables>(AllRapidProFlowsDocument, options);
      }
export function useAllRapidProFlowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables>(AllRapidProFlowsDocument, options);
        }
export function useAllRapidProFlowsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables>(AllRapidProFlowsDocument, options);
        }
export type AllRapidProFlowsQueryHookResult = ReturnType<typeof useAllRapidProFlowsQuery>;
export type AllRapidProFlowsLazyQueryHookResult = ReturnType<typeof useAllRapidProFlowsLazyQuery>;
export type AllRapidProFlowsSuspenseQueryHookResult = ReturnType<typeof useAllRapidProFlowsSuspenseQuery>;
export type AllRapidProFlowsQueryResult = Apollo.QueryResult<AllRapidProFlowsQuery, AllRapidProFlowsQueryVariables>;
export const PaymentVerificationPlanDocument = gql`
    query PaymentVerificationPlan($id: ID!) {
  paymentVerificationPlan(id: $id) {
    id
  }
}
    `;

/**
 * __usePaymentVerificationPlanQuery__
 *
 * To run a query within a React component, call `usePaymentVerificationPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentVerificationPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentVerificationPlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePaymentVerificationPlanQuery(baseOptions: Apollo.QueryHookOptions<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables> & ({ variables: PaymentVerificationPlanQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables>(PaymentVerificationPlanDocument, options);
      }
export function usePaymentVerificationPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables>(PaymentVerificationPlanDocument, options);
        }
export function usePaymentVerificationPlanSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables>(PaymentVerificationPlanDocument, options);
        }
export type PaymentVerificationPlanQueryHookResult = ReturnType<typeof usePaymentVerificationPlanQuery>;
export type PaymentVerificationPlanLazyQueryHookResult = ReturnType<typeof usePaymentVerificationPlanLazyQuery>;
export type PaymentVerificationPlanSuspenseQueryHookResult = ReturnType<typeof usePaymentVerificationPlanSuspenseQuery>;
export type PaymentVerificationPlanQueryResult = Apollo.QueryResult<PaymentVerificationPlanQuery, PaymentVerificationPlanQueryVariables>;
export const CashPlanVerificationStatusChoicesDocument = gql`
    query cashPlanVerificationStatusChoices {
  cashPlanVerificationStatusChoices {
    name
    value
  }
  paymentRecordDeliveryTypeChoices {
    name
    value
  }
}
    `;

/**
 * __useCashPlanVerificationStatusChoicesQuery__
 *
 * To run a query within a React component, call `useCashPlanVerificationStatusChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCashPlanVerificationStatusChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCashPlanVerificationStatusChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCashPlanVerificationStatusChoicesQuery(baseOptions?: Apollo.QueryHookOptions<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>(CashPlanVerificationStatusChoicesDocument, options);
      }
export function useCashPlanVerificationStatusChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>(CashPlanVerificationStatusChoicesDocument, options);
        }
export function useCashPlanVerificationStatusChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>(CashPlanVerificationStatusChoicesDocument, options);
        }
export type CashPlanVerificationStatusChoicesQueryHookResult = ReturnType<typeof useCashPlanVerificationStatusChoicesQuery>;
export type CashPlanVerificationStatusChoicesLazyQueryHookResult = ReturnType<typeof useCashPlanVerificationStatusChoicesLazyQuery>;
export type CashPlanVerificationStatusChoicesSuspenseQueryHookResult = ReturnType<typeof useCashPlanVerificationStatusChoicesSuspenseQuery>;
export type CashPlanVerificationStatusChoicesQueryResult = Apollo.QueryResult<CashPlanVerificationStatusChoicesQuery, CashPlanVerificationStatusChoicesQueryVariables>;
export const PaymentPlanStatusChoicesQueryDocument = gql`
    query PaymentPlanStatusChoicesQuery {
  paymentPlanStatusChoices {
    name
    value
  }
}
    `;

/**
 * __usePaymentPlanStatusChoicesQueryQuery__
 *
 * To run a query within a React component, call `usePaymentPlanStatusChoicesQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentPlanStatusChoicesQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentPlanStatusChoicesQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function usePaymentPlanStatusChoicesQueryQuery(baseOptions?: Apollo.QueryHookOptions<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>(PaymentPlanStatusChoicesQueryDocument, options);
      }
export function usePaymentPlanStatusChoicesQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>(PaymentPlanStatusChoicesQueryDocument, options);
        }
export function usePaymentPlanStatusChoicesQuerySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>(PaymentPlanStatusChoicesQueryDocument, options);
        }
export type PaymentPlanStatusChoicesQueryQueryHookResult = ReturnType<typeof usePaymentPlanStatusChoicesQueryQuery>;
export type PaymentPlanStatusChoicesQueryLazyQueryHookResult = ReturnType<typeof usePaymentPlanStatusChoicesQueryLazyQuery>;
export type PaymentPlanStatusChoicesQuerySuspenseQueryHookResult = ReturnType<typeof usePaymentPlanStatusChoicesQuerySuspenseQuery>;
export type PaymentPlanStatusChoicesQueryQueryResult = Apollo.QueryResult<PaymentPlanStatusChoicesQueryQuery, PaymentPlanStatusChoicesQueryQueryVariables>;
export const PaymentRecordVerificationDocument = gql`
    query PaymentRecordVerification($id: ID!) {
  paymentRecordVerification(id: $id) {
    id
    status
    statusDate
    receivedAmount
    isManuallyEditable
  }
}
    `;

/**
 * __usePaymentRecordVerificationQuery__
 *
 * To run a query within a React component, call `usePaymentRecordVerificationQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentRecordVerificationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentRecordVerificationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePaymentRecordVerificationQuery(baseOptions: Apollo.QueryHookOptions<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables> & ({ variables: PaymentRecordVerificationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables>(PaymentRecordVerificationDocument, options);
      }
export function usePaymentRecordVerificationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables>(PaymentRecordVerificationDocument, options);
        }
export function usePaymentRecordVerificationSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables>(PaymentRecordVerificationDocument, options);
        }
export type PaymentRecordVerificationQueryHookResult = ReturnType<typeof usePaymentRecordVerificationQuery>;
export type PaymentRecordVerificationLazyQueryHookResult = ReturnType<typeof usePaymentRecordVerificationLazyQuery>;
export type PaymentRecordVerificationSuspenseQueryHookResult = ReturnType<typeof usePaymentRecordVerificationSuspenseQuery>;
export type PaymentRecordVerificationQueryResult = Apollo.QueryResult<PaymentRecordVerificationQuery, PaymentRecordVerificationQueryVariables>;
export const PaymentVerificationChoicesDocument = gql`
    query paymentVerificationChoices {
  paymentVerificationStatusChoices {
    name
    value
  }
  cashPlanVerificationVerificationChannelChoices {
    name
    value
  }
  paymentRecordDeliveryTypeChoices {
    name
    value
  }
}
    `;

/**
 * __usePaymentVerificationChoicesQuery__
 *
 * To run a query within a React component, call `usePaymentVerificationChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentVerificationChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentVerificationChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function usePaymentVerificationChoicesQuery(baseOptions?: Apollo.QueryHookOptions<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>(PaymentVerificationChoicesDocument, options);
      }
export function usePaymentVerificationChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>(PaymentVerificationChoicesDocument, options);
        }
export function usePaymentVerificationChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>(PaymentVerificationChoicesDocument, options);
        }
export type PaymentVerificationChoicesQueryHookResult = ReturnType<typeof usePaymentVerificationChoicesQuery>;
export type PaymentVerificationChoicesLazyQueryHookResult = ReturnType<typeof usePaymentVerificationChoicesLazyQuery>;
export type PaymentVerificationChoicesSuspenseQueryHookResult = ReturnType<typeof usePaymentVerificationChoicesSuspenseQuery>;
export type PaymentVerificationChoicesQueryResult = Apollo.QueryResult<PaymentVerificationChoicesQuery, PaymentVerificationChoicesQueryVariables>;
export const SampleSizeDocument = gql`
    query SampleSize($input: GetCashplanVerificationSampleSizeInput!) {
  sampleSize(input: $input) {
    paymentRecordCount
    sampleSize
  }
}
    `;

/**
 * __useSampleSizeQuery__
 *
 * To run a query within a React component, call `useSampleSizeQuery` and pass it any options that fit your needs.
 * When your component renders, `useSampleSizeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSampleSizeQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSampleSizeQuery(baseOptions: Apollo.QueryHookOptions<SampleSizeQuery, SampleSizeQueryVariables> & ({ variables: SampleSizeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SampleSizeQuery, SampleSizeQueryVariables>(SampleSizeDocument, options);
      }
export function useSampleSizeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SampleSizeQuery, SampleSizeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SampleSizeQuery, SampleSizeQueryVariables>(SampleSizeDocument, options);
        }
export function useSampleSizeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SampleSizeQuery, SampleSizeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SampleSizeQuery, SampleSizeQueryVariables>(SampleSizeDocument, options);
        }
export type SampleSizeQueryHookResult = ReturnType<typeof useSampleSizeQuery>;
export type SampleSizeLazyQueryHookResult = ReturnType<typeof useSampleSizeLazyQuery>;
export type SampleSizeSuspenseQueryHookResult = ReturnType<typeof useSampleSizeSuspenseQuery>;
export type SampleSizeQueryResult = Apollo.QueryResult<SampleSizeQuery, SampleSizeQueryVariables>;
export const CashPlanVerificationSamplingChoicesDocument = gql`
    query cashPlanVerificationSamplingChoices {
  cashPlanVerificationSamplingChoices {
    name
    value
  }
}
    `;

/**
 * __useCashPlanVerificationSamplingChoicesQuery__
 *
 * To run a query within a React component, call `useCashPlanVerificationSamplingChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCashPlanVerificationSamplingChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCashPlanVerificationSamplingChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCashPlanVerificationSamplingChoicesQuery(baseOptions?: Apollo.QueryHookOptions<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>(CashPlanVerificationSamplingChoicesDocument, options);
      }
export function useCashPlanVerificationSamplingChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>(CashPlanVerificationSamplingChoicesDocument, options);
        }
export function useCashPlanVerificationSamplingChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>(CashPlanVerificationSamplingChoicesDocument, options);
        }
export type CashPlanVerificationSamplingChoicesQueryHookResult = ReturnType<typeof useCashPlanVerificationSamplingChoicesQuery>;
export type CashPlanVerificationSamplingChoicesLazyQueryHookResult = ReturnType<typeof useCashPlanVerificationSamplingChoicesLazyQuery>;
export type CashPlanVerificationSamplingChoicesSuspenseQueryHookResult = ReturnType<typeof useCashPlanVerificationSamplingChoicesSuspenseQuery>;
export type CashPlanVerificationSamplingChoicesQueryResult = Apollo.QueryResult<CashPlanVerificationSamplingChoicesQuery, CashPlanVerificationSamplingChoicesQueryVariables>;
export const AllHouseholdsDocument = gql`
    query AllHouseholds($after: String, $before: String, $first: Int, $last: Int, $businessArea: String, $orderBy: String, $familySize: String, $headOfHouseholdFullNameIcontains: String, $headOfHouseholdPhoneNoValid: Boolean, $adminArea: ID, $search: String, $searchType: String, $residenceStatus: String, $lastRegistrationDate: String, $admin2: ID, $withdrawn: Boolean, $program: ID) {
  allHouseholds(
    after: $after
    before: $before
    first: $first
    last: $last
    businessArea: $businessArea
    size: $familySize
    orderBy: $orderBy
    headOfHousehold_FullName_Startswith: $headOfHouseholdFullNameIcontains
    headOfHousehold_PhoneNoValid: $headOfHouseholdPhoneNoValid
    adminArea: $adminArea
    search: $search
    searchType: $searchType
    residenceStatus: $residenceStatus
    lastRegistrationDate: $lastRegistrationDate
    admin2: $admin2
    withdrawn: $withdrawn
    program: $program
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        status
        unicefId
        hasDuplicates
        sanctionListPossibleMatch
        sanctionListConfirmedMatch
        headOfHousehold {
          id
          fullName
          phoneNo
          birthDate
          phoneNo
          relationship
        }
        size
        address
        village
        maleChildrenCount
        femaleChildrenCount
        childrenDisabledCount
        admin1 {
          id
          name
        }
        admin2 {
          id
          name
        }
        residenceStatus
        totalCashReceived
        currency
        lastRegistrationDate
        programs {
          edges {
            node {
              id
              name
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useAllHouseholdsQuery__
 *
 * To run a query within a React component, call `useAllHouseholdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllHouseholdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllHouseholdsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      businessArea: // value for 'businessArea'
 *      orderBy: // value for 'orderBy'
 *      familySize: // value for 'familySize'
 *      headOfHouseholdFullNameIcontains: // value for 'headOfHouseholdFullNameIcontains'
 *      headOfHouseholdPhoneNoValid: // value for 'headOfHouseholdPhoneNoValid'
 *      adminArea: // value for 'adminArea'
 *      search: // value for 'search'
 *      searchType: // value for 'searchType'
 *      residenceStatus: // value for 'residenceStatus'
 *      lastRegistrationDate: // value for 'lastRegistrationDate'
 *      admin2: // value for 'admin2'
 *      withdrawn: // value for 'withdrawn'
 *      program: // value for 'program'
 *   },
 * });
 */
export function useAllHouseholdsQuery(baseOptions?: Apollo.QueryHookOptions<AllHouseholdsQuery, AllHouseholdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllHouseholdsQuery, AllHouseholdsQueryVariables>(AllHouseholdsDocument, options);
      }
export function useAllHouseholdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllHouseholdsQuery, AllHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllHouseholdsQuery, AllHouseholdsQueryVariables>(AllHouseholdsDocument, options);
        }
export function useAllHouseholdsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllHouseholdsQuery, AllHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllHouseholdsQuery, AllHouseholdsQueryVariables>(AllHouseholdsDocument, options);
        }
export type AllHouseholdsQueryHookResult = ReturnType<typeof useAllHouseholdsQuery>;
export type AllHouseholdsLazyQueryHookResult = ReturnType<typeof useAllHouseholdsLazyQuery>;
export type AllHouseholdsSuspenseQueryHookResult = ReturnType<typeof useAllHouseholdsSuspenseQuery>;
export type AllHouseholdsQueryResult = Apollo.QueryResult<AllHouseholdsQuery, AllHouseholdsQueryVariables>;
export const AllHouseholdsForPopulationTableDocument = gql`
    query AllHouseholdsForPopulationTable($after: String, $before: String, $first: Int, $last: Int, $businessArea: String, $orderBy: String, $familySize: String, $headOfHouseholdFullNameIcontains: String, $adminArea: ID, $search: String, $searchType: String, $residenceStatus: String, $lastRegistrationDate: String, $admin2: ID, $withdrawn: Boolean, $headOfHouseholdPhoneNoValid: Boolean, $program: ID, $isActiveProgram: Boolean) {
  allHouseholds(
    after: $after
    before: $before
    first: $first
    last: $last
    businessArea: $businessArea
    size: $familySize
    orderBy: $orderBy
    headOfHousehold_FullName_Startswith: $headOfHouseholdFullNameIcontains
    adminArea: $adminArea
    search: $search
    searchType: $searchType
    residenceStatus: $residenceStatus
    lastRegistrationDate: $lastRegistrationDate
    admin2: $admin2
    withdrawn: $withdrawn
    headOfHousehold_PhoneNoValid: $headOfHouseholdPhoneNoValid
    program: $program
    isActiveProgram: $isActiveProgram
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        id
        status
        unicefId
        hasDuplicates
        sanctionListPossibleMatch
        sanctionListConfirmedMatch
        headOfHousehold {
          id
          fullName
        }
        size
        admin2 {
          id
          name
        }
        residenceStatus
        totalCashReceived
        currency
        lastRegistrationDate
        programs {
          edges {
            node {
              id
              name
            }
          }
        }
        program {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useAllHouseholdsForPopulationTableQuery__
 *
 * To run a query within a React component, call `useAllHouseholdsForPopulationTableQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllHouseholdsForPopulationTableQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllHouseholdsForPopulationTableQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      businessArea: // value for 'businessArea'
 *      orderBy: // value for 'orderBy'
 *      familySize: // value for 'familySize'
 *      headOfHouseholdFullNameIcontains: // value for 'headOfHouseholdFullNameIcontains'
 *      adminArea: // value for 'adminArea'
 *      search: // value for 'search'
 *      searchType: // value for 'searchType'
 *      residenceStatus: // value for 'residenceStatus'
 *      lastRegistrationDate: // value for 'lastRegistrationDate'
 *      admin2: // value for 'admin2'
 *      withdrawn: // value for 'withdrawn'
 *      headOfHouseholdPhoneNoValid: // value for 'headOfHouseholdPhoneNoValid'
 *      program: // value for 'program'
 *      isActiveProgram: // value for 'isActiveProgram'
 *   },
 * });
 */
export function useAllHouseholdsForPopulationTableQuery(baseOptions?: Apollo.QueryHookOptions<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>(AllHouseholdsForPopulationTableDocument, options);
      }
export function useAllHouseholdsForPopulationTableLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>(AllHouseholdsForPopulationTableDocument, options);
        }
export function useAllHouseholdsForPopulationTableSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>(AllHouseholdsForPopulationTableDocument, options);
        }
export type AllHouseholdsForPopulationTableQueryHookResult = ReturnType<typeof useAllHouseholdsForPopulationTableQuery>;
export type AllHouseholdsForPopulationTableLazyQueryHookResult = ReturnType<typeof useAllHouseholdsForPopulationTableLazyQuery>;
export type AllHouseholdsForPopulationTableSuspenseQueryHookResult = ReturnType<typeof useAllHouseholdsForPopulationTableSuspenseQuery>;
export type AllHouseholdsForPopulationTableQueryResult = Apollo.QueryResult<AllHouseholdsForPopulationTableQuery, AllHouseholdsForPopulationTableQueryVariables>;
export const AllIndividualsDocument = gql`
    query AllIndividuals($before: String, $after: String, $first: Int, $last: Int, $fullNameContains: String, $sex: [String], $age: String, $orderBy: String, $search: String, $searchType: String, $programs: [ID], $status: [String], $lastRegistrationDate: String, $householdId: UUID, $excludedId: String, $businessArea: String, $adminArea: ID, $withdrawn: Boolean, $admin2: [ID], $flags: [String]) {
  allIndividuals(
    before: $before
    after: $after
    first: $first
    last: $last
    fullName_Startswith: $fullNameContains
    sex: $sex
    age: $age
    orderBy: $orderBy
    search: $search
    searchType: $searchType
    programs: $programs
    status: $status
    lastRegistrationDate: $lastRegistrationDate
    household_Id: $householdId
    excludedId: $excludedId
    businessArea: $businessArea
    household_AdminArea: $adminArea
    withdrawn: $withdrawn
    admin2: $admin2
    flags: $flags
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        unicefId
        sanctionListPossibleMatch
        sanctionListConfirmedMatch
        deduplicationGoldenRecordStatus
        sanctionListLastCheck
        fullName
        household {
          id
          unicefId
          admin2 {
            id
            name
          }
          programs {
            edges {
              node {
                id
                name
              }
            }
          }
        }
        relationship
        age
        sex
        lastRegistrationDate
        phoneNo
        birthDate
        documents {
          edges {
            node {
              id
              country
              countryIso3
              documentNumber
              photo
              type {
                label
                key
              }
            }
          }
        }
        identities {
          edges {
            node {
              id
              partner
              country
              countryIso3
              number
            }
          }
        }
        paymentChannels {
          id
          bankName
          bankAccountNumber
          accountHolderName
          bankBranchName
        }
      }
    }
  }
}
    `;

/**
 * __useAllIndividualsQuery__
 *
 * To run a query within a React component, call `useAllIndividualsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllIndividualsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllIndividualsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      fullNameContains: // value for 'fullNameContains'
 *      sex: // value for 'sex'
 *      age: // value for 'age'
 *      orderBy: // value for 'orderBy'
 *      search: // value for 'search'
 *      searchType: // value for 'searchType'
 *      programs: // value for 'programs'
 *      status: // value for 'status'
 *      lastRegistrationDate: // value for 'lastRegistrationDate'
 *      householdId: // value for 'householdId'
 *      excludedId: // value for 'excludedId'
 *      businessArea: // value for 'businessArea'
 *      adminArea: // value for 'adminArea'
 *      withdrawn: // value for 'withdrawn'
 *      admin2: // value for 'admin2'
 *      flags: // value for 'flags'
 *   },
 * });
 */
export function useAllIndividualsQuery(baseOptions?: Apollo.QueryHookOptions<AllIndividualsQuery, AllIndividualsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllIndividualsQuery, AllIndividualsQueryVariables>(AllIndividualsDocument, options);
      }
export function useAllIndividualsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllIndividualsQuery, AllIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllIndividualsQuery, AllIndividualsQueryVariables>(AllIndividualsDocument, options);
        }
export function useAllIndividualsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllIndividualsQuery, AllIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllIndividualsQuery, AllIndividualsQueryVariables>(AllIndividualsDocument, options);
        }
export type AllIndividualsQueryHookResult = ReturnType<typeof useAllIndividualsQuery>;
export type AllIndividualsLazyQueryHookResult = ReturnType<typeof useAllIndividualsLazyQuery>;
export type AllIndividualsSuspenseQueryHookResult = ReturnType<typeof useAllIndividualsSuspenseQuery>;
export type AllIndividualsQueryResult = Apollo.QueryResult<AllIndividualsQuery, AllIndividualsQueryVariables>;
export const AllIndividualsForPopulationTableDocument = gql`
    query AllIndividualsForPopulationTable($before: String, $after: String, $first: Int, $last: Int, $fullNameContains: String, $sex: [String], $age: String, $orderBy: String, $search: String, $searchType: String, $programs: [ID], $status: [String], $lastRegistrationDate: String, $householdId: UUID, $excludedId: String, $businessArea: String, $adminArea: ID, $withdrawn: Boolean, $admin2: [ID], $flags: [String], $program: ID, $isActiveProgram: Boolean) {
  allIndividuals(
    before: $before
    after: $after
    first: $first
    last: $last
    fullName_Startswith: $fullNameContains
    sex: $sex
    age: $age
    orderBy: $orderBy
    search: $search
    searchType: $searchType
    programs: $programs
    status: $status
    lastRegistrationDate: $lastRegistrationDate
    household_Id: $householdId
    excludedId: $excludedId
    businessArea: $businessArea
    household_AdminArea: $adminArea
    withdrawn: $withdrawn
    admin2: $admin2
    flags: $flags
    program: $program
    isActiveProgram: $isActiveProgram
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        unicefId
        sanctionListPossibleMatch
        sanctionListConfirmedMatch
        deduplicationGoldenRecordStatus
        status
        sanctionListLastCheck
        fullName
        household {
          id
          unicefId
          admin2 {
            id
            name
          }
        }
        relationship
        age
        sex
        lastRegistrationDate
        program {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useAllIndividualsForPopulationTableQuery__
 *
 * To run a query within a React component, call `useAllIndividualsForPopulationTableQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllIndividualsForPopulationTableQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllIndividualsForPopulationTableQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      fullNameContains: // value for 'fullNameContains'
 *      sex: // value for 'sex'
 *      age: // value for 'age'
 *      orderBy: // value for 'orderBy'
 *      search: // value for 'search'
 *      searchType: // value for 'searchType'
 *      programs: // value for 'programs'
 *      status: // value for 'status'
 *      lastRegistrationDate: // value for 'lastRegistrationDate'
 *      householdId: // value for 'householdId'
 *      excludedId: // value for 'excludedId'
 *      businessArea: // value for 'businessArea'
 *      adminArea: // value for 'adminArea'
 *      withdrawn: // value for 'withdrawn'
 *      admin2: // value for 'admin2'
 *      flags: // value for 'flags'
 *      program: // value for 'program'
 *      isActiveProgram: // value for 'isActiveProgram'
 *   },
 * });
 */
export function useAllIndividualsForPopulationTableQuery(baseOptions?: Apollo.QueryHookOptions<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>(AllIndividualsForPopulationTableDocument, options);
      }
export function useAllIndividualsForPopulationTableLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>(AllIndividualsForPopulationTableDocument, options);
        }
export function useAllIndividualsForPopulationTableSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>(AllIndividualsForPopulationTableDocument, options);
        }
export type AllIndividualsForPopulationTableQueryHookResult = ReturnType<typeof useAllIndividualsForPopulationTableQuery>;
export type AllIndividualsForPopulationTableLazyQueryHookResult = ReturnType<typeof useAllIndividualsForPopulationTableLazyQuery>;
export type AllIndividualsForPopulationTableSuspenseQueryHookResult = ReturnType<typeof useAllIndividualsForPopulationTableSuspenseQuery>;
export type AllIndividualsForPopulationTableQueryResult = Apollo.QueryResult<AllIndividualsForPopulationTableQuery, AllIndividualsForPopulationTableQueryVariables>;
export const HouseholdDocument = gql`
    query Household($id: ID!) {
  household(id: $id) {
    ...householdDetailed
  }
}
    ${HouseholdDetailedFragmentDoc}`;

/**
 * __useHouseholdQuery__
 *
 * To run a query within a React component, call `useHouseholdQuery` and pass it any options that fit your needs.
 * When your component renders, `useHouseholdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHouseholdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useHouseholdQuery(baseOptions: Apollo.QueryHookOptions<HouseholdQuery, HouseholdQueryVariables> & ({ variables: HouseholdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HouseholdQuery, HouseholdQueryVariables>(HouseholdDocument, options);
      }
export function useHouseholdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HouseholdQuery, HouseholdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HouseholdQuery, HouseholdQueryVariables>(HouseholdDocument, options);
        }
export function useHouseholdSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HouseholdQuery, HouseholdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HouseholdQuery, HouseholdQueryVariables>(HouseholdDocument, options);
        }
export type HouseholdQueryHookResult = ReturnType<typeof useHouseholdQuery>;
export type HouseholdLazyQueryHookResult = ReturnType<typeof useHouseholdLazyQuery>;
export type HouseholdSuspenseQueryHookResult = ReturnType<typeof useHouseholdSuspenseQuery>;
export type HouseholdQueryResult = Apollo.QueryResult<HouseholdQuery, HouseholdQueryVariables>;
export const HouseholdChoiceDataDocument = gql`
    query householdChoiceData {
  residenceStatusChoices {
    name
    value
  }
  relationshipChoices {
    name
    value
  }
  roleChoices {
    name
    value
  }
  maritalStatusChoices {
    name
    value
  }
  workStatusChoices {
    name
    value
  }
  deduplicationBatchStatusChoices {
    name
    value
  }
  deduplicationGoldenRecordStatusChoices {
    name
    value
  }
  observedDisabilityChoices {
    name
    value
  }
  severityOfDisabilityChoices {
    name
    value
  }
  householdSearchTypesChoices {
    name
    value
  }
}
    `;

/**
 * __useHouseholdChoiceDataQuery__
 *
 * To run a query within a React component, call `useHouseholdChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useHouseholdChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHouseholdChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useHouseholdChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>(HouseholdChoiceDataDocument, options);
      }
export function useHouseholdChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>(HouseholdChoiceDataDocument, options);
        }
export function useHouseholdChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>(HouseholdChoiceDataDocument, options);
        }
export type HouseholdChoiceDataQueryHookResult = ReturnType<typeof useHouseholdChoiceDataQuery>;
export type HouseholdChoiceDataLazyQueryHookResult = ReturnType<typeof useHouseholdChoiceDataLazyQuery>;
export type HouseholdChoiceDataSuspenseQueryHookResult = ReturnType<typeof useHouseholdChoiceDataSuspenseQuery>;
export type HouseholdChoiceDataQueryResult = Apollo.QueryResult<HouseholdChoiceDataQuery, HouseholdChoiceDataQueryVariables>;
export const HouseholdFlexFieldsDocument = gql`
    query HouseholdFlexFields($id: ID!) {
  household(id: $id) {
    id
    flexFields
  }
}
    `;

/**
 * __useHouseholdFlexFieldsQuery__
 *
 * To run a query within a React component, call `useHouseholdFlexFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useHouseholdFlexFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHouseholdFlexFieldsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useHouseholdFlexFieldsQuery(baseOptions: Apollo.QueryHookOptions<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables> & ({ variables: HouseholdFlexFieldsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables>(HouseholdFlexFieldsDocument, options);
      }
export function useHouseholdFlexFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables>(HouseholdFlexFieldsDocument, options);
        }
export function useHouseholdFlexFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables>(HouseholdFlexFieldsDocument, options);
        }
export type HouseholdFlexFieldsQueryHookResult = ReturnType<typeof useHouseholdFlexFieldsQuery>;
export type HouseholdFlexFieldsLazyQueryHookResult = ReturnType<typeof useHouseholdFlexFieldsLazyQuery>;
export type HouseholdFlexFieldsSuspenseQueryHookResult = ReturnType<typeof useHouseholdFlexFieldsSuspenseQuery>;
export type HouseholdFlexFieldsQueryResult = Apollo.QueryResult<HouseholdFlexFieldsQuery, HouseholdFlexFieldsQueryVariables>;
export const IndividualDocument = gql`
    query Individual($id: ID!) {
  individual(id: $id) {
    ...individualDetailed
  }
}
    ${IndividualDetailedFragmentDoc}`;

/**
 * __useIndividualQuery__
 *
 * To run a query within a React component, call `useIndividualQuery` and pass it any options that fit your needs.
 * When your component renders, `useIndividualQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIndividualQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useIndividualQuery(baseOptions: Apollo.QueryHookOptions<IndividualQuery, IndividualQueryVariables> & ({ variables: IndividualQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IndividualQuery, IndividualQueryVariables>(IndividualDocument, options);
      }
export function useIndividualLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IndividualQuery, IndividualQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IndividualQuery, IndividualQueryVariables>(IndividualDocument, options);
        }
export function useIndividualSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IndividualQuery, IndividualQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IndividualQuery, IndividualQueryVariables>(IndividualDocument, options);
        }
export type IndividualQueryHookResult = ReturnType<typeof useIndividualQuery>;
export type IndividualLazyQueryHookResult = ReturnType<typeof useIndividualLazyQuery>;
export type IndividualSuspenseQueryHookResult = ReturnType<typeof useIndividualSuspenseQuery>;
export type IndividualQueryResult = Apollo.QueryResult<IndividualQuery, IndividualQueryVariables>;
export const IndividualChoiceDataDocument = gql`
    query individualChoiceData {
  flagChoices {
    name
    value
  }
  individualSearchTypesChoices {
    name
    value
  }
}
    `;

/**
 * __useIndividualChoiceDataQuery__
 *
 * To run a query within a React component, call `useIndividualChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useIndividualChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIndividualChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useIndividualChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>(IndividualChoiceDataDocument, options);
      }
export function useIndividualChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>(IndividualChoiceDataDocument, options);
        }
export function useIndividualChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>(IndividualChoiceDataDocument, options);
        }
export type IndividualChoiceDataQueryHookResult = ReturnType<typeof useIndividualChoiceDataQuery>;
export type IndividualChoiceDataLazyQueryHookResult = ReturnType<typeof useIndividualChoiceDataLazyQuery>;
export type IndividualChoiceDataSuspenseQueryHookResult = ReturnType<typeof useIndividualChoiceDataSuspenseQuery>;
export type IndividualChoiceDataQueryResult = Apollo.QueryResult<IndividualChoiceDataQuery, IndividualChoiceDataQueryVariables>;
export const IndividualFlexFieldsDocument = gql`
    query IndividualFlexFields($id: ID!) {
  individual(id: $id) {
    id
    flexFields
  }
}
    `;

/**
 * __useIndividualFlexFieldsQuery__
 *
 * To run a query within a React component, call `useIndividualFlexFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useIndividualFlexFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIndividualFlexFieldsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useIndividualFlexFieldsQuery(baseOptions: Apollo.QueryHookOptions<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables> & ({ variables: IndividualFlexFieldsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables>(IndividualFlexFieldsDocument, options);
      }
export function useIndividualFlexFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables>(IndividualFlexFieldsDocument, options);
        }
export function useIndividualFlexFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables>(IndividualFlexFieldsDocument, options);
        }
export type IndividualFlexFieldsQueryHookResult = ReturnType<typeof useIndividualFlexFieldsQuery>;
export type IndividualFlexFieldsLazyQueryHookResult = ReturnType<typeof useIndividualFlexFieldsLazyQuery>;
export type IndividualFlexFieldsSuspenseQueryHookResult = ReturnType<typeof useIndividualFlexFieldsSuspenseQuery>;
export type IndividualFlexFieldsQueryResult = Apollo.QueryResult<IndividualFlexFieldsQuery, IndividualFlexFieldsQueryVariables>;
export const AllActiveProgramsDocument = gql`
    query AllActivePrograms($before: String, $after: String, $first: Int, $last: Int, $status: [String], $sector: [String], $businessArea: String!, $search: String, $budget: String, $startDate: Date, $endDate: Date, $orderBy: String, $numberOfHouseholdsWithTpInProgram: String, $dataCollectingType: String) {
  allActivePrograms(
    before: $before
    after: $after
    first: $first
    last: $last
    status: $status
    sector: $sector
    businessArea: $businessArea
    search: $search
    budget: $budget
    orderBy: $orderBy
    startDate: $startDate
    endDate: $endDate
    numberOfHouseholdsWithTpInProgram: $numberOfHouseholdsWithTpInProgram
    dataCollectingType: $dataCollectingType
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    totalCount
    edgeCount
    edges {
      cursor
      node {
        id
        name
        status
        startDate
        endDate
        sector
        totalNumberOfHouseholds
        totalNumberOfHouseholdsWithTpInProgram
        budget
      }
    }
  }
}
    `;

/**
 * __useAllActiveProgramsQuery__
 *
 * To run a query within a React component, call `useAllActiveProgramsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllActiveProgramsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllActiveProgramsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      status: // value for 'status'
 *      sector: // value for 'sector'
 *      businessArea: // value for 'businessArea'
 *      search: // value for 'search'
 *      budget: // value for 'budget'
 *      startDate: // value for 'startDate'
 *      endDate: // value for 'endDate'
 *      orderBy: // value for 'orderBy'
 *      numberOfHouseholdsWithTpInProgram: // value for 'numberOfHouseholdsWithTpInProgram'
 *      dataCollectingType: // value for 'dataCollectingType'
 *   },
 * });
 */
export function useAllActiveProgramsQuery(baseOptions: Apollo.QueryHookOptions<AllActiveProgramsQuery, AllActiveProgramsQueryVariables> & ({ variables: AllActiveProgramsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllActiveProgramsQuery, AllActiveProgramsQueryVariables>(AllActiveProgramsDocument, options);
      }
export function useAllActiveProgramsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllActiveProgramsQuery, AllActiveProgramsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllActiveProgramsQuery, AllActiveProgramsQueryVariables>(AllActiveProgramsDocument, options);
        }
export function useAllActiveProgramsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllActiveProgramsQuery, AllActiveProgramsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllActiveProgramsQuery, AllActiveProgramsQueryVariables>(AllActiveProgramsDocument, options);
        }
export type AllActiveProgramsQueryHookResult = ReturnType<typeof useAllActiveProgramsQuery>;
export type AllActiveProgramsLazyQueryHookResult = ReturnType<typeof useAllActiveProgramsLazyQuery>;
export type AllActiveProgramsSuspenseQueryHookResult = ReturnType<typeof useAllActiveProgramsSuspenseQuery>;
export type AllActiveProgramsQueryResult = Apollo.QueryResult<AllActiveProgramsQuery, AllActiveProgramsQueryVariables>;
export const AllProgramsDocument = gql`
    query AllPrograms($before: String, $after: String, $first: Int, $last: Int, $status: [String], $sector: [String], $businessArea: String!, $search: String, $numberOfHouseholds: String, $budget: String, $startDate: Date, $endDate: Date, $orderBy: String, $dataCollectingType: String) {
  allPrograms(
    before: $before
    after: $after
    first: $first
    last: $last
    status: $status
    sector: $sector
    businessArea: $businessArea
    search: $search
    numberOfHouseholds: $numberOfHouseholds
    budget: $budget
    orderBy: $orderBy
    startDate: $startDate
    endDate: $endDate
    dataCollectingType: $dataCollectingType
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    totalCount
    edgeCount
    edges {
      cursor
      node {
        id
        name
        startDate
        endDate
        status
        caId
        description
        budget
        frequencyOfPayments
        populationGoal
        sector
        totalNumberOfHouseholds
        totalNumberOfHouseholdsWithTpInProgram
      }
    }
  }
}
    `;

/**
 * __useAllProgramsQuery__
 *
 * To run a query within a React component, call `useAllProgramsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllProgramsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllProgramsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      status: // value for 'status'
 *      sector: // value for 'sector'
 *      businessArea: // value for 'businessArea'
 *      search: // value for 'search'
 *      numberOfHouseholds: // value for 'numberOfHouseholds'
 *      budget: // value for 'budget'
 *      startDate: // value for 'startDate'
 *      endDate: // value for 'endDate'
 *      orderBy: // value for 'orderBy'
 *      dataCollectingType: // value for 'dataCollectingType'
 *   },
 * });
 */
export function useAllProgramsQuery(baseOptions: Apollo.QueryHookOptions<AllProgramsQuery, AllProgramsQueryVariables> & ({ variables: AllProgramsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllProgramsQuery, AllProgramsQueryVariables>(AllProgramsDocument, options);
      }
export function useAllProgramsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllProgramsQuery, AllProgramsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllProgramsQuery, AllProgramsQueryVariables>(AllProgramsDocument, options);
        }
export function useAllProgramsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllProgramsQuery, AllProgramsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllProgramsQuery, AllProgramsQueryVariables>(AllProgramsDocument, options);
        }
export type AllProgramsQueryHookResult = ReturnType<typeof useAllProgramsQuery>;
export type AllProgramsLazyQueryHookResult = ReturnType<typeof useAllProgramsLazyQuery>;
export type AllProgramsSuspenseQueryHookResult = ReturnType<typeof useAllProgramsSuspenseQuery>;
export type AllProgramsQueryResult = Apollo.QueryResult<AllProgramsQuery, AllProgramsQueryVariables>;
export const AllProgramsForChoicesDocument = gql`
    query AllProgramsForChoices($before: String, $after: String, $first: Int, $last: Int, $status: [String], $sector: [String], $businessArea: String!, $search: String, $numberOfHouseholds: String, $budget: String, $startDate: Date, $endDate: Date, $orderBy: String) {
  allPrograms(
    before: $before
    after: $after
    first: $first
    last: $last
    status: $status
    sector: $sector
    businessArea: $businessArea
    search: $search
    numberOfHouseholds: $numberOfHouseholds
    budget: $budget
    orderBy: $orderBy
    startDate: $startDate
    endDate: $endDate
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    totalCount
    edgeCount
    edges {
      cursor
      node {
        id
        name
        status
        dataCollectingType {
          id
          code
          type
          label
          active
          individualFiltersAvailable
          householdFiltersAvailable
          description
        }
      }
    }
  }
}
    `;

/**
 * __useAllProgramsForChoicesQuery__
 *
 * To run a query within a React component, call `useAllProgramsForChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllProgramsForChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllProgramsForChoicesQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      status: // value for 'status'
 *      sector: // value for 'sector'
 *      businessArea: // value for 'businessArea'
 *      search: // value for 'search'
 *      numberOfHouseholds: // value for 'numberOfHouseholds'
 *      budget: // value for 'budget'
 *      startDate: // value for 'startDate'
 *      endDate: // value for 'endDate'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useAllProgramsForChoicesQuery(baseOptions: Apollo.QueryHookOptions<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables> & ({ variables: AllProgramsForChoicesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables>(AllProgramsForChoicesDocument, options);
      }
export function useAllProgramsForChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables>(AllProgramsForChoicesDocument, options);
        }
export function useAllProgramsForChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables>(AllProgramsForChoicesDocument, options);
        }
export type AllProgramsForChoicesQueryHookResult = ReturnType<typeof useAllProgramsForChoicesQuery>;
export type AllProgramsForChoicesLazyQueryHookResult = ReturnType<typeof useAllProgramsForChoicesLazyQuery>;
export type AllProgramsForChoicesSuspenseQueryHookResult = ReturnType<typeof useAllProgramsForChoicesSuspenseQuery>;
export type AllProgramsForChoicesQueryResult = Apollo.QueryResult<AllProgramsForChoicesQuery, AllProgramsForChoicesQueryVariables>;
export const ProgramDocument = gql`
    query Program($id: ID!) {
  program(id: $id) {
    id
    name
    programmeCode
    startDate
    endDate
    status
    caId
    caHashId
    description
    budget
    frequencyOfPayments
    cashPlus
    populationGoal
    scope
    sector
    totalNumberOfHouseholds
    totalNumberOfHouseholdsWithTpInProgram
    administrativeAreasOfImplementation
    isSocialWorkerProgram
    version
    adminUrl
    dataCollectingType {
      id
      code
      label
      active
      individualFiltersAvailable
      householdFiltersAvailable
      description
    }
    partners {
      id
      name
      areaAccess
      adminAreas {
        ids
        level
        totalCount
      }
    }
  }
}
    `;

/**
 * __useProgramQuery__
 *
 * To run a query within a React component, call `useProgramQuery` and pass it any options that fit your needs.
 * When your component renders, `useProgramQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProgramQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useProgramQuery(baseOptions: Apollo.QueryHookOptions<ProgramQuery, ProgramQueryVariables> & ({ variables: ProgramQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProgramQuery, ProgramQueryVariables>(ProgramDocument, options);
      }
export function useProgramLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProgramQuery, ProgramQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProgramQuery, ProgramQueryVariables>(ProgramDocument, options);
        }
export function useProgramSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProgramQuery, ProgramQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProgramQuery, ProgramQueryVariables>(ProgramDocument, options);
        }
export type ProgramQueryHookResult = ReturnType<typeof useProgramQuery>;
export type ProgramLazyQueryHookResult = ReturnType<typeof useProgramLazyQuery>;
export type ProgramSuspenseQueryHookResult = ReturnType<typeof useProgramSuspenseQuery>;
export type ProgramQueryResult = Apollo.QueryResult<ProgramQuery, ProgramQueryVariables>;
export const ProgrammeChoiceDataDocument = gql`
    query ProgrammeChoiceData {
  programFrequencyOfPaymentsChoices {
    name
    value
  }
  programScopeChoices {
    name
    value
  }
  programSectorChoices {
    name
    value
  }
  programStatusChoices {
    name
    value
  }
  dataCollectingTypeChoices {
    name
    value
  }
}
    `;

/**
 * __useProgrammeChoiceDataQuery__
 *
 * To run a query within a React component, call `useProgrammeChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useProgrammeChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProgrammeChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useProgrammeChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>(ProgrammeChoiceDataDocument, options);
      }
export function useProgrammeChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>(ProgrammeChoiceDataDocument, options);
        }
export function useProgrammeChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>(ProgrammeChoiceDataDocument, options);
        }
export type ProgrammeChoiceDataQueryHookResult = ReturnType<typeof useProgrammeChoiceDataQuery>;
export type ProgrammeChoiceDataLazyQueryHookResult = ReturnType<typeof useProgrammeChoiceDataLazyQuery>;
export type ProgrammeChoiceDataSuspenseQueryHookResult = ReturnType<typeof useProgrammeChoiceDataSuspenseQuery>;
export type ProgrammeChoiceDataQueryResult = Apollo.QueryResult<ProgrammeChoiceDataQuery, ProgrammeChoiceDataQueryVariables>;
export const UserPartnerChoicesDocument = gql`
    query UserPartnerChoices {
  userPartnerChoices {
    name
    value
  }
}
    `;

/**
 * __useUserPartnerChoicesQuery__
 *
 * To run a query within a React component, call `useUserPartnerChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserPartnerChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserPartnerChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserPartnerChoicesQuery(baseOptions?: Apollo.QueryHookOptions<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>(UserPartnerChoicesDocument, options);
      }
export function useUserPartnerChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>(UserPartnerChoicesDocument, options);
        }
export function useUserPartnerChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>(UserPartnerChoicesDocument, options);
        }
export type UserPartnerChoicesQueryHookResult = ReturnType<typeof useUserPartnerChoicesQuery>;
export type UserPartnerChoicesLazyQueryHookResult = ReturnType<typeof useUserPartnerChoicesLazyQuery>;
export type UserPartnerChoicesSuspenseQueryHookResult = ReturnType<typeof useUserPartnerChoicesSuspenseQuery>;
export type UserPartnerChoicesQueryResult = Apollo.QueryResult<UserPartnerChoicesQuery, UserPartnerChoicesQueryVariables>;
export const AllImportedHouseholdsDocument = gql`
    query AllImportedHouseholds($after: String, $before: String, $first: Int, $last: Int, $rdiId: String, $orderBy: String, $businessArea: String) {
  allImportedHouseholds(
    after: $after
    before: $before
    first: $first
    last: $last
    rdiId: $rdiId
    orderBy: $orderBy
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        ...importedHouseholdMinimal
      }
    }
  }
}
    ${ImportedHouseholdMinimalFragmentDoc}`;

/**
 * __useAllImportedHouseholdsQuery__
 *
 * To run a query within a React component, call `useAllImportedHouseholdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllImportedHouseholdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllImportedHouseholdsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      rdiId: // value for 'rdiId'
 *      orderBy: // value for 'orderBy'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllImportedHouseholdsQuery(baseOptions?: Apollo.QueryHookOptions<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>(AllImportedHouseholdsDocument, options);
      }
export function useAllImportedHouseholdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>(AllImportedHouseholdsDocument, options);
        }
export function useAllImportedHouseholdsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>(AllImportedHouseholdsDocument, options);
        }
export type AllImportedHouseholdsQueryHookResult = ReturnType<typeof useAllImportedHouseholdsQuery>;
export type AllImportedHouseholdsLazyQueryHookResult = ReturnType<typeof useAllImportedHouseholdsLazyQuery>;
export type AllImportedHouseholdsSuspenseQueryHookResult = ReturnType<typeof useAllImportedHouseholdsSuspenseQuery>;
export type AllImportedHouseholdsQueryResult = Apollo.QueryResult<AllImportedHouseholdsQuery, AllImportedHouseholdsQueryVariables>;
export const AllImportedIndividualsDocument = gql`
    query AllImportedIndividuals($after: String, $before: String, $first: Int, $last: Int, $rdiId: String, $household: ID, $orderBy: String, $duplicatesOnly: Boolean, $businessArea: String) {
  allImportedIndividuals(
    after: $after
    before: $before
    first: $first
    last: $last
    rdiId: $rdiId
    household: $household
    orderBy: $orderBy
    duplicatesOnly: $duplicatesOnly
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        ...importedIndividualMinimal
      }
    }
  }
}
    ${ImportedIndividualMinimalFragmentDoc}`;

/**
 * __useAllImportedIndividualsQuery__
 *
 * To run a query within a React component, call `useAllImportedIndividualsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllImportedIndividualsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllImportedIndividualsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      rdiId: // value for 'rdiId'
 *      household: // value for 'household'
 *      orderBy: // value for 'orderBy'
 *      duplicatesOnly: // value for 'duplicatesOnly'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllImportedIndividualsQuery(baseOptions?: Apollo.QueryHookOptions<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>(AllImportedIndividualsDocument, options);
      }
export function useAllImportedIndividualsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>(AllImportedIndividualsDocument, options);
        }
export function useAllImportedIndividualsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>(AllImportedIndividualsDocument, options);
        }
export type AllImportedIndividualsQueryHookResult = ReturnType<typeof useAllImportedIndividualsQuery>;
export type AllImportedIndividualsLazyQueryHookResult = ReturnType<typeof useAllImportedIndividualsLazyQuery>;
export type AllImportedIndividualsSuspenseQueryHookResult = ReturnType<typeof useAllImportedIndividualsSuspenseQuery>;
export type AllImportedIndividualsQueryResult = Apollo.QueryResult<AllImportedIndividualsQuery, AllImportedIndividualsQueryVariables>;
export const AllKoboProjectsDocument = gql`
    query AllKoboProjects($after: String, $before: String, $first: Int, $last: Int, $businessAreaSlug: String!) {
  allKoboProjects(
    after: $after
    before: $before
    first: $first
    last: $last
    businessAreaSlug: $businessAreaSlug
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        name
        id
      }
    }
  }
}
    `;

/**
 * __useAllKoboProjectsQuery__
 *
 * To run a query within a React component, call `useAllKoboProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllKoboProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllKoboProjectsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *   },
 * });
 */
export function useAllKoboProjectsQuery(baseOptions: Apollo.QueryHookOptions<AllKoboProjectsQuery, AllKoboProjectsQueryVariables> & ({ variables: AllKoboProjectsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllKoboProjectsQuery, AllKoboProjectsQueryVariables>(AllKoboProjectsDocument, options);
      }
export function useAllKoboProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllKoboProjectsQuery, AllKoboProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllKoboProjectsQuery, AllKoboProjectsQueryVariables>(AllKoboProjectsDocument, options);
        }
export function useAllKoboProjectsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllKoboProjectsQuery, AllKoboProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllKoboProjectsQuery, AllKoboProjectsQueryVariables>(AllKoboProjectsDocument, options);
        }
export type AllKoboProjectsQueryHookResult = ReturnType<typeof useAllKoboProjectsQuery>;
export type AllKoboProjectsLazyQueryHookResult = ReturnType<typeof useAllKoboProjectsLazyQuery>;
export type AllKoboProjectsSuspenseQueryHookResult = ReturnType<typeof useAllKoboProjectsSuspenseQuery>;
export type AllKoboProjectsQueryResult = Apollo.QueryResult<AllKoboProjectsQuery, AllKoboProjectsQueryVariables>;
export const AllMergedHouseholdsDocument = gql`
    query AllMergedHouseholds($after: String, $before: String, $first: Int, $last: Int, $rdiId: String, $orderBy: String, $businessArea: String) {
  allMergedHouseholds(
    after: $after
    before: $before
    first: $first
    last: $last
    rdiId: $rdiId
    orderBy: $orderBy
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        ...mergedHouseholdMinimal
      }
    }
  }
}
    ${MergedHouseholdMinimalFragmentDoc}`;

/**
 * __useAllMergedHouseholdsQuery__
 *
 * To run a query within a React component, call `useAllMergedHouseholdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllMergedHouseholdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllMergedHouseholdsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      rdiId: // value for 'rdiId'
 *      orderBy: // value for 'orderBy'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllMergedHouseholdsQuery(baseOptions?: Apollo.QueryHookOptions<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>(AllMergedHouseholdsDocument, options);
      }
export function useAllMergedHouseholdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>(AllMergedHouseholdsDocument, options);
        }
export function useAllMergedHouseholdsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>(AllMergedHouseholdsDocument, options);
        }
export type AllMergedHouseholdsQueryHookResult = ReturnType<typeof useAllMergedHouseholdsQuery>;
export type AllMergedHouseholdsLazyQueryHookResult = ReturnType<typeof useAllMergedHouseholdsLazyQuery>;
export type AllMergedHouseholdsSuspenseQueryHookResult = ReturnType<typeof useAllMergedHouseholdsSuspenseQuery>;
export type AllMergedHouseholdsQueryResult = Apollo.QueryResult<AllMergedHouseholdsQuery, AllMergedHouseholdsQueryVariables>;
export const AllMergedIndividualsDocument = gql`
    query AllMergedIndividuals($after: String, $before: String, $first: Int, $last: Int, $rdiId: String, $household: ID, $orderBy: String, $duplicatesOnly: Boolean, $businessArea: String) {
  allMergedIndividuals(
    after: $after
    before: $before
    first: $first
    last: $last
    rdiId: $rdiId
    household: $household
    orderBy: $orderBy
    duplicatesOnly: $duplicatesOnly
    businessArea: $businessArea
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        ...mergedIndividualMinimal
      }
    }
  }
}
    ${MergedIndividualMinimalFragmentDoc}`;

/**
 * __useAllMergedIndividualsQuery__
 *
 * To run a query within a React component, call `useAllMergedIndividualsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllMergedIndividualsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllMergedIndividualsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      rdiId: // value for 'rdiId'
 *      household: // value for 'household'
 *      orderBy: // value for 'orderBy'
 *      duplicatesOnly: // value for 'duplicatesOnly'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useAllMergedIndividualsQuery(baseOptions?: Apollo.QueryHookOptions<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>(AllMergedIndividualsDocument, options);
      }
export function useAllMergedIndividualsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>(AllMergedIndividualsDocument, options);
        }
export function useAllMergedIndividualsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>(AllMergedIndividualsDocument, options);
        }
export type AllMergedIndividualsQueryHookResult = ReturnType<typeof useAllMergedIndividualsQuery>;
export type AllMergedIndividualsLazyQueryHookResult = ReturnType<typeof useAllMergedIndividualsLazyQuery>;
export type AllMergedIndividualsSuspenseQueryHookResult = ReturnType<typeof useAllMergedIndividualsSuspenseQuery>;
export type AllMergedIndividualsQueryResult = Apollo.QueryResult<AllMergedIndividualsQuery, AllMergedIndividualsQueryVariables>;
export const AllRegistrationDataImportsDocument = gql`
    query AllRegistrationDataImports($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $search: String, $importedBy: UUID, $status: String, $importDate: Date, $businessArea: String, $importDateRange: String, $size: String, $program: String, $totalHouseholdsCountWithValidPhoneNoMin: Int, $totalHouseholdsCountWithValidPhoneNoMax: Int) {
  allRegistrationDataImports(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    name_Startswith: $search
    importedBy_Id: $importedBy
    status: $status
    importDate: $importDate
    businessArea: $businessArea
    importDateRange: $importDateRange
    size: $size
    program: $program
    totalHouseholdsCountWithValidPhoneNoMin: $totalHouseholdsCountWithValidPhoneNoMin
    totalHouseholdsCountWithValidPhoneNoMax: $totalHouseholdsCountWithValidPhoneNoMax
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      cursor
      node {
        ...registrationMinimal
      }
    }
  }
}
    ${RegistrationMinimalFragmentDoc}`;

/**
 * __useAllRegistrationDataImportsQuery__
 *
 * To run a query within a React component, call `useAllRegistrationDataImportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllRegistrationDataImportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllRegistrationDataImportsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      search: // value for 'search'
 *      importedBy: // value for 'importedBy'
 *      status: // value for 'status'
 *      importDate: // value for 'importDate'
 *      businessArea: // value for 'businessArea'
 *      importDateRange: // value for 'importDateRange'
 *      size: // value for 'size'
 *      program: // value for 'program'
 *      totalHouseholdsCountWithValidPhoneNoMin: // value for 'totalHouseholdsCountWithValidPhoneNoMin'
 *      totalHouseholdsCountWithValidPhoneNoMax: // value for 'totalHouseholdsCountWithValidPhoneNoMax'
 *   },
 * });
 */
export function useAllRegistrationDataImportsQuery(baseOptions?: Apollo.QueryHookOptions<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>(AllRegistrationDataImportsDocument, options);
      }
export function useAllRegistrationDataImportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>(AllRegistrationDataImportsDocument, options);
        }
export function useAllRegistrationDataImportsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>(AllRegistrationDataImportsDocument, options);
        }
export type AllRegistrationDataImportsQueryHookResult = ReturnType<typeof useAllRegistrationDataImportsQuery>;
export type AllRegistrationDataImportsLazyQueryHookResult = ReturnType<typeof useAllRegistrationDataImportsLazyQuery>;
export type AllRegistrationDataImportsSuspenseQueryHookResult = ReturnType<typeof useAllRegistrationDataImportsSuspenseQuery>;
export type AllRegistrationDataImportsQueryResult = Apollo.QueryResult<AllRegistrationDataImportsQuery, AllRegistrationDataImportsQueryVariables>;
export const ImportedHouseholdDocument = gql`
    query ImportedHousehold($id: ID!) {
  importedHousehold(id: $id) {
    ...importedHouseholdDetailed
  }
}
    ${ImportedHouseholdDetailedFragmentDoc}`;

/**
 * __useImportedHouseholdQuery__
 *
 * To run a query within a React component, call `useImportedHouseholdQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedHouseholdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedHouseholdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useImportedHouseholdQuery(baseOptions: Apollo.QueryHookOptions<ImportedHouseholdQuery, ImportedHouseholdQueryVariables> & ({ variables: ImportedHouseholdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedHouseholdQuery, ImportedHouseholdQueryVariables>(ImportedHouseholdDocument, options);
      }
export function useImportedHouseholdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedHouseholdQuery, ImportedHouseholdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedHouseholdQuery, ImportedHouseholdQueryVariables>(ImportedHouseholdDocument, options);
        }
export function useImportedHouseholdSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ImportedHouseholdQuery, ImportedHouseholdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ImportedHouseholdQuery, ImportedHouseholdQueryVariables>(ImportedHouseholdDocument, options);
        }
export type ImportedHouseholdQueryHookResult = ReturnType<typeof useImportedHouseholdQuery>;
export type ImportedHouseholdLazyQueryHookResult = ReturnType<typeof useImportedHouseholdLazyQuery>;
export type ImportedHouseholdSuspenseQueryHookResult = ReturnType<typeof useImportedHouseholdSuspenseQuery>;
export type ImportedHouseholdQueryResult = Apollo.QueryResult<ImportedHouseholdQuery, ImportedHouseholdQueryVariables>;
export const ImportedIndividualDocument = gql`
    query ImportedIndividual($id: ID!) {
  importedIndividual(id: $id) {
    ...importedIndividualDetailed
  }
}
    ${ImportedIndividualDetailedFragmentDoc}`;

/**
 * __useImportedIndividualQuery__
 *
 * To run a query within a React component, call `useImportedIndividualQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedIndividualQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedIndividualQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useImportedIndividualQuery(baseOptions: Apollo.QueryHookOptions<ImportedIndividualQuery, ImportedIndividualQueryVariables> & ({ variables: ImportedIndividualQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedIndividualQuery, ImportedIndividualQueryVariables>(ImportedIndividualDocument, options);
      }
export function useImportedIndividualLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedIndividualQuery, ImportedIndividualQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedIndividualQuery, ImportedIndividualQueryVariables>(ImportedIndividualDocument, options);
        }
export function useImportedIndividualSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ImportedIndividualQuery, ImportedIndividualQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ImportedIndividualQuery, ImportedIndividualQueryVariables>(ImportedIndividualDocument, options);
        }
export type ImportedIndividualQueryHookResult = ReturnType<typeof useImportedIndividualQuery>;
export type ImportedIndividualLazyQueryHookResult = ReturnType<typeof useImportedIndividualLazyQuery>;
export type ImportedIndividualSuspenseQueryHookResult = ReturnType<typeof useImportedIndividualSuspenseQuery>;
export type ImportedIndividualQueryResult = Apollo.QueryResult<ImportedIndividualQuery, ImportedIndividualQueryVariables>;
export const ImportedIndividualFlexFieldsDocument = gql`
    query ImportedIndividualFlexFields($id: ID!) {
  importedIndividual(id: $id) {
    id
    flexFields
  }
}
    `;

/**
 * __useImportedIndividualFlexFieldsQuery__
 *
 * To run a query within a React component, call `useImportedIndividualFlexFieldsQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedIndividualFlexFieldsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedIndividualFlexFieldsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useImportedIndividualFlexFieldsQuery(baseOptions: Apollo.QueryHookOptions<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables> & ({ variables: ImportedIndividualFlexFieldsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables>(ImportedIndividualFlexFieldsDocument, options);
      }
export function useImportedIndividualFlexFieldsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables>(ImportedIndividualFlexFieldsDocument, options);
        }
export function useImportedIndividualFlexFieldsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables>(ImportedIndividualFlexFieldsDocument, options);
        }
export type ImportedIndividualFlexFieldsQueryHookResult = ReturnType<typeof useImportedIndividualFlexFieldsQuery>;
export type ImportedIndividualFlexFieldsLazyQueryHookResult = ReturnType<typeof useImportedIndividualFlexFieldsLazyQuery>;
export type ImportedIndividualFlexFieldsSuspenseQueryHookResult = ReturnType<typeof useImportedIndividualFlexFieldsSuspenseQuery>;
export type ImportedIndividualFlexFieldsQueryResult = Apollo.QueryResult<ImportedIndividualFlexFieldsQuery, ImportedIndividualFlexFieldsQueryVariables>;
export const KoboImportDataDocument = gql`
    query KoboImportData($id: ID!) {
  koboImportData(id: $id) {
    id
    status
    numberOfIndividuals
    numberOfHouseholds
    error
    koboValidationErrors {
      header
      message
    }
  }
}
    `;

/**
 * __useKoboImportDataQuery__
 *
 * To run a query within a React component, call `useKoboImportDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useKoboImportDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useKoboImportDataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useKoboImportDataQuery(baseOptions: Apollo.QueryHookOptions<KoboImportDataQuery, KoboImportDataQueryVariables> & ({ variables: KoboImportDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<KoboImportDataQuery, KoboImportDataQueryVariables>(KoboImportDataDocument, options);
      }
export function useKoboImportDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<KoboImportDataQuery, KoboImportDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<KoboImportDataQuery, KoboImportDataQueryVariables>(KoboImportDataDocument, options);
        }
export function useKoboImportDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<KoboImportDataQuery, KoboImportDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<KoboImportDataQuery, KoboImportDataQueryVariables>(KoboImportDataDocument, options);
        }
export type KoboImportDataQueryHookResult = ReturnType<typeof useKoboImportDataQuery>;
export type KoboImportDataLazyQueryHookResult = ReturnType<typeof useKoboImportDataLazyQuery>;
export type KoboImportDataSuspenseQueryHookResult = ReturnType<typeof useKoboImportDataSuspenseQuery>;
export type KoboImportDataQueryResult = Apollo.QueryResult<KoboImportDataQuery, KoboImportDataQueryVariables>;
export const RegistrationChoicesDocument = gql`
    query registrationChoices {
  registrationDataStatusChoices {
    name
    value
  }
}
    `;

/**
 * __useRegistrationChoicesQuery__
 *
 * To run a query within a React component, call `useRegistrationChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrationChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrationChoicesQuery({
 *   variables: {
 *   },
 * });
 */
export function useRegistrationChoicesQuery(baseOptions?: Apollo.QueryHookOptions<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>(RegistrationChoicesDocument, options);
      }
export function useRegistrationChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>(RegistrationChoicesDocument, options);
        }
export function useRegistrationChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>(RegistrationChoicesDocument, options);
        }
export type RegistrationChoicesQueryHookResult = ReturnType<typeof useRegistrationChoicesQuery>;
export type RegistrationChoicesLazyQueryHookResult = ReturnType<typeof useRegistrationChoicesLazyQuery>;
export type RegistrationChoicesSuspenseQueryHookResult = ReturnType<typeof useRegistrationChoicesSuspenseQuery>;
export type RegistrationChoicesQueryResult = Apollo.QueryResult<RegistrationChoicesQuery, RegistrationChoicesQueryVariables>;
export const RegistrationDataImportDocument = gql`
    query RegistrationDataImport($id: ID!) {
  registrationDataImport(id: $id) {
    ...registrationDetailed
  }
}
    ${RegistrationDetailedFragmentDoc}`;

/**
 * __useRegistrationDataImportQuery__
 *
 * To run a query within a React component, call `useRegistrationDataImportQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrationDataImportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrationDataImportQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRegistrationDataImportQuery(baseOptions: Apollo.QueryHookOptions<RegistrationDataImportQuery, RegistrationDataImportQueryVariables> & ({ variables: RegistrationDataImportQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrationDataImportQuery, RegistrationDataImportQueryVariables>(RegistrationDataImportDocument, options);
      }
export function useRegistrationDataImportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrationDataImportQuery, RegistrationDataImportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrationDataImportQuery, RegistrationDataImportQueryVariables>(RegistrationDataImportDocument, options);
        }
export function useRegistrationDataImportSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RegistrationDataImportQuery, RegistrationDataImportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RegistrationDataImportQuery, RegistrationDataImportQueryVariables>(RegistrationDataImportDocument, options);
        }
export type RegistrationDataImportQueryHookResult = ReturnType<typeof useRegistrationDataImportQuery>;
export type RegistrationDataImportLazyQueryHookResult = ReturnType<typeof useRegistrationDataImportLazyQuery>;
export type RegistrationDataImportSuspenseQueryHookResult = ReturnType<typeof useRegistrationDataImportSuspenseQuery>;
export type RegistrationDataImportQueryResult = Apollo.QueryResult<RegistrationDataImportQuery, RegistrationDataImportQueryVariables>;
export const XlsxImportDataDocument = gql`
    query XlsxImportData($id: ID!) {
  importData(id: $id) {
    id
    status
    numberOfIndividuals
    numberOfHouseholds
    error
    xlsxValidationErrors {
      rowNumber
      header
      message
    }
  }
}
    `;

/**
 * __useXlsxImportDataQuery__
 *
 * To run a query within a React component, call `useXlsxImportDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useXlsxImportDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useXlsxImportDataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useXlsxImportDataQuery(baseOptions: Apollo.QueryHookOptions<XlsxImportDataQuery, XlsxImportDataQueryVariables> & ({ variables: XlsxImportDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<XlsxImportDataQuery, XlsxImportDataQueryVariables>(XlsxImportDataDocument, options);
      }
export function useXlsxImportDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<XlsxImportDataQuery, XlsxImportDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<XlsxImportDataQuery, XlsxImportDataQueryVariables>(XlsxImportDataDocument, options);
        }
export function useXlsxImportDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<XlsxImportDataQuery, XlsxImportDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<XlsxImportDataQuery, XlsxImportDataQueryVariables>(XlsxImportDataDocument, options);
        }
export type XlsxImportDataQueryHookResult = ReturnType<typeof useXlsxImportDataQuery>;
export type XlsxImportDataLazyQueryHookResult = ReturnType<typeof useXlsxImportDataLazyQuery>;
export type XlsxImportDataSuspenseQueryHookResult = ReturnType<typeof useXlsxImportDataSuspenseQuery>;
export type XlsxImportDataQueryResult = Apollo.QueryResult<XlsxImportDataQuery, XlsxImportDataQueryVariables>;
export const AllReportsDocument = gql`
    query AllReports($before: String, $after: String, $first: Int, $last: Int, $status: [String], $businessArea: String!, $createdFrom: DateTime, $createdTo: DateTime, $reportType: [String], $createdBy: ID, $orderBy: String) {
  allReports(
    before: $before
    after: $after
    first: $first
    last: $last
    status: $status
    businessArea: $businessArea
    createdFrom: $createdFrom
    createdTo: $createdTo
    reportType: $reportType
    createdBy: $createdBy
    orderBy: $orderBy
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    totalCount
    edgeCount
    edges {
      cursor
      node {
        id
        reportType
        dateFrom
        dateTo
        status
        createdAt
        updatedAt
        createdBy {
          firstName
          lastName
        }
        fileUrl
        numberOfRecords
      }
    }
  }
}
    `;

/**
 * __useAllReportsQuery__
 *
 * To run a query within a React component, call `useAllReportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllReportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllReportsQuery({
 *   variables: {
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      status: // value for 'status'
 *      businessArea: // value for 'businessArea'
 *      createdFrom: // value for 'createdFrom'
 *      createdTo: // value for 'createdTo'
 *      reportType: // value for 'reportType'
 *      createdBy: // value for 'createdBy'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useAllReportsQuery(baseOptions: Apollo.QueryHookOptions<AllReportsQuery, AllReportsQueryVariables> & ({ variables: AllReportsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllReportsQuery, AllReportsQueryVariables>(AllReportsDocument, options);
      }
export function useAllReportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllReportsQuery, AllReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllReportsQuery, AllReportsQueryVariables>(AllReportsDocument, options);
        }
export function useAllReportsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllReportsQuery, AllReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllReportsQuery, AllReportsQueryVariables>(AllReportsDocument, options);
        }
export type AllReportsQueryHookResult = ReturnType<typeof useAllReportsQuery>;
export type AllReportsLazyQueryHookResult = ReturnType<typeof useAllReportsLazyQuery>;
export type AllReportsSuspenseQueryHookResult = ReturnType<typeof useAllReportsSuspenseQuery>;
export type AllReportsQueryResult = Apollo.QueryResult<AllReportsQuery, AllReportsQueryVariables>;
export const ReportDocument = gql`
    query Report($id: ID!) {
  report(id: $id) {
    id
    status
    reportType
    createdAt
    updatedAt
    dateFrom
    dateTo
    fileUrl
    numberOfRecords
    createdBy {
      firstName
      lastName
    }
    adminArea2 {
      edges {
        node {
          name
        }
      }
    }
    adminArea1 {
      edges {
        node {
          name
        }
      }
    }
    program {
      name
    }
  }
}
    `;

/**
 * __useReportQuery__
 *
 * To run a query within a React component, call `useReportQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useReportQuery(baseOptions: Apollo.QueryHookOptions<ReportQuery, ReportQueryVariables> & ({ variables: ReportQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportQuery, ReportQueryVariables>(ReportDocument, options);
      }
export function useReportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportQuery, ReportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportQuery, ReportQueryVariables>(ReportDocument, options);
        }
export function useReportSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ReportQuery, ReportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ReportQuery, ReportQueryVariables>(ReportDocument, options);
        }
export type ReportQueryHookResult = ReturnType<typeof useReportQuery>;
export type ReportLazyQueryHookResult = ReturnType<typeof useReportLazyQuery>;
export type ReportSuspenseQueryHookResult = ReturnType<typeof useReportSuspenseQuery>;
export type ReportQueryResult = Apollo.QueryResult<ReportQuery, ReportQueryVariables>;
export const ReportChoiceDataDocument = gql`
    query ReportChoiceData {
  reportStatusChoices {
    name
    value
  }
  reportTypesChoices {
    name
    value
  }
}
    `;

/**
 * __useReportChoiceDataQuery__
 *
 * To run a query within a React component, call `useReportChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useReportChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>(ReportChoiceDataDocument, options);
      }
export function useReportChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>(ReportChoiceDataDocument, options);
        }
export function useReportChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>(ReportChoiceDataDocument, options);
        }
export type ReportChoiceDataQueryHookResult = ReturnType<typeof useReportChoiceDataQuery>;
export type ReportChoiceDataLazyQueryHookResult = ReturnType<typeof useReportChoiceDataLazyQuery>;
export type ReportChoiceDataSuspenseQueryHookResult = ReturnType<typeof useReportChoiceDataSuspenseQuery>;
export type ReportChoiceDataQueryResult = Apollo.QueryResult<ReportChoiceDataQuery, ReportChoiceDataQueryVariables>;
export const AllChartsDocument = gql`
    query AllCharts($businessAreaSlug: String!, $year: Int!, $program: String, $administrativeArea: String) {
  chartProgrammesBySector(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    labels
    datasets {
      label
      data
    }
  }
  chartPaymentVerification(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    datasets {
      label
      data
    }
    labels
    households
    averageSampleSize
  }
  chartVolumeByDeliveryMechanism(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    datasets {
      data
    }
    labels
  }
  chartPayment(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    datasets {
      data
    }
    labels
  }
  chartGrievances(
    businessAreaSlug: $businessAreaSlug
    year: $year
    administrativeArea: $administrativeArea
  ) {
    datasets {
      data
    }
    labels
    totalNumberOfGrievances
    totalNumberOfFeedback
    totalNumberOfOpenSensitive
  }
  sectionHouseholdsReached(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    total
  }
  sectionIndividualsReached(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    total
  }
  sectionChildReached(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    total
  }
  chartIndividualsReachedByAgeAndGender(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    datasets {
      data
    }
    labels
  }
  chartIndividualsWithDisabilityReachedByAge(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    datasets {
      data
      label
    }
    labels
  }
  sectionTotalTransferred(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    total
  }
  chartTotalTransferredByMonth(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
  ) {
    datasets {
      data
      label
    }
    labels
  }
}
    `;

/**
 * __useAllChartsQuery__
 *
 * To run a query within a React component, call `useAllChartsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllChartsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllChartsQuery({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *      year: // value for 'year'
 *      program: // value for 'program'
 *      administrativeArea: // value for 'administrativeArea'
 *   },
 * });
 */
export function useAllChartsQuery(baseOptions: Apollo.QueryHookOptions<AllChartsQuery, AllChartsQueryVariables> & ({ variables: AllChartsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllChartsQuery, AllChartsQueryVariables>(AllChartsDocument, options);
      }
export function useAllChartsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllChartsQuery, AllChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllChartsQuery, AllChartsQueryVariables>(AllChartsDocument, options);
        }
export function useAllChartsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllChartsQuery, AllChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllChartsQuery, AllChartsQueryVariables>(AllChartsDocument, options);
        }
export type AllChartsQueryHookResult = ReturnType<typeof useAllChartsQuery>;
export type AllChartsLazyQueryHookResult = ReturnType<typeof useAllChartsLazyQuery>;
export type AllChartsSuspenseQueryHookResult = ReturnType<typeof useAllChartsSuspenseQuery>;
export type AllChartsQueryResult = Apollo.QueryResult<AllChartsQuery, AllChartsQueryVariables>;
export const CountryChartsDocument = gql`
    query CountryCharts($businessAreaSlug: String!, $year: Int!, $program: String, $administrativeArea: String, $order: String, $orderBy: String) {
  tableTotalCashTransferredByAdministrativeArea(
    businessAreaSlug: $businessAreaSlug
    year: $year
    program: $program
    administrativeArea: $administrativeArea
    order: $order
    orderBy: $orderBy
  ) {
    data {
      id
      admin2
      totalCashTransferred
      totalHouseholds
    }
  }
}
    `;

/**
 * __useCountryChartsQuery__
 *
 * To run a query within a React component, call `useCountryChartsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCountryChartsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCountryChartsQuery({
 *   variables: {
 *      businessAreaSlug: // value for 'businessAreaSlug'
 *      year: // value for 'year'
 *      program: // value for 'program'
 *      administrativeArea: // value for 'administrativeArea'
 *      order: // value for 'order'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useCountryChartsQuery(baseOptions: Apollo.QueryHookOptions<CountryChartsQuery, CountryChartsQueryVariables> & ({ variables: CountryChartsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CountryChartsQuery, CountryChartsQueryVariables>(CountryChartsDocument, options);
      }
export function useCountryChartsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CountryChartsQuery, CountryChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CountryChartsQuery, CountryChartsQueryVariables>(CountryChartsDocument, options);
        }
export function useCountryChartsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CountryChartsQuery, CountryChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CountryChartsQuery, CountryChartsQueryVariables>(CountryChartsDocument, options);
        }
export type CountryChartsQueryHookResult = ReturnType<typeof useCountryChartsQuery>;
export type CountryChartsLazyQueryHookResult = ReturnType<typeof useCountryChartsLazyQuery>;
export type CountryChartsSuspenseQueryHookResult = ReturnType<typeof useCountryChartsSuspenseQuery>;
export type CountryChartsQueryResult = Apollo.QueryResult<CountryChartsQuery, CountryChartsQueryVariables>;
export const DashboardReportChoiceDataDocument = gql`
    query DashboardReportChoiceData($businessArea: String!) {
  dashboardReportTypesChoices(businessAreaSlug: $businessArea) {
    name
    value
  }
}
    `;

/**
 * __useDashboardReportChoiceDataQuery__
 *
 * To run a query within a React component, call `useDashboardReportChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useDashboardReportChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDashboardReportChoiceDataQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useDashboardReportChoiceDataQuery(baseOptions: Apollo.QueryHookOptions<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables> & ({ variables: DashboardReportChoiceDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables>(DashboardReportChoiceDataDocument, options);
      }
export function useDashboardReportChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables>(DashboardReportChoiceDataDocument, options);
        }
export function useDashboardReportChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables>(DashboardReportChoiceDataDocument, options);
        }
export type DashboardReportChoiceDataQueryHookResult = ReturnType<typeof useDashboardReportChoiceDataQuery>;
export type DashboardReportChoiceDataLazyQueryHookResult = ReturnType<typeof useDashboardReportChoiceDataLazyQuery>;
export type DashboardReportChoiceDataSuspenseQueryHookResult = ReturnType<typeof useDashboardReportChoiceDataSuspenseQuery>;
export type DashboardReportChoiceDataQueryResult = Apollo.QueryResult<DashboardReportChoiceDataQuery, DashboardReportChoiceDataQueryVariables>;
export const DashboardYearsChoiceDataDocument = gql`
    query DashboardYearsChoiceData($businessArea: String!) {
  dashboardYearsChoices(businessAreaSlug: $businessArea)
}
    `;

/**
 * __useDashboardYearsChoiceDataQuery__
 *
 * To run a query within a React component, call `useDashboardYearsChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useDashboardYearsChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDashboardYearsChoiceDataQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useDashboardYearsChoiceDataQuery(baseOptions: Apollo.QueryHookOptions<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables> & ({ variables: DashboardYearsChoiceDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables>(DashboardYearsChoiceDataDocument, options);
      }
export function useDashboardYearsChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables>(DashboardYearsChoiceDataDocument, options);
        }
export function useDashboardYearsChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables>(DashboardYearsChoiceDataDocument, options);
        }
export type DashboardYearsChoiceDataQueryHookResult = ReturnType<typeof useDashboardYearsChoiceDataQuery>;
export type DashboardYearsChoiceDataLazyQueryHookResult = ReturnType<typeof useDashboardYearsChoiceDataLazyQuery>;
export type DashboardYearsChoiceDataSuspenseQueryHookResult = ReturnType<typeof useDashboardYearsChoiceDataSuspenseQuery>;
export type DashboardYearsChoiceDataQueryResult = Apollo.QueryResult<DashboardYearsChoiceDataQuery, DashboardYearsChoiceDataQueryVariables>;
export const GlobalAreaChartsDocument = gql`
    query GlobalAreaCharts($year: Int!) {
  chartTotalTransferredCashByCountry(year: $year) {
    datasets {
      data
      label
    }
    labels
  }
}
    `;

/**
 * __useGlobalAreaChartsQuery__
 *
 * To run a query within a React component, call `useGlobalAreaChartsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGlobalAreaChartsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGlobalAreaChartsQuery({
 *   variables: {
 *      year: // value for 'year'
 *   },
 * });
 */
export function useGlobalAreaChartsQuery(baseOptions: Apollo.QueryHookOptions<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables> & ({ variables: GlobalAreaChartsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables>(GlobalAreaChartsDocument, options);
      }
export function useGlobalAreaChartsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables>(GlobalAreaChartsDocument, options);
        }
export function useGlobalAreaChartsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables>(GlobalAreaChartsDocument, options);
        }
export type GlobalAreaChartsQueryHookResult = ReturnType<typeof useGlobalAreaChartsQuery>;
export type GlobalAreaChartsLazyQueryHookResult = ReturnType<typeof useGlobalAreaChartsLazyQuery>;
export type GlobalAreaChartsSuspenseQueryHookResult = ReturnType<typeof useGlobalAreaChartsSuspenseQuery>;
export type GlobalAreaChartsQueryResult = Apollo.QueryResult<GlobalAreaChartsQuery, GlobalAreaChartsQueryVariables>;
export const LanguageAutocompleteDocument = gql`
    query LanguageAutocomplete($first: Int, $code: String) {
  allLanguages(first: $first, code: $code) {
    edges {
      cursor
      node {
        english
        code
      }
    }
  }
}
    `;

/**
 * __useLanguageAutocompleteQuery__
 *
 * To run a query within a React component, call `useLanguageAutocompleteQuery` and pass it any options that fit your needs.
 * When your component renders, `useLanguageAutocompleteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLanguageAutocompleteQuery({
 *   variables: {
 *      first: // value for 'first'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useLanguageAutocompleteQuery(baseOptions?: Apollo.QueryHookOptions<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>(LanguageAutocompleteDocument, options);
      }
export function useLanguageAutocompleteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>(LanguageAutocompleteDocument, options);
        }
export function useLanguageAutocompleteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>(LanguageAutocompleteDocument, options);
        }
export type LanguageAutocompleteQueryHookResult = ReturnType<typeof useLanguageAutocompleteQuery>;
export type LanguageAutocompleteLazyQueryHookResult = ReturnType<typeof useLanguageAutocompleteLazyQuery>;
export type LanguageAutocompleteSuspenseQueryHookResult = ReturnType<typeof useLanguageAutocompleteSuspenseQuery>;
export type LanguageAutocompleteQueryResult = Apollo.QueryResult<LanguageAutocompleteQuery, LanguageAutocompleteQueryVariables>;
export const RdiAutocompleteDocument = gql`
    query RdiAutocomplete($businessArea: String, $first: Int, $orderBy: String, $name: String) {
  allRegistrationDataImports(
    businessArea: $businessArea
    first: $first
    orderBy: $orderBy
    name_Startswith: $name
  ) {
    edges {
      cursor
      node {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useRdiAutocompleteQuery__
 *
 * To run a query within a React component, call `useRdiAutocompleteQuery` and pass it any options that fit your needs.
 * When your component renders, `useRdiAutocompleteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRdiAutocompleteQuery({
 *   variables: {
 *      businessArea: // value for 'businessArea'
 *      first: // value for 'first'
 *      orderBy: // value for 'orderBy'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useRdiAutocompleteQuery(baseOptions?: Apollo.QueryHookOptions<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>(RdiAutocompleteDocument, options);
      }
export function useRdiAutocompleteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>(RdiAutocompleteDocument, options);
        }
export function useRdiAutocompleteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>(RdiAutocompleteDocument, options);
        }
export type RdiAutocompleteQueryHookResult = ReturnType<typeof useRdiAutocompleteQuery>;
export type RdiAutocompleteLazyQueryHookResult = ReturnType<typeof useRdiAutocompleteLazyQuery>;
export type RdiAutocompleteSuspenseQueryHookResult = ReturnType<typeof useRdiAutocompleteSuspenseQuery>;
export type RdiAutocompleteQueryResult = Apollo.QueryResult<RdiAutocompleteQuery, RdiAutocompleteQueryVariables>;
export const AllSurveysDocument = gql`
    query AllSurveys($offset: Int, $before: String, $after: String, $first: Int, $last: Int, $program: ID!, $targetPopulation: ID, $createdAtRange: String, $createdBy: String, $search: String, $orderBy: String) {
  allSurveys(
    offset: $offset
    before: $before
    after: $after
    first: $first
    last: $last
    program: $program
    targetPopulation: $targetPopulation
    createdAtRange: $createdAtRange
    createdBy: $createdBy
    search: $search
    orderBy: $orderBy
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        unicefId
        title
        category
        numberOfRecipients
        createdBy {
          id
          firstName
          lastName
          email
        }
        createdAt
      }
    }
  }
}
    `;

/**
 * __useAllSurveysQuery__
 *
 * To run a query within a React component, call `useAllSurveysQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllSurveysQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllSurveysQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      program: // value for 'program'
 *      targetPopulation: // value for 'targetPopulation'
 *      createdAtRange: // value for 'createdAtRange'
 *      createdBy: // value for 'createdBy'
 *      search: // value for 'search'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useAllSurveysQuery(baseOptions: Apollo.QueryHookOptions<AllSurveysQuery, AllSurveysQueryVariables> & ({ variables: AllSurveysQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllSurveysQuery, AllSurveysQueryVariables>(AllSurveysDocument, options);
      }
export function useAllSurveysLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllSurveysQuery, AllSurveysQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllSurveysQuery, AllSurveysQueryVariables>(AllSurveysDocument, options);
        }
export function useAllSurveysSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllSurveysQuery, AllSurveysQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllSurveysQuery, AllSurveysQueryVariables>(AllSurveysDocument, options);
        }
export type AllSurveysQueryHookResult = ReturnType<typeof useAllSurveysQuery>;
export type AllSurveysLazyQueryHookResult = ReturnType<typeof useAllSurveysLazyQuery>;
export type AllSurveysSuspenseQueryHookResult = ReturnType<typeof useAllSurveysSuspenseQuery>;
export type AllSurveysQueryResult = Apollo.QueryResult<AllSurveysQuery, AllSurveysQueryVariables>;
export const SurveyAvailableFlowsDocument = gql`
    query SurveyAvailableFlows {
  surveyAvailableFlows {
    id
    name
  }
}
    `;

/**
 * __useSurveyAvailableFlowsQuery__
 *
 * To run a query within a React component, call `useSurveyAvailableFlowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSurveyAvailableFlowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSurveyAvailableFlowsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSurveyAvailableFlowsQuery(baseOptions?: Apollo.QueryHookOptions<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>(SurveyAvailableFlowsDocument, options);
      }
export function useSurveyAvailableFlowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>(SurveyAvailableFlowsDocument, options);
        }
export function useSurveyAvailableFlowsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>(SurveyAvailableFlowsDocument, options);
        }
export type SurveyAvailableFlowsQueryHookResult = ReturnType<typeof useSurveyAvailableFlowsQuery>;
export type SurveyAvailableFlowsLazyQueryHookResult = ReturnType<typeof useSurveyAvailableFlowsLazyQuery>;
export type SurveyAvailableFlowsSuspenseQueryHookResult = ReturnType<typeof useSurveyAvailableFlowsSuspenseQuery>;
export type SurveyAvailableFlowsQueryResult = Apollo.QueryResult<SurveyAvailableFlowsQuery, SurveyAvailableFlowsQueryVariables>;
export const RecipientsDocument = gql`
    query Recipients($offset: Int, $before: String, $after: String, $first: Int, $last: Int, $survey: String!, $orderBy: String) {
  recipients(
    offset: $offset
    before: $before
    after: $after
    first: $first
    last: $last
    survey: $survey
    orderBy: $orderBy
  ) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edgeCount
    edges {
      cursor
      node {
        id
        headOfHousehold {
          id
          fullName
          household {
            id
            unicefId
            size
            status
            admin2 {
              id
              name
            }
            residenceStatus
            lastRegistrationDate
          }
        }
      }
    }
  }
}
    `;

/**
 * __useRecipientsQuery__
 *
 * To run a query within a React component, call `useRecipientsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRecipientsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRecipientsQuery({
 *   variables: {
 *      offset: // value for 'offset'
 *      before: // value for 'before'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      survey: // value for 'survey'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useRecipientsQuery(baseOptions: Apollo.QueryHookOptions<RecipientsQuery, RecipientsQueryVariables> & ({ variables: RecipientsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RecipientsQuery, RecipientsQueryVariables>(RecipientsDocument, options);
      }
export function useRecipientsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RecipientsQuery, RecipientsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RecipientsQuery, RecipientsQueryVariables>(RecipientsDocument, options);
        }
export function useRecipientsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RecipientsQuery, RecipientsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RecipientsQuery, RecipientsQueryVariables>(RecipientsDocument, options);
        }
export type RecipientsQueryHookResult = ReturnType<typeof useRecipientsQuery>;
export type RecipientsLazyQueryHookResult = ReturnType<typeof useRecipientsLazyQuery>;
export type RecipientsSuspenseQueryHookResult = ReturnType<typeof useRecipientsSuspenseQuery>;
export type RecipientsQueryResult = Apollo.QueryResult<RecipientsQuery, RecipientsQueryVariables>;
export const SurveyDocument = gql`
    query Survey($id: ID!) {
  survey(id: $id) {
    id
    unicefId
    category
    title
    adminUrl
    createdBy {
      id
      firstName
      lastName
      username
      email
    }
    createdAt
    targetPopulation {
      id
      name
    }
    program {
      id
      name
    }
    body
    title
    rapidProUrl
    sampleFilePath
    hasValidSampleFile
  }
}
    `;

/**
 * __useSurveyQuery__
 *
 * To run a query within a React component, call `useSurveyQuery` and pass it any options that fit your needs.
 * When your component renders, `useSurveyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSurveyQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSurveyQuery(baseOptions: Apollo.QueryHookOptions<SurveyQuery, SurveyQueryVariables> & ({ variables: SurveyQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SurveyQuery, SurveyQueryVariables>(SurveyDocument, options);
      }
export function useSurveyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SurveyQuery, SurveyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SurveyQuery, SurveyQueryVariables>(SurveyDocument, options);
        }
export function useSurveySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SurveyQuery, SurveyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SurveyQuery, SurveyQueryVariables>(SurveyDocument, options);
        }
export type SurveyQueryHookResult = ReturnType<typeof useSurveyQuery>;
export type SurveyLazyQueryHookResult = ReturnType<typeof useSurveyLazyQuery>;
export type SurveySuspenseQueryHookResult = ReturnType<typeof useSurveySuspenseQuery>;
export type SurveyQueryResult = Apollo.QueryResult<SurveyQuery, SurveyQueryVariables>;
export const SurveysChoiceDataDocument = gql`
    query SurveysChoiceData {
  surveyCategoryChoices {
    name
    value
  }
}
    `;

/**
 * __useSurveysChoiceDataQuery__
 *
 * To run a query within a React component, call `useSurveysChoiceDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSurveysChoiceDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSurveysChoiceDataQuery({
 *   variables: {
 *   },
 * });
 */
export function useSurveysChoiceDataQuery(baseOptions?: Apollo.QueryHookOptions<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>(SurveysChoiceDataDocument, options);
      }
export function useSurveysChoiceDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>(SurveysChoiceDataDocument, options);
        }
export function useSurveysChoiceDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>(SurveysChoiceDataDocument, options);
        }
export type SurveysChoiceDataQueryHookResult = ReturnType<typeof useSurveysChoiceDataQuery>;
export type SurveysChoiceDataLazyQueryHookResult = ReturnType<typeof useSurveysChoiceDataLazyQuery>;
export type SurveysChoiceDataSuspenseQueryHookResult = ReturnType<typeof useSurveysChoiceDataSuspenseQuery>;
export type SurveysChoiceDataQueryResult = Apollo.QueryResult<SurveysChoiceDataQuery, SurveysChoiceDataQueryVariables>;
export const AllActiveTargetPopulationsDocument = gql`
    query AllActiveTargetPopulations($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $name: String, $status: String, $totalHouseholdsCountWithValidPhoneNoMin: Int, $totalHouseholdsCountWithValidPhoneNoMax: Int, $totalHouseholdsCountMin: Int, $totalHouseholdsCountMax: Int, $businessArea: String, $program: [ID], $createdAtRange: String, $statusNot: String) {
  allActiveTargetPopulations(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    name: $name
    status: $status
    totalHouseholdsCountWithValidPhoneNoMin: $totalHouseholdsCountWithValidPhoneNoMin
    totalHouseholdsCountWithValidPhoneNoMax: $totalHouseholdsCountWithValidPhoneNoMax
    totalHouseholdsCountMin: $totalHouseholdsCountMin
    totalHouseholdsCountMax: $totalHouseholdsCountMax
    businessArea: $businessArea
    program: $program
    createdAtRange: $createdAtRange
    statusNot: $statusNot
  ) {
    edges {
      node {
        id
        name
        status
        program {
          id
          name
        }
        totalHouseholdsCount
        totalHouseholdsCountWithValidPhoneNo
        createdAt
        updatedAt
        createdBy {
          id
          email
          firstName
          lastName
        }
      }
      cursor
    }
    totalCount
    edgeCount
  }
}
    `;

/**
 * __useAllActiveTargetPopulationsQuery__
 *
 * To run a query within a React component, call `useAllActiveTargetPopulationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllActiveTargetPopulationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllActiveTargetPopulationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      name: // value for 'name'
 *      status: // value for 'status'
 *      totalHouseholdsCountWithValidPhoneNoMin: // value for 'totalHouseholdsCountWithValidPhoneNoMin'
 *      totalHouseholdsCountWithValidPhoneNoMax: // value for 'totalHouseholdsCountWithValidPhoneNoMax'
 *      totalHouseholdsCountMin: // value for 'totalHouseholdsCountMin'
 *      totalHouseholdsCountMax: // value for 'totalHouseholdsCountMax'
 *      businessArea: // value for 'businessArea'
 *      program: // value for 'program'
 *      createdAtRange: // value for 'createdAtRange'
 *      statusNot: // value for 'statusNot'
 *   },
 * });
 */
export function useAllActiveTargetPopulationsQuery(baseOptions?: Apollo.QueryHookOptions<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>(AllActiveTargetPopulationsDocument, options);
      }
export function useAllActiveTargetPopulationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>(AllActiveTargetPopulationsDocument, options);
        }
export function useAllActiveTargetPopulationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>(AllActiveTargetPopulationsDocument, options);
        }
export type AllActiveTargetPopulationsQueryHookResult = ReturnType<typeof useAllActiveTargetPopulationsQuery>;
export type AllActiveTargetPopulationsLazyQueryHookResult = ReturnType<typeof useAllActiveTargetPopulationsLazyQuery>;
export type AllActiveTargetPopulationsSuspenseQueryHookResult = ReturnType<typeof useAllActiveTargetPopulationsSuspenseQuery>;
export type AllActiveTargetPopulationsQueryResult = Apollo.QueryResult<AllActiveTargetPopulationsQuery, AllActiveTargetPopulationsQueryVariables>;
export const AllFieldsAttributesDocument = gql`
    query AllFieldsAttributes {
  allFieldsAttributes {
    id
    name
    labelEn
    associatedWith
    isFlexField
  }
}
    `;

/**
 * __useAllFieldsAttributesQuery__
 *
 * To run a query within a React component, call `useAllFieldsAttributesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllFieldsAttributesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllFieldsAttributesQuery({
 *   variables: {
 *   },
 * });
 */
export function useAllFieldsAttributesQuery(baseOptions?: Apollo.QueryHookOptions<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>(AllFieldsAttributesDocument, options);
      }
export function useAllFieldsAttributesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>(AllFieldsAttributesDocument, options);
        }
export function useAllFieldsAttributesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>(AllFieldsAttributesDocument, options);
        }
export type AllFieldsAttributesQueryHookResult = ReturnType<typeof useAllFieldsAttributesQuery>;
export type AllFieldsAttributesLazyQueryHookResult = ReturnType<typeof useAllFieldsAttributesLazyQuery>;
export type AllFieldsAttributesSuspenseQueryHookResult = ReturnType<typeof useAllFieldsAttributesSuspenseQuery>;
export type AllFieldsAttributesQueryResult = Apollo.QueryResult<AllFieldsAttributesQuery, AllFieldsAttributesQueryVariables>;
export const AllSteficonRulesDocument = gql`
    query AllSteficonRules($enabled: Boolean, $deprecated: Boolean, $type: String!) {
  allSteficonRules(enabled: $enabled, deprecated: $deprecated, type: $type) {
    edges {
      node {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useAllSteficonRulesQuery__
 *
 * To run a query within a React component, call `useAllSteficonRulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllSteficonRulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllSteficonRulesQuery({
 *   variables: {
 *      enabled: // value for 'enabled'
 *      deprecated: // value for 'deprecated'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useAllSteficonRulesQuery(baseOptions: Apollo.QueryHookOptions<AllSteficonRulesQuery, AllSteficonRulesQueryVariables> & ({ variables: AllSteficonRulesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllSteficonRulesQuery, AllSteficonRulesQueryVariables>(AllSteficonRulesDocument, options);
      }
export function useAllSteficonRulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllSteficonRulesQuery, AllSteficonRulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllSteficonRulesQuery, AllSteficonRulesQueryVariables>(AllSteficonRulesDocument, options);
        }
export function useAllSteficonRulesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllSteficonRulesQuery, AllSteficonRulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllSteficonRulesQuery, AllSteficonRulesQueryVariables>(AllSteficonRulesDocument, options);
        }
export type AllSteficonRulesQueryHookResult = ReturnType<typeof useAllSteficonRulesQuery>;
export type AllSteficonRulesLazyQueryHookResult = ReturnType<typeof useAllSteficonRulesLazyQuery>;
export type AllSteficonRulesSuspenseQueryHookResult = ReturnType<typeof useAllSteficonRulesSuspenseQuery>;
export type AllSteficonRulesQueryResult = Apollo.QueryResult<AllSteficonRulesQuery, AllSteficonRulesQueryVariables>;
export const AllTargetPopulationForChoicesDocument = gql`
    query AllTargetPopulationForChoices($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $name: String, $status: String, $numberOfHouseholdsMin: Int, $numberOfHouseholdsMax: Int, $businessArea: String, $program: [ID]) {
  allTargetPopulation(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    name: $name
    status: $status
    totalHouseholdsCountMin: $numberOfHouseholdsMin
    totalHouseholdsCountMax: $numberOfHouseholdsMax
    businessArea: $businessArea
    program: $program
  ) {
    edges {
      node {
        id
        name
      }
      cursor
    }
    totalCount
    edgeCount
  }
}
    `;

/**
 * __useAllTargetPopulationForChoicesQuery__
 *
 * To run a query within a React component, call `useAllTargetPopulationForChoicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllTargetPopulationForChoicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllTargetPopulationForChoicesQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      name: // value for 'name'
 *      status: // value for 'status'
 *      numberOfHouseholdsMin: // value for 'numberOfHouseholdsMin'
 *      numberOfHouseholdsMax: // value for 'numberOfHouseholdsMax'
 *      businessArea: // value for 'businessArea'
 *      program: // value for 'program'
 *   },
 * });
 */
export function useAllTargetPopulationForChoicesQuery(baseOptions?: Apollo.QueryHookOptions<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>(AllTargetPopulationForChoicesDocument, options);
      }
export function useAllTargetPopulationForChoicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>(AllTargetPopulationForChoicesDocument, options);
        }
export function useAllTargetPopulationForChoicesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>(AllTargetPopulationForChoicesDocument, options);
        }
export type AllTargetPopulationForChoicesQueryHookResult = ReturnType<typeof useAllTargetPopulationForChoicesQuery>;
export type AllTargetPopulationForChoicesLazyQueryHookResult = ReturnType<typeof useAllTargetPopulationForChoicesLazyQuery>;
export type AllTargetPopulationForChoicesSuspenseQueryHookResult = ReturnType<typeof useAllTargetPopulationForChoicesSuspenseQuery>;
export type AllTargetPopulationForChoicesQueryResult = Apollo.QueryResult<AllTargetPopulationForChoicesQuery, AllTargetPopulationForChoicesQueryVariables>;
export const AllTargetPopulationsDocument = gql`
    query AllTargetPopulations($after: String, $before: String, $first: Int, $last: Int, $orderBy: String, $name: String, $status: String, $totalHouseholdsCountMin: Int, $totalHouseholdsCountMax: Int, $businessArea: String, $program: [ID], $createdAtRange: String, $paymentPlanApplicable: Boolean) {
  allTargetPopulation(
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    name: $name
    status: $status
    totalHouseholdsCountMin: $totalHouseholdsCountMin
    totalHouseholdsCountMax: $totalHouseholdsCountMax
    businessArea: $businessArea
    program: $program
    createdAtRange: $createdAtRange
    paymentPlanApplicable: $paymentPlanApplicable
  ) {
    edges {
      node {
        ...targetPopulationMinimal
      }
      cursor
    }
    totalCount
    edgeCount
  }
}
    ${TargetPopulationMinimalFragmentDoc}`;

/**
 * __useAllTargetPopulationsQuery__
 *
 * To run a query within a React component, call `useAllTargetPopulationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAllTargetPopulationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAllTargetPopulationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      name: // value for 'name'
 *      status: // value for 'status'
 *      totalHouseholdsCountMin: // value for 'totalHouseholdsCountMin'
 *      totalHouseholdsCountMax: // value for 'totalHouseholdsCountMax'
 *      businessArea: // value for 'businessArea'
 *      program: // value for 'program'
 *      createdAtRange: // value for 'createdAtRange'
 *      paymentPlanApplicable: // value for 'paymentPlanApplicable'
 *   },
 * });
 */
export function useAllTargetPopulationsQuery(baseOptions?: Apollo.QueryHookOptions<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>(AllTargetPopulationsDocument, options);
      }
export function useAllTargetPopulationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>(AllTargetPopulationsDocument, options);
        }
export function useAllTargetPopulationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>(AllTargetPopulationsDocument, options);
        }
export type AllTargetPopulationsQueryHookResult = ReturnType<typeof useAllTargetPopulationsQuery>;
export type AllTargetPopulationsLazyQueryHookResult = ReturnType<typeof useAllTargetPopulationsLazyQuery>;
export type AllTargetPopulationsSuspenseQueryHookResult = ReturnType<typeof useAllTargetPopulationsSuspenseQuery>;
export type AllTargetPopulationsQueryResult = Apollo.QueryResult<AllTargetPopulationsQuery, AllTargetPopulationsQueryVariables>;
export const TargetPopulationDocument = gql`
    query targetPopulation($id: ID!) {
  targetPopulation(id: $id) {
    ...targetPopulationDetailed
  }
}
    ${TargetPopulationDetailedFragmentDoc}`;

/**
 * __useTargetPopulationQuery__
 *
 * To run a query within a React component, call `useTargetPopulationQuery` and pass it any options that fit your needs.
 * When your component renders, `useTargetPopulationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTargetPopulationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTargetPopulationQuery(baseOptions: Apollo.QueryHookOptions<TargetPopulationQuery, TargetPopulationQueryVariables> & ({ variables: TargetPopulationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TargetPopulationQuery, TargetPopulationQueryVariables>(TargetPopulationDocument, options);
      }
export function useTargetPopulationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TargetPopulationQuery, TargetPopulationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TargetPopulationQuery, TargetPopulationQueryVariables>(TargetPopulationDocument, options);
        }
export function useTargetPopulationSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TargetPopulationQuery, TargetPopulationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TargetPopulationQuery, TargetPopulationQueryVariables>(TargetPopulationDocument, options);
        }
export type TargetPopulationQueryHookResult = ReturnType<typeof useTargetPopulationQuery>;
export type TargetPopulationLazyQueryHookResult = ReturnType<typeof useTargetPopulationLazyQuery>;
export type TargetPopulationSuspenseQueryHookResult = ReturnType<typeof useTargetPopulationSuspenseQuery>;
export type TargetPopulationQueryResult = Apollo.QueryResult<TargetPopulationQuery, TargetPopulationQueryVariables>;
export const TargetPopulationHouseholdsDocument = gql`
    query TargetPopulationHouseholds($targetPopulation: ID!, $first: Int, $after: String, $before: String, $last: Int, $orderBy: String, $businessArea: String) {
  targetPopulationHouseholds(
    targetPopulation: $targetPopulation
    after: $after
    before: $before
    first: $first
    last: $last
    orderBy: $orderBy
    businessArea: $businessArea
  ) {
    edges {
      node {
        id
        unicefId
        headOfHousehold {
          id
          unicefId
          givenName
          familyName
          fullName
        }
        size
        adminArea {
          id
          name
        }
        updatedAt
        address
        selection {
          vulnerabilityScore
        }
      }
      cursor
    }
    totalCount
    edgeCount
  }
}
    `;

/**
 * __useTargetPopulationHouseholdsQuery__
 *
 * To run a query within a React component, call `useTargetPopulationHouseholdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTargetPopulationHouseholdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTargetPopulationHouseholdsQuery({
 *   variables: {
 *      targetPopulation: // value for 'targetPopulation'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      last: // value for 'last'
 *      orderBy: // value for 'orderBy'
 *      businessArea: // value for 'businessArea'
 *   },
 * });
 */
export function useTargetPopulationHouseholdsQuery(baseOptions: Apollo.QueryHookOptions<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables> & ({ variables: TargetPopulationHouseholdsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables>(TargetPopulationHouseholdsDocument, options);
      }
export function useTargetPopulationHouseholdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables>(TargetPopulationHouseholdsDocument, options);
        }
export function useTargetPopulationHouseholdsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables>(TargetPopulationHouseholdsDocument, options);
        }
export type TargetPopulationHouseholdsQueryHookResult = ReturnType<typeof useTargetPopulationHouseholdsQuery>;
export type TargetPopulationHouseholdsLazyQueryHookResult = ReturnType<typeof useTargetPopulationHouseholdsLazyQuery>;
export type TargetPopulationHouseholdsSuspenseQueryHookResult = ReturnType<typeof useTargetPopulationHouseholdsSuspenseQuery>;
export type TargetPopulationHouseholdsQueryResult = Apollo.QueryResult<TargetPopulationHouseholdsQuery, TargetPopulationHouseholdsQueryVariables>;


export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;


/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> = {
  Node: ( ApprovalProcessNode ) | ( AreaNode ) | ( AreaTypeNode ) | ( BankAccountInfoNode ) | ( BusinessAreaNode ) | ( CashPlanNode ) | ( CommunicationMessageNode ) | ( CommunicationMessageRecipientMapNode ) | ( DataCollectingTypeNode ) | ( DeliveryMechanismNode ) | ( DocumentNode ) | ( FeedbackMessageNode ) | ( FeedbackNode ) | ( FinancialServiceProviderNode ) | ( FinancialServiceProviderXlsxReportNode ) | ( FinancialServiceProviderXlsxTemplateNode ) | ( GrievanceDocumentNode ) | ( GrievanceTicketNode ) | ( HouseholdNode ) | ( ImportDataNode ) | ( ImportedDocumentNode ) | ( ImportedHouseholdNode ) | ( ImportedIndividualIdentityNode ) | ( ImportedIndividualNode ) | ( IndividualIdentityNode ) | ( IndividualNode ) | ( KoboImportDataNode ) | ( LogEntryNode ) | ( PaymentHouseholdSnapshotNode ) | ( PaymentNode ) | ( PaymentPlanNode ) | ( PaymentRecordNode ) | ( PaymentVerificationLogEntryNode ) | ( PaymentVerificationNode ) | ( PaymentVerificationPlanNode ) | ( PaymentVerificationSummaryNode ) | ( ProgramNode ) | ( RecipientNode ) | ( RegistrationDataImportDatahubNode ) | ( RegistrationDataImportNode ) | ( ReportNode ) | ( RuleCommitNode ) | ( SanctionListIndividualAliasNameNode ) | ( SanctionListIndividualCountriesNode ) | ( SanctionListIndividualDateOfBirthNode ) | ( SanctionListIndividualDocumentNode ) | ( SanctionListIndividualNationalitiesNode ) | ( SanctionListIndividualNode ) | ( ServiceProviderNode ) | ( SteficonRuleNode ) | ( SurveyNode ) | ( TargetPopulationNode ) | ( TicketAddIndividualDetailsNode ) | ( TicketComplaintDetailsNode ) | ( TicketDeleteHouseholdDetailsNode ) | ( TicketDeleteIndividualDetailsNode ) | ( TicketHouseholdDataUpdateDetailsNode ) | ( TicketIndividualDataUpdateDetailsNode ) | ( TicketNeedsAdjudicationDetailsNode ) | ( TicketNegativeFeedbackDetailsNode ) | ( TicketNoteNode ) | ( TicketPaymentVerificationDetailsNode ) | ( TicketPositiveFeedbackDetailsNode ) | ( TicketReferralDetailsNode ) | ( TicketSensitiveDetailsNode ) | ( TicketSystemFlaggingDetailsNode ) | ( UserBusinessAreaNode ) | ( UserNode ) | ( VolumeByDeliveryMechanismNode );
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AccountabilityCommunicationMessageAgeInput: AccountabilityCommunicationMessageAgeInput;
  AccountabilityFullListArguments: AccountabilityFullListArguments;
  AccountabilityRandomSamplingArguments: AccountabilityRandomSamplingArguments;
  AccountabilitySampleSizeInput: AccountabilitySampleSizeInput;
  AccountabilitySampleSizeNode: ResolverTypeWrapper<AccountabilitySampleSizeNode>;
  Action: Action;
  ActionPaymentPlanInput: ActionPaymentPlanInput;
  ActionPaymentPlanMutation: ResolverTypeWrapper<ActionPaymentPlanMutation>;
  ActivatePaymentVerificationPlan: ResolverTypeWrapper<ActivatePaymentVerificationPlan>;
  AddIndividualDataObjectType: AddIndividualDataObjectType;
  AddIndividualIssueTypeExtras: AddIndividualIssueTypeExtras;
  AgeFilterObject: ResolverTypeWrapper<AgeFilterObject>;
  AgeInput: AgeInput;
  ApprovalNode: ResolverTypeWrapper<ApprovalNode>;
  ApprovalProcessNode: ResolverTypeWrapper<ApprovalProcessNode>;
  ApprovalProcessNodeConnection: ResolverTypeWrapper<ApprovalProcessNodeConnection>;
  ApprovalProcessNodeEdge: ResolverTypeWrapper<ApprovalProcessNodeEdge>;
  AreaGroupNode: ResolverTypeWrapper<AreaGroupNode>;
  AreaNode: ResolverTypeWrapper<AreaNode>;
  AreaNodeConnection: ResolverTypeWrapper<AreaNodeConnection>;
  AreaNodeEdge: ResolverTypeWrapper<AreaNodeEdge>;
  AreaTreeNode: ResolverTypeWrapper<AreaTreeNode>;
  AreaTypeNode: ResolverTypeWrapper<AreaTypeNode>;
  AreaTypeNodeConnection: ResolverTypeWrapper<AreaTypeNodeConnection>;
  AreaTypeNodeEdge: ResolverTypeWrapper<AreaTypeNodeEdge>;
  Arg: ResolverTypeWrapper<Scalars['Arg']['output']>;
  AssignFspToDeliveryMechanismInput: AssignFspToDeliveryMechanismInput;
  AssignFspToDeliveryMechanismMutation: ResolverTypeWrapper<AssignFspToDeliveryMechanismMutation>;
  AvailableFspsForDeliveryMechanismsInput: AvailableFspsForDeliveryMechanismsInput;
  BankAccountInfoNode: ResolverTypeWrapper<BankAccountInfoNode>;
  BankAccountInfoNodeConnection: ResolverTypeWrapper<BankAccountInfoNodeConnection>;
  BankAccountInfoNodeEdge: ResolverTypeWrapper<BankAccountInfoNodeEdge>;
  BankTransferObjectType: BankTransferObjectType;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']['output']>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  BulkGrievanceAddNoteMutation: ResolverTypeWrapper<BulkGrievanceAddNoteMutation>;
  BulkUpdateGrievanceTicketsAssigneesMutation: ResolverTypeWrapper<BulkUpdateGrievanceTicketsAssigneesMutation>;
  BulkUpdateGrievanceTicketsPriorityMutation: ResolverTypeWrapper<BulkUpdateGrievanceTicketsPriorityMutation>;
  BulkUpdateGrievanceTicketsUrgencyMutation: ResolverTypeWrapper<BulkUpdateGrievanceTicketsUrgencyMutation>;
  BusinessAreaNode: ResolverTypeWrapper<BusinessAreaNode>;
  BusinessAreaNodeConnection: ResolverTypeWrapper<BusinessAreaNodeConnection>;
  BusinessAreaNodeEdge: ResolverTypeWrapper<BusinessAreaNodeEdge>;
  CashPlanAndPaymentPlanEdges: ResolverTypeWrapper<CashPlanAndPaymentPlanEdges>;
  CashPlanAndPaymentPlanNode: ResolverTypeWrapper<CashPlanAndPaymentPlanNode>;
  CashPlanNode: ResolverTypeWrapper<CashPlanNode>;
  CashPlanNodeConnection: ResolverTypeWrapper<CashPlanNodeConnection>;
  CashPlanNodeEdge: ResolverTypeWrapper<CashPlanNodeEdge>;
  CashPlanStatus: CashPlanStatus;
  CategoryExtrasInput: CategoryExtrasInput;
  ChartDatasetNode: ResolverTypeWrapper<ChartDatasetNode>;
  ChartDetailedDatasetsNode: ResolverTypeWrapper<ChartDetailedDatasetsNode>;
  ChartGrievanceTicketsNode: ResolverTypeWrapper<ChartGrievanceTicketsNode>;
  ChartPaymentVerification: ResolverTypeWrapper<ChartPaymentVerification>;
  CheckAgainstSanctionListMutation: ResolverTypeWrapper<CheckAgainstSanctionListMutation>;
  ChoiceObject: ResolverTypeWrapper<ChoiceObject>;
  ChoiceObjectInt: ResolverTypeWrapper<ChoiceObjectInt>;
  ChooseDeliveryMechanismsForPaymentPlanInput: ChooseDeliveryMechanismsForPaymentPlanInput;
  ChooseDeliveryMechanismsForPaymentPlanMutation: ResolverTypeWrapper<ChooseDeliveryMechanismsForPaymentPlanMutation>;
  CommunicationMessageNode: ResolverTypeWrapper<CommunicationMessageNode>;
  CommunicationMessageNodeConnection: ResolverTypeWrapper<CommunicationMessageNodeConnection>;
  CommunicationMessageNodeEdge: ResolverTypeWrapper<CommunicationMessageNodeEdge>;
  CommunicationMessageRecipientMapNode: ResolverTypeWrapper<CommunicationMessageRecipientMapNode>;
  CommunicationMessageRecipientMapNodeConnection: ResolverTypeWrapper<CommunicationMessageRecipientMapNodeConnection>;
  CommunicationMessageRecipientMapNodeEdge: ResolverTypeWrapper<CommunicationMessageRecipientMapNodeEdge>;
  ContentTypeObjectType: ResolverTypeWrapper<ContentTypeObjectType>;
  CopyProgram: ResolverTypeWrapper<CopyProgram>;
  CopyProgramInput: CopyProgramInput;
  CopyTargetPopulationInput: CopyTargetPopulationInput;
  CopyTargetPopulationMutationInput: CopyTargetPopulationMutationInput;
  CopyTargetPopulationMutationPayload: ResolverTypeWrapper<CopyTargetPopulationMutationPayload>;
  CoreFieldChoiceObject: ResolverTypeWrapper<CoreFieldChoiceObject>;
  CountAndPercentageNode: ResolverTypeWrapper<CountAndPercentageNode>;
  CreateAccountabilityCommunicationMessageInput: CreateAccountabilityCommunicationMessageInput;
  CreateCommunicationMessageMutation: ResolverTypeWrapper<CreateCommunicationMessageMutation>;
  CreateDashboardReport: ResolverTypeWrapper<CreateDashboardReport>;
  CreateDashboardReportInput: CreateDashboardReportInput;
  CreateFeedbackInput: CreateFeedbackInput;
  CreateFeedbackMessageInput: CreateFeedbackMessageInput;
  CreateFeedbackMessageMutation: ResolverTypeWrapper<CreateFeedbackMessageMutation>;
  CreateFeedbackMutation: ResolverTypeWrapper<CreateFeedbackMutation>;
  CreateFollowUpPaymentPlanMutation: ResolverTypeWrapper<CreateFollowUpPaymentPlanMutation>;
  CreateGrievanceTicketExtrasInput: CreateGrievanceTicketExtrasInput;
  CreateGrievanceTicketInput: CreateGrievanceTicketInput;
  CreateGrievanceTicketMutation: ResolverTypeWrapper<CreateGrievanceTicketMutation>;
  CreatePaymentPlanInput: CreatePaymentPlanInput;
  CreatePaymentPlanMutation: ResolverTypeWrapper<CreatePaymentPlanMutation>;
  CreatePaymentVerificationInput: CreatePaymentVerificationInput;
  CreateProgram: ResolverTypeWrapper<CreateProgram>;
  CreateProgramInput: CreateProgramInput;
  CreateReport: ResolverTypeWrapper<CreateReport>;
  CreateReportInput: CreateReportInput;
  CreateSurveyInput: CreateSurveyInput;
  CreateSurveyMutation: ResolverTypeWrapper<CreateSurveyMutation>;
  CreateTargetPopulationInput: CreateTargetPopulationInput;
  CreateTargetPopulationMutation: ResolverTypeWrapper<CreateTargetPopulationMutation>;
  CreateTicketNoteInput: CreateTicketNoteInput;
  CreateTicketNoteMutation: ResolverTypeWrapper<CreateTicketNoteMutation>;
  CreateVerificationPlanMutation: ResolverTypeWrapper<CreateVerificationPlanMutation>;
  DataCollectingTypeChoiceObject: ResolverTypeWrapper<DataCollectingTypeChoiceObject>;
  DataCollectingTypeNode: ResolverTypeWrapper<DataCollectingTypeNode>;
  DataCollectingTypeNodeConnection: ResolverTypeWrapper<DataCollectingTypeNodeConnection>;
  DataCollectingTypeNodeEdge: ResolverTypeWrapper<DataCollectingTypeNodeEdge>;
  DataCollectingTypeType: DataCollectingTypeType;
  Date: ResolverTypeWrapper<Scalars['Date']['output']>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
  Decimal: ResolverTypeWrapper<Scalars['Decimal']['output']>;
  DeduplicationResultNode: ResolverTypeWrapper<DeduplicationResultNode>;
  DeleteHouseholdApproveMutation: ResolverTypeWrapper<DeleteHouseholdApproveMutation>;
  DeletePaymentPlanMutation: ResolverTypeWrapper<DeletePaymentPlanMutation>;
  DeletePaymentVerificationPlan: ResolverTypeWrapper<DeletePaymentVerificationPlan>;
  DeleteProgram: ResolverTypeWrapper<DeleteProgram>;
  DeleteRegistrationDataImport: ResolverTypeWrapper<DeleteRegistrationDataImport>;
  DeleteTargetPopulationMutationInput: DeleteTargetPopulationMutationInput;
  DeleteTargetPopulationMutationPayload: ResolverTypeWrapper<DeleteTargetPopulationMutationPayload>;
  DeliveredQuantityNode: ResolverTypeWrapper<DeliveredQuantityNode>;
  DeliveryMechanismNode: ResolverTypeWrapper<DeliveryMechanismNode>;
  DeliveryMechanismNodeConnection: ResolverTypeWrapper<DeliveryMechanismNodeConnection>;
  DeliveryMechanismNodeEdge: ResolverTypeWrapper<DeliveryMechanismNodeEdge>;
  DeliveryMechanismPerPaymentPlanDeliveryMechanism: DeliveryMechanismPerPaymentPlanDeliveryMechanism;
  DiscardPaymentVerificationPlan: ResolverTypeWrapper<DiscardPaymentVerificationPlan>;
  DjangoDebug: ResolverTypeWrapper<DjangoDebug>;
  DjangoDebugSQL: ResolverTypeWrapper<DjangoDebugSql>;
  DocumentNode: ResolverTypeWrapper<DocumentNode>;
  DocumentNodeConnection: ResolverTypeWrapper<DocumentNodeConnection>;
  DocumentNodeEdge: ResolverTypeWrapper<DocumentNodeEdge>;
  DocumentStatus: DocumentStatus;
  DocumentTypeNode: ResolverTypeWrapper<DocumentTypeNode>;
  EditBankTransferObjectType: EditBankTransferObjectType;
  EditIndividualDocumentObjectType: EditIndividualDocumentObjectType;
  EditIndividualIdentityObjectType: EditIndividualIdentityObjectType;
  EditPaymentVerificationInput: EditPaymentVerificationInput;
  EditPaymentVerificationMutation: ResolverTypeWrapper<EditPaymentVerificationMutation>;
  EraseRegistrationDataImportMutation: ResolverTypeWrapper<EraseRegistrationDataImportMutation>;
  ExcludeHouseholdsMutation: ResolverTypeWrapper<ExcludeHouseholdsMutation>;
  ExportPDFPaymentPlanSummaryMutation: ResolverTypeWrapper<ExportPdfPaymentPlanSummaryMutation>;
  ExportSurveySampleMutationMutation: ResolverTypeWrapper<ExportSurveySampleMutationMutation>;
  ExportXLSXPaymentPlanPaymentListMutation: ResolverTypeWrapper<ExportXlsxPaymentPlanPaymentListMutation>;
  ExportXLSXPaymentPlanPaymentListPerFSPMutation: ResolverTypeWrapper<ExportXlsxPaymentPlanPaymentListPerFspMutation>;
  ExportXlsxPaymentVerificationPlanFile: ResolverTypeWrapper<ExportXlsxPaymentVerificationPlanFile>;
  FSPToDeliveryMechanismMappingInput: FspToDeliveryMechanismMappingInput;
  FeedbackIssueType: FeedbackIssueType;
  FeedbackMessageNode: ResolverTypeWrapper<FeedbackMessageNode>;
  FeedbackMessageNodeConnection: ResolverTypeWrapper<FeedbackMessageNodeConnection>;
  FeedbackMessageNodeEdge: ResolverTypeWrapper<FeedbackMessageNodeEdge>;
  FeedbackNode: ResolverTypeWrapper<FeedbackNode>;
  FeedbackNodeConnection: ResolverTypeWrapper<FeedbackNodeConnection>;
  FeedbackNodeEdge: ResolverTypeWrapper<FeedbackNodeEdge>;
  FieldAttributeNode: ResolverTypeWrapper<FieldAttributeNode>;
  FilteredActionsListNode: ResolverTypeWrapper<FilteredActionsListNode>;
  FinalizeTargetPopulationMutation: ResolverTypeWrapper<FinalizeTargetPopulationMutation>;
  FinancialServiceProviderCommunicationChannel: FinancialServiceProviderCommunicationChannel;
  FinancialServiceProviderNode: ResolverTypeWrapper<FinancialServiceProviderNode>;
  FinancialServiceProviderNodeConnection: ResolverTypeWrapper<FinancialServiceProviderNodeConnection>;
  FinancialServiceProviderNodeEdge: ResolverTypeWrapper<FinancialServiceProviderNodeEdge>;
  FinancialServiceProviderXlsxReportNode: ResolverTypeWrapper<FinancialServiceProviderXlsxReportNode>;
  FinancialServiceProviderXlsxReportNodeConnection: ResolverTypeWrapper<FinancialServiceProviderXlsxReportNodeConnection>;
  FinancialServiceProviderXlsxReportNodeEdge: ResolverTypeWrapper<FinancialServiceProviderXlsxReportNodeEdge>;
  FinancialServiceProviderXlsxTemplateNode: ResolverTypeWrapper<FinancialServiceProviderXlsxTemplateNode>;
  FinancialServiceProviderXlsxTemplateNodeConnection: ResolverTypeWrapper<FinancialServiceProviderXlsxTemplateNodeConnection>;
  FinancialServiceProviderXlsxTemplateNodeEdge: ResolverTypeWrapper<FinancialServiceProviderXlsxTemplateNodeEdge>;
  FinishPaymentVerificationPlan: ResolverTypeWrapper<FinishPaymentVerificationPlan>;
  FlexFieldsScalar: ResolverTypeWrapper<Scalars['FlexFieldsScalar']['output']>;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  FspChoice: ResolverTypeWrapper<FspChoice>;
  FspChoices: ResolverTypeWrapper<FspChoices>;
  FspConfiguration: ResolverTypeWrapper<FspConfiguration>;
  FullListArguments: FullListArguments;
  GenericPaymentNode: ResolverTypeWrapper<GenericPaymentNode>;
  GenericPaymentPlanNode: ResolverTypeWrapper<GenericPaymentPlanNode>;
  GeoJSON: ResolverTypeWrapper<Scalars['GeoJSON']['output']>;
  GetAccountabilityCommunicationMessageSampleSizeInput: GetAccountabilityCommunicationMessageSampleSizeInput;
  GetCashplanVerificationSampleSizeInput: GetCashplanVerificationSampleSizeInput;
  GetCashplanVerificationSampleSizeObject: ResolverTypeWrapper<GetCashplanVerificationSampleSizeObject>;
  GetCommunicationMessageSampleSizeNode: ResolverTypeWrapper<GetCommunicationMessageSampleSizeNode>;
  GrievanceComplaintTicketExtras: GrievanceComplaintTicketExtras;
  GrievanceDocumentInput: GrievanceDocumentInput;
  GrievanceDocumentNode: ResolverTypeWrapper<GrievanceDocumentNode>;
  GrievanceDocumentNodeConnection: ResolverTypeWrapper<GrievanceDocumentNodeConnection>;
  GrievanceDocumentNodeEdge: ResolverTypeWrapper<GrievanceDocumentNodeEdge>;
  GrievanceDocumentUpdateInput: GrievanceDocumentUpdateInput;
  GrievanceStatusChangeMutation: ResolverTypeWrapper<GrievanceStatusChangeMutation>;
  GrievanceTicketNode: ResolverTypeWrapper<GrievanceTicketNode>;
  GrievanceTicketNodeConnection: ResolverTypeWrapper<GrievanceTicketNodeConnection>;
  GrievanceTicketNodeEdge: ResolverTypeWrapper<GrievanceTicketNodeEdge>;
  GroupAttributeNode: ResolverTypeWrapper<GroupAttributeNode>;
  HouseholdCollectIndividualData: HouseholdCollectIndividualData;
  HouseholdCollectType: HouseholdCollectType;
  HouseholdDataChangeApproveMutation: ResolverTypeWrapper<HouseholdDataChangeApproveMutation>;
  HouseholdDataUpdateIssueTypeExtras: HouseholdDataUpdateIssueTypeExtras;
  HouseholdDeleteIssueTypeExtras: HouseholdDeleteIssueTypeExtras;
  HouseholdNode: ResolverTypeWrapper<HouseholdNode>;
  HouseholdNodeConnection: ResolverTypeWrapper<HouseholdNodeConnection>;
  HouseholdNodeEdge: ResolverTypeWrapper<HouseholdNodeEdge>;
  HouseholdOrgEnumerator: HouseholdOrgEnumerator;
  HouseholdRegistrationMethod: HouseholdRegistrationMethod;
  HouseholdSelectionNode: ResolverTypeWrapper<HouseholdSelectionNode>;
  HouseholdUpdateDataObjectType: HouseholdUpdateDataObjectType;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  ImportDataDataType: ImportDataDataType;
  ImportDataNode: ResolverTypeWrapper<ImportDataNode>;
  ImportDataStatus: ImportDataStatus;
  ImportXLSXPaymentPlanPaymentListMutation: ResolverTypeWrapper<ImportXlsxPaymentPlanPaymentListMutation>;
  ImportXLSXPaymentPlanPaymentListPerFSPMutation: ResolverTypeWrapper<ImportXlsxPaymentPlanPaymentListPerFspMutation>;
  ImportXlsxPaymentVerificationPlanFile: ResolverTypeWrapper<ImportXlsxPaymentVerificationPlanFile>;
  ImportedDocumentNode: ResolverTypeWrapper<ImportedDocumentNode>;
  ImportedDocumentNodeConnection: ResolverTypeWrapper<ImportedDocumentNodeConnection>;
  ImportedDocumentNodeEdge: ResolverTypeWrapper<ImportedDocumentNodeEdge>;
  ImportedDocumentTypeNode: ResolverTypeWrapper<ImportedDocumentTypeNode>;
  ImportedHouseholdCollectIndividualData: ImportedHouseholdCollectIndividualData;
  ImportedHouseholdCollectType: ImportedHouseholdCollectType;
  ImportedHouseholdConsentSharing: ImportedHouseholdConsentSharing;
  ImportedHouseholdCurrency: ImportedHouseholdCurrency;
  ImportedHouseholdNode: ResolverTypeWrapper<ImportedHouseholdNode>;
  ImportedHouseholdNodeConnection: ResolverTypeWrapper<ImportedHouseholdNodeConnection>;
  ImportedHouseholdNodeEdge: ResolverTypeWrapper<ImportedHouseholdNodeEdge>;
  ImportedHouseholdOrgEnumerator: ImportedHouseholdOrgEnumerator;
  ImportedHouseholdRegistrationMethod: ImportedHouseholdRegistrationMethod;
  ImportedHouseholdResidenceStatus: ImportedHouseholdResidenceStatus;
  ImportedIndividualDeduplicationBatchStatus: ImportedIndividualDeduplicationBatchStatus;
  ImportedIndividualDeduplicationGoldenRecordStatus: ImportedIndividualDeduplicationGoldenRecordStatus;
  ImportedIndividualDisability: ImportedIndividualDisability;
  ImportedIndividualIdentityNode: ResolverTypeWrapper<ImportedIndividualIdentityNode>;
  ImportedIndividualIdentityNodeConnection: ResolverTypeWrapper<ImportedIndividualIdentityNodeConnection>;
  ImportedIndividualIdentityNodeEdge: ResolverTypeWrapper<ImportedIndividualIdentityNodeEdge>;
  ImportedIndividualMaritalStatus: ImportedIndividualMaritalStatus;
  ImportedIndividualNode: ResolverTypeWrapper<ImportedIndividualNode>;
  ImportedIndividualNodeConnection: ResolverTypeWrapper<ImportedIndividualNodeConnection>;
  ImportedIndividualNodeEdge: ResolverTypeWrapper<ImportedIndividualNodeEdge>;
  ImportedIndividualSex: ImportedIndividualSex;
  IndividualDataChangeApproveMutation: ResolverTypeWrapper<IndividualDataChangeApproveMutation>;
  IndividualDataUpdateIssueTypeExtras: IndividualDataUpdateIssueTypeExtras;
  IndividualDeduplicationBatchStatus: IndividualDeduplicationBatchStatus;
  IndividualDeduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus;
  IndividualDeleteIssueTypeExtras: IndividualDeleteIssueTypeExtras;
  IndividualDisability: IndividualDisability;
  IndividualDocumentObjectType: IndividualDocumentObjectType;
  IndividualIdentityNode: ResolverTypeWrapper<IndividualIdentityNode>;
  IndividualIdentityNodeConnection: ResolverTypeWrapper<IndividualIdentityNodeConnection>;
  IndividualIdentityNodeEdge: ResolverTypeWrapper<IndividualIdentityNodeEdge>;
  IndividualIdentityObjectType: IndividualIdentityObjectType;
  IndividualMaritalStatus: IndividualMaritalStatus;
  IndividualNode: ResolverTypeWrapper<IndividualNode>;
  IndividualNodeConnection: ResolverTypeWrapper<IndividualNodeConnection>;
  IndividualNodeEdge: ResolverTypeWrapper<IndividualNodeEdge>;
  IndividualRelationship: IndividualRelationship;
  IndividualRoleInHouseholdNode: ResolverTypeWrapper<IndividualRoleInHouseholdNode>;
  IndividualRoleInHouseholdRole: IndividualRoleInHouseholdRole;
  IndividualSex: IndividualSex;
  IndividualUpdateDataObjectType: IndividualUpdateDataObjectType;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  InvalidPaymentVerificationPlan: ResolverTypeWrapper<InvalidPaymentVerificationPlan>;
  IssueTypeExtrasInput: IssueTypeExtrasInput;
  IssueTypesObject: ResolverTypeWrapper<IssueTypesObject>;
  JSONString: ResolverTypeWrapper<Scalars['JSONString']['output']>;
  KoboAssetObject: ResolverTypeWrapper<KoboAssetObject>;
  KoboAssetObjectConnection: ResolverTypeWrapper<KoboAssetObjectConnection>;
  KoboAssetObjectEdge: ResolverTypeWrapper<KoboAssetObjectEdge>;
  KoboErrorNode: ResolverTypeWrapper<KoboErrorNode>;
  KoboImportDataNode: ResolverTypeWrapper<KoboImportDataNode>;
  LabelNode: ResolverTypeWrapper<LabelNode>;
  LanguageObject: ResolverTypeWrapper<LanguageObject>;
  LanguageObjectConnection: ResolverTypeWrapper<LanguageObjectConnection>;
  LanguageObjectEdge: ResolverTypeWrapper<LanguageObjectEdge>;
  LockTargetPopulationMutation: ResolverTypeWrapper<LockTargetPopulationMutation>;
  LogEntryAction: LogEntryAction;
  LogEntryNode: ResolverTypeWrapper<LogEntryNode>;
  LogEntryNodeConnection: ResolverTypeWrapper<LogEntryNodeConnection>;
  LogEntryNodeEdge: ResolverTypeWrapper<LogEntryNodeEdge>;
  MarkPaymentAsFailedMutation: ResolverTypeWrapper<MarkPaymentAsFailedMutation>;
  MarkPaymentRecordAsFailedMutation: ResolverTypeWrapper<MarkPaymentRecordAsFailedMutation>;
  MergeRegistrationDataImportMutation: ResolverTypeWrapper<MergeRegistrationDataImportMutation>;
  MessageSamplingType: MessageSamplingType;
  Mutations: ResolverTypeWrapper<{}>;
  NeedsAdjudicationApproveMutation: ResolverTypeWrapper<NeedsAdjudicationApproveMutation>;
  NegativeFeedbackTicketExtras: NegativeFeedbackTicketExtras;
  Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Node']>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PageInfoNode: ResolverTypeWrapper<PageInfoNode>;
  PaginatedCashPlanAndPaymentPlanNode: ResolverTypeWrapper<PaginatedCashPlanAndPaymentPlanNode>;
  PaginatedPaymentRecordsAndPaymentsNode: ResolverTypeWrapper<PaginatedPaymentRecordsAndPaymentsNode>;
  PartnerNodeForProgram: ResolverTypeWrapper<PartnerNodeForProgram>;
  PartnerProgramInput: PartnerProgramInput;
  PartnerType: ResolverTypeWrapper<PartnerType>;
  PaymentConflictDataNode: ResolverTypeWrapper<PaymentConflictDataNode>;
  PaymentDeliveryType: PaymentDeliveryType;
  PaymentDetailsApproveMutation: ResolverTypeWrapper<PaymentDetailsApproveMutation>;
  PaymentHouseholdSnapshotNode: ResolverTypeWrapper<PaymentHouseholdSnapshotNode>;
  PaymentNode: ResolverTypeWrapper<PaymentNode>;
  PaymentNodeConnection: ResolverTypeWrapper<PaymentNodeConnection>;
  PaymentNodeEdge: ResolverTypeWrapper<PaymentNodeEdge>;
  PaymentPlanBackgroundActionStatus: PaymentPlanBackgroundActionStatus;
  PaymentPlanCurrency: PaymentPlanCurrency;
  PaymentPlanNode: ResolverTypeWrapper<PaymentPlanNode>;
  PaymentPlanNodeConnection: ResolverTypeWrapper<PaymentPlanNodeConnection>;
  PaymentPlanNodeEdge: ResolverTypeWrapper<PaymentPlanNodeEdge>;
  PaymentPlanStatus: PaymentPlanStatus;
  PaymentRecordAndPaymentNode: ResolverTypeWrapper<PaymentRecordAndPaymentNode>;
  PaymentRecordDeliveryType: PaymentRecordDeliveryType;
  PaymentRecordEntitlementCardStatus: PaymentRecordEntitlementCardStatus;
  PaymentRecordNode: ResolverTypeWrapper<PaymentRecordNode>;
  PaymentRecordNodeConnection: ResolverTypeWrapper<PaymentRecordNodeConnection>;
  PaymentRecordNodeEdge: ResolverTypeWrapper<PaymentRecordNodeEdge>;
  PaymentRecordStatus: PaymentRecordStatus;
  PaymentRecordsAndPaymentsEdges: ResolverTypeWrapper<PaymentRecordsAndPaymentsEdges>;
  PaymentStatus: PaymentStatus;
  PaymentVerificationLogEntryNode: ResolverTypeWrapper<PaymentVerificationLogEntryNode>;
  PaymentVerificationLogEntryNodeConnection: ResolverTypeWrapper<PaymentVerificationLogEntryNodeConnection>;
  PaymentVerificationLogEntryNodeEdge: ResolverTypeWrapper<PaymentVerificationLogEntryNodeEdge>;
  PaymentVerificationNode: ResolverTypeWrapper<PaymentVerificationNode>;
  PaymentVerificationNodeConnection: ResolverTypeWrapper<PaymentVerificationNodeConnection>;
  PaymentVerificationNodeEdge: ResolverTypeWrapper<PaymentVerificationNodeEdge>;
  PaymentVerificationPlanNode: ResolverTypeWrapper<PaymentVerificationPlanNode>;
  PaymentVerificationPlanNodeConnection: ResolverTypeWrapper<PaymentVerificationPlanNodeConnection>;
  PaymentVerificationPlanNodeEdge: ResolverTypeWrapper<PaymentVerificationPlanNodeEdge>;
  PaymentVerificationPlanSampling: PaymentVerificationPlanSampling;
  PaymentVerificationPlanStatus: PaymentVerificationPlanStatus;
  PaymentVerificationPlanVerificationChannel: PaymentVerificationPlanVerificationChannel;
  PaymentVerificationStatus: PaymentVerificationStatus;
  PaymentVerificationStatusForUpdate: PaymentVerificationStatusForUpdate;
  PaymentVerificationSummaryNode: ResolverTypeWrapper<PaymentVerificationSummaryNode>;
  PaymentVerificationSummaryNodeConnection: ResolverTypeWrapper<PaymentVerificationSummaryNodeConnection>;
  PaymentVerificationSummaryNodeEdge: ResolverTypeWrapper<PaymentVerificationSummaryNodeEdge>;
  PaymentVerificationSummaryStatus: PaymentVerificationSummaryStatus;
  PositiveFeedbackTicketExtras: PositiveFeedbackTicketExtras;
  ProgramFrequencyOfPayments: ProgramFrequencyOfPayments;
  ProgramNode: ResolverTypeWrapper<ProgramNode>;
  ProgramNodeConnection: ResolverTypeWrapper<ProgramNodeConnection>;
  ProgramNodeEdge: ResolverTypeWrapper<ProgramNodeEdge>;
  ProgramScope: ProgramScope;
  ProgramSector: ProgramSector;
  ProgramStatus: ProgramStatus;
  Query: ResolverTypeWrapper<{}>;
  RandomSamplingArguments: RandomSamplingArguments;
  RapidProArguments: RapidProArguments;
  RapidProFlow: ResolverTypeWrapper<RapidProFlow>;
  RapidProFlowNode: ResolverTypeWrapper<RapidProFlowNode>;
  RapidProFlowResult: ResolverTypeWrapper<RapidProFlowResult>;
  RapidProFlowRun: ResolverTypeWrapper<RapidProFlowRun>;
  ReassignRoleMutation: ResolverTypeWrapper<ReassignRoleMutation>;
  RebuildTargetPopulationMutation: ResolverTypeWrapper<RebuildTargetPopulationMutation>;
  RecipientNode: ResolverTypeWrapper<RecipientNode>;
  RecipientNodeConnection: ResolverTypeWrapper<RecipientNodeConnection>;
  RecipientNodeEdge: ResolverTypeWrapper<RecipientNodeEdge>;
  ReconciliationSummaryNode: ResolverTypeWrapper<ReconciliationSummaryNode>;
  ReferralTicketExtras: ReferralTicketExtras;
  RefuseRegistrationDataImportMutation: ResolverTypeWrapper<RefuseRegistrationDataImportMutation>;
  RegistrationDataImportDataSource: RegistrationDataImportDataSource;
  RegistrationDataImportDatahubImportDone: RegistrationDataImportDatahubImportDone;
  RegistrationDataImportDatahubNode: ResolverTypeWrapper<RegistrationDataImportDatahubNode>;
  RegistrationDataImportDatahubNodeConnection: ResolverTypeWrapper<RegistrationDataImportDatahubNodeConnection>;
  RegistrationDataImportDatahubNodeEdge: ResolverTypeWrapper<RegistrationDataImportDatahubNodeEdge>;
  RegistrationDataImportNode: ResolverTypeWrapper<RegistrationDataImportNode>;
  RegistrationDataImportNodeConnection: ResolverTypeWrapper<RegistrationDataImportNodeConnection>;
  RegistrationDataImportNodeEdge: ResolverTypeWrapper<RegistrationDataImportNodeEdge>;
  RegistrationDataImportStatus: RegistrationDataImportStatus;
  RegistrationDeduplicationMutation: ResolverTypeWrapper<RegistrationDeduplicationMutation>;
  RegistrationKoboImportMutation: ResolverTypeWrapper<RegistrationKoboImportMutation>;
  RegistrationKoboImportMutationInput: RegistrationKoboImportMutationInput;
  RegistrationXlsxImportMutation: ResolverTypeWrapper<RegistrationXlsxImportMutation>;
  RegistrationXlsxImportMutationInput: RegistrationXlsxImportMutationInput;
  ReportNode: ResolverTypeWrapper<ReportNode>;
  ReportNodeConnection: ResolverTypeWrapper<ReportNodeConnection>;
  ReportNodeEdge: ResolverTypeWrapper<ReportNodeEdge>;
  RestartCreateReport: ResolverTypeWrapper<RestartCreateReport>;
  RestartCreateReportInput: RestartCreateReportInput;
  RevertMarkPaymentAsFailedMutation: ResolverTypeWrapper<RevertMarkPaymentAsFailedMutation>;
  RevertMarkPaymentRecordAsFailedMutation: ResolverTypeWrapper<RevertMarkPaymentRecordAsFailedMutation>;
  RoleChoiceObject: ResolverTypeWrapper<RoleChoiceObject>;
  RoleNode: ResolverTypeWrapper<RoleNode>;
  RoleSubsystem: RoleSubsystem;
  RuleCommitLanguage: RuleCommitLanguage;
  RuleCommitNode: ResolverTypeWrapper<RuleCommitNode>;
  RuleCommitNodeConnection: ResolverTypeWrapper<RuleCommitNodeConnection>;
  RuleCommitNodeEdge: ResolverTypeWrapper<RuleCommitNodeEdge>;
  RuleLanguage: RuleLanguage;
  RuleSecurity: RuleSecurity;
  RuleType: RuleType;
  SamplingChoices: SamplingChoices;
  SanctionListIndividualAliasNameNode: ResolverTypeWrapper<SanctionListIndividualAliasNameNode>;
  SanctionListIndividualAliasNameNodeConnection: ResolverTypeWrapper<SanctionListIndividualAliasNameNodeConnection>;
  SanctionListIndividualAliasNameNodeEdge: ResolverTypeWrapper<SanctionListIndividualAliasNameNodeEdge>;
  SanctionListIndividualCountriesNode: ResolverTypeWrapper<SanctionListIndividualCountriesNode>;
  SanctionListIndividualCountriesNodeConnection: ResolverTypeWrapper<SanctionListIndividualCountriesNodeConnection>;
  SanctionListIndividualCountriesNodeEdge: ResolverTypeWrapper<SanctionListIndividualCountriesNodeEdge>;
  SanctionListIndividualDateOfBirthNode: ResolverTypeWrapper<SanctionListIndividualDateOfBirthNode>;
  SanctionListIndividualDateOfBirthNodeConnection: ResolverTypeWrapper<SanctionListIndividualDateOfBirthNodeConnection>;
  SanctionListIndividualDateOfBirthNodeEdge: ResolverTypeWrapper<SanctionListIndividualDateOfBirthNodeEdge>;
  SanctionListIndividualDocumentNode: ResolverTypeWrapper<SanctionListIndividualDocumentNode>;
  SanctionListIndividualDocumentNodeConnection: ResolverTypeWrapper<SanctionListIndividualDocumentNodeConnection>;
  SanctionListIndividualDocumentNodeEdge: ResolverTypeWrapper<SanctionListIndividualDocumentNodeEdge>;
  SanctionListIndividualNationalitiesNode: ResolverTypeWrapper<SanctionListIndividualNationalitiesNode>;
  SanctionListIndividualNationalitiesNodeConnection: ResolverTypeWrapper<SanctionListIndividualNationalitiesNodeConnection>;
  SanctionListIndividualNationalitiesNodeEdge: ResolverTypeWrapper<SanctionListIndividualNationalitiesNodeEdge>;
  SanctionListIndividualNode: ResolverTypeWrapper<SanctionListIndividualNode>;
  SanctionListIndividualNodeConnection: ResolverTypeWrapper<SanctionListIndividualNodeConnection>;
  SanctionListIndividualNodeEdge: ResolverTypeWrapper<SanctionListIndividualNodeEdge>;
  SaveKoboProjectImportDataAsync: ResolverTypeWrapper<SaveKoboProjectImportDataAsync>;
  SectionTotalNode: ResolverTypeWrapper<SectionTotalNode>;
  SensitiveGrievanceTicketExtras: SensitiveGrievanceTicketExtras;
  ServiceProviderNode: ResolverTypeWrapper<ServiceProviderNode>;
  ServiceProviderNodeConnection: ResolverTypeWrapper<ServiceProviderNodeConnection>;
  ServiceProviderNodeEdge: ResolverTypeWrapper<ServiceProviderNodeEdge>;
  SetSteficonRuleOnPaymentPlanPaymentListMutation: ResolverTypeWrapper<SetSteficonRuleOnPaymentPlanPaymentListMutation>;
  SetSteficonRuleOnTargetPopulationMutationInput: SetSteficonRuleOnTargetPopulationMutationInput;
  SetSteficonRuleOnTargetPopulationMutationPayload: ResolverTypeWrapper<SetSteficonRuleOnTargetPopulationMutationPayload>;
  SimpleApproveMutation: ResolverTypeWrapper<SimpleApproveMutation>;
  SplitPaymentPlanMutation: ResolverTypeWrapper<SplitPaymentPlanMutation>;
  SteficonRuleNode: ResolverTypeWrapper<SteficonRuleNode>;
  SteficonRuleNodeConnection: ResolverTypeWrapper<SteficonRuleNodeConnection>;
  SteficonRuleNodeEdge: ResolverTypeWrapper<SteficonRuleNodeEdge>;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  SurveyCategory: SurveyCategory;
  SurveyNode: ResolverTypeWrapper<SurveyNode>;
  SurveyNodeConnection: ResolverTypeWrapper<SurveyNodeConnection>;
  SurveyNodeEdge: ResolverTypeWrapper<SurveyNodeEdge>;
  SurveySamplingType: SurveySamplingType;
  TableTotalCashTransferred: ResolverTypeWrapper<TableTotalCashTransferred>;
  TargetPopulationBuildStatus: TargetPopulationBuildStatus;
  TargetPopulationNode: ResolverTypeWrapper<TargetPopulationNode>;
  TargetPopulationNodeConnection: ResolverTypeWrapper<TargetPopulationNodeConnection>;
  TargetPopulationNodeEdge: ResolverTypeWrapper<TargetPopulationNodeEdge>;
  TargetPopulationStatus: TargetPopulationStatus;
  TargetingCriteriaNode: ResolverTypeWrapper<TargetingCriteriaNode>;
  TargetingCriteriaObjectType: TargetingCriteriaObjectType;
  TargetingCriteriaRuleFilterComparisonMethod: TargetingCriteriaRuleFilterComparisonMethod;
  TargetingCriteriaRuleFilterNode: ResolverTypeWrapper<TargetingCriteriaRuleFilterNode>;
  TargetingCriteriaRuleFilterObjectType: TargetingCriteriaRuleFilterObjectType;
  TargetingCriteriaRuleNode: ResolverTypeWrapper<TargetingCriteriaRuleNode>;
  TargetingCriteriaRuleObjectType: TargetingCriteriaRuleObjectType;
  TargetingIndividualBlockRuleFilterComparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod;
  TargetingIndividualBlockRuleFilterNode: ResolverTypeWrapper<TargetingIndividualBlockRuleFilterNode>;
  TargetingIndividualRuleFilterBlockNode: ResolverTypeWrapper<TargetingIndividualRuleFilterBlockNode>;
  TargetingIndividualRuleFilterBlockObjectType: TargetingIndividualRuleFilterBlockObjectType;
  TicketAddIndividualDetailsNode: ResolverTypeWrapper<TicketAddIndividualDetailsNode>;
  TicketAddIndividualDetailsNodeConnection: ResolverTypeWrapper<TicketAddIndividualDetailsNodeConnection>;
  TicketAddIndividualDetailsNodeEdge: ResolverTypeWrapper<TicketAddIndividualDetailsNodeEdge>;
  TicketByType: ResolverTypeWrapper<TicketByType>;
  TicketComplaintDetailsNode: ResolverTypeWrapper<TicketComplaintDetailsNode>;
  TicketComplaintDetailsNodeConnection: ResolverTypeWrapper<TicketComplaintDetailsNodeConnection>;
  TicketComplaintDetailsNodeEdge: ResolverTypeWrapper<TicketComplaintDetailsNodeEdge>;
  TicketDeleteHouseholdDetailsNode: ResolverTypeWrapper<TicketDeleteHouseholdDetailsNode>;
  TicketDeleteHouseholdDetailsNodeConnection: ResolverTypeWrapper<TicketDeleteHouseholdDetailsNodeConnection>;
  TicketDeleteHouseholdDetailsNodeEdge: ResolverTypeWrapper<TicketDeleteHouseholdDetailsNodeEdge>;
  TicketDeleteIndividualDetailsNode: ResolverTypeWrapper<TicketDeleteIndividualDetailsNode>;
  TicketDeleteIndividualDetailsNodeConnection: ResolverTypeWrapper<TicketDeleteIndividualDetailsNodeConnection>;
  TicketDeleteIndividualDetailsNodeEdge: ResolverTypeWrapper<TicketDeleteIndividualDetailsNodeEdge>;
  TicketHouseholdDataUpdateDetailsNode: ResolverTypeWrapper<TicketHouseholdDataUpdateDetailsNode>;
  TicketHouseholdDataUpdateDetailsNodeConnection: ResolverTypeWrapper<TicketHouseholdDataUpdateDetailsNodeConnection>;
  TicketHouseholdDataUpdateDetailsNodeEdge: ResolverTypeWrapper<TicketHouseholdDataUpdateDetailsNodeEdge>;
  TicketIndividualDataUpdateDetailsNode: ResolverTypeWrapper<TicketIndividualDataUpdateDetailsNode>;
  TicketIndividualDataUpdateDetailsNodeConnection: ResolverTypeWrapper<TicketIndividualDataUpdateDetailsNodeConnection>;
  TicketIndividualDataUpdateDetailsNodeEdge: ResolverTypeWrapper<TicketIndividualDataUpdateDetailsNodeEdge>;
  TicketNeedsAdjudicationDetailsExtraDataNode: ResolverTypeWrapper<TicketNeedsAdjudicationDetailsExtraDataNode>;
  TicketNeedsAdjudicationDetailsNode: ResolverTypeWrapper<TicketNeedsAdjudicationDetailsNode>;
  TicketNeedsAdjudicationDetailsNodeConnection: ResolverTypeWrapper<TicketNeedsAdjudicationDetailsNodeConnection>;
  TicketNeedsAdjudicationDetailsNodeEdge: ResolverTypeWrapper<TicketNeedsAdjudicationDetailsNodeEdge>;
  TicketNegativeFeedbackDetailsNode: ResolverTypeWrapper<TicketNegativeFeedbackDetailsNode>;
  TicketNegativeFeedbackDetailsNodeConnection: ResolverTypeWrapper<TicketNegativeFeedbackDetailsNodeConnection>;
  TicketNegativeFeedbackDetailsNodeEdge: ResolverTypeWrapper<TicketNegativeFeedbackDetailsNodeEdge>;
  TicketNoteNode: ResolverTypeWrapper<TicketNoteNode>;
  TicketNoteNodeConnection: ResolverTypeWrapper<TicketNoteNodeConnection>;
  TicketNoteNodeEdge: ResolverTypeWrapper<TicketNoteNodeEdge>;
  TicketPaymentVerificationDetailsExtras: TicketPaymentVerificationDetailsExtras;
  TicketPaymentVerificationDetailsNewStatus: TicketPaymentVerificationDetailsNewStatus;
  TicketPaymentVerificationDetailsNode: ResolverTypeWrapper<TicketPaymentVerificationDetailsNode>;
  TicketPaymentVerificationDetailsNodeConnection: ResolverTypeWrapper<TicketPaymentVerificationDetailsNodeConnection>;
  TicketPaymentVerificationDetailsNodeEdge: ResolverTypeWrapper<TicketPaymentVerificationDetailsNodeEdge>;
  TicketPaymentVerificationDetailsPaymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus;
  TicketPositiveFeedbackDetailsNode: ResolverTypeWrapper<TicketPositiveFeedbackDetailsNode>;
  TicketPositiveFeedbackDetailsNodeConnection: ResolverTypeWrapper<TicketPositiveFeedbackDetailsNodeConnection>;
  TicketPositiveFeedbackDetailsNodeEdge: ResolverTypeWrapper<TicketPositiveFeedbackDetailsNodeEdge>;
  TicketReferralDetailsNode: ResolverTypeWrapper<TicketReferralDetailsNode>;
  TicketReferralDetailsNodeConnection: ResolverTypeWrapper<TicketReferralDetailsNodeConnection>;
  TicketReferralDetailsNodeEdge: ResolverTypeWrapper<TicketReferralDetailsNodeEdge>;
  TicketSensitiveDetailsNode: ResolverTypeWrapper<TicketSensitiveDetailsNode>;
  TicketSensitiveDetailsNodeConnection: ResolverTypeWrapper<TicketSensitiveDetailsNodeConnection>;
  TicketSensitiveDetailsNodeEdge: ResolverTypeWrapper<TicketSensitiveDetailsNodeEdge>;
  TicketSystemFlaggingDetailsNode: ResolverTypeWrapper<TicketSystemFlaggingDetailsNode>;
  TicketSystemFlaggingDetailsNodeConnection: ResolverTypeWrapper<TicketSystemFlaggingDetailsNodeConnection>;
  TicketSystemFlaggingDetailsNodeEdge: ResolverTypeWrapper<TicketSystemFlaggingDetailsNodeEdge>;
  UUID: ResolverTypeWrapper<Scalars['UUID']['output']>;
  UnlockTargetPopulationMutation: ResolverTypeWrapper<UnlockTargetPopulationMutation>;
  UpdateAddIndividualIssueTypeExtras: UpdateAddIndividualIssueTypeExtras;
  UpdateFeedbackInput: UpdateFeedbackInput;
  UpdateFeedbackMutation: ResolverTypeWrapper<UpdateFeedbackMutation>;
  UpdateGrievanceTicketExtrasInput: UpdateGrievanceTicketExtrasInput;
  UpdateGrievanceTicketInput: UpdateGrievanceTicketInput;
  UpdateGrievanceTicketMutation: ResolverTypeWrapper<UpdateGrievanceTicketMutation>;
  UpdateHouseholdDataUpdateIssueTypeExtras: UpdateHouseholdDataUpdateIssueTypeExtras;
  UpdateIndividualDataUpdateIssueTypeExtras: UpdateIndividualDataUpdateIssueTypeExtras;
  UpdatePaymentPlanInput: UpdatePaymentPlanInput;
  UpdatePaymentPlanMutation: ResolverTypeWrapper<UpdatePaymentPlanMutation>;
  UpdatePaymentVerificationReceivedAndReceivedAmount: ResolverTypeWrapper<UpdatePaymentVerificationReceivedAndReceivedAmount>;
  UpdatePaymentVerificationStatusAndReceivedAmount: ResolverTypeWrapper<UpdatePaymentVerificationStatusAndReceivedAmount>;
  UpdateProgram: ResolverTypeWrapper<UpdateProgram>;
  UpdateProgramInput: UpdateProgramInput;
  UpdateTargetPopulationInput: UpdateTargetPopulationInput;
  UpdateTargetPopulationMutation: ResolverTypeWrapper<UpdateTargetPopulationMutation>;
  Upload: ResolverTypeWrapper<Scalars['Upload']['output']>;
  UploadImportDataXLSXFileAsync: ResolverTypeWrapper<UploadImportDataXlsxFileAsync>;
  UserBusinessAreaNode: ResolverTypeWrapper<UserBusinessAreaNode>;
  UserBusinessAreaNodeConnection: ResolverTypeWrapper<UserBusinessAreaNodeConnection>;
  UserBusinessAreaNodeEdge: ResolverTypeWrapper<UserBusinessAreaNodeEdge>;
  UserNode: ResolverTypeWrapper<UserNode>;
  UserNodeConnection: ResolverTypeWrapper<UserNodeConnection>;
  UserNodeEdge: ResolverTypeWrapper<UserNodeEdge>;
  UserRoleNode: ResolverTypeWrapper<UserRoleNode>;
  UserStatus: UserStatus;
  VolumeByDeliveryMechanismNode: ResolverTypeWrapper<VolumeByDeliveryMechanismNode>;
  XlsxErrorNode: ResolverTypeWrapper<XlsxErrorNode>;
  XlsxRowErrorNode: ResolverTypeWrapper<XlsxRowErrorNode>;
  _DatasetsNode: ResolverTypeWrapper<_DatasetsNode>;
  _DetailedDatasetsNode: ResolverTypeWrapper<_DetailedDatasetsNode>;
  _TableTotalCashTransferredDataNode: ResolverTypeWrapper<_TableTotalCashTransferredDataNode>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AccountabilityCommunicationMessageAgeInput: AccountabilityCommunicationMessageAgeInput;
  AccountabilityFullListArguments: AccountabilityFullListArguments;
  AccountabilityRandomSamplingArguments: AccountabilityRandomSamplingArguments;
  AccountabilitySampleSizeInput: AccountabilitySampleSizeInput;
  AccountabilitySampleSizeNode: AccountabilitySampleSizeNode;
  ActionPaymentPlanInput: ActionPaymentPlanInput;
  ActionPaymentPlanMutation: ActionPaymentPlanMutation;
  ActivatePaymentVerificationPlan: ActivatePaymentVerificationPlan;
  AddIndividualDataObjectType: AddIndividualDataObjectType;
  AddIndividualIssueTypeExtras: AddIndividualIssueTypeExtras;
  AgeFilterObject: AgeFilterObject;
  AgeInput: AgeInput;
  ApprovalNode: ApprovalNode;
  ApprovalProcessNode: ApprovalProcessNode;
  ApprovalProcessNodeConnection: ApprovalProcessNodeConnection;
  ApprovalProcessNodeEdge: ApprovalProcessNodeEdge;
  AreaGroupNode: AreaGroupNode;
  AreaNode: AreaNode;
  AreaNodeConnection: AreaNodeConnection;
  AreaNodeEdge: AreaNodeEdge;
  AreaTreeNode: AreaTreeNode;
  AreaTypeNode: AreaTypeNode;
  AreaTypeNodeConnection: AreaTypeNodeConnection;
  AreaTypeNodeEdge: AreaTypeNodeEdge;
  Arg: Scalars['Arg']['output'];
  AssignFspToDeliveryMechanismInput: AssignFspToDeliveryMechanismInput;
  AssignFspToDeliveryMechanismMutation: AssignFspToDeliveryMechanismMutation;
  AvailableFspsForDeliveryMechanismsInput: AvailableFspsForDeliveryMechanismsInput;
  BankAccountInfoNode: BankAccountInfoNode;
  BankAccountInfoNodeConnection: BankAccountInfoNodeConnection;
  BankAccountInfoNodeEdge: BankAccountInfoNodeEdge;
  BankTransferObjectType: BankTransferObjectType;
  BigInt: Scalars['BigInt']['output'];
  Boolean: Scalars['Boolean']['output'];
  BulkGrievanceAddNoteMutation: BulkGrievanceAddNoteMutation;
  BulkUpdateGrievanceTicketsAssigneesMutation: BulkUpdateGrievanceTicketsAssigneesMutation;
  BulkUpdateGrievanceTicketsPriorityMutation: BulkUpdateGrievanceTicketsPriorityMutation;
  BulkUpdateGrievanceTicketsUrgencyMutation: BulkUpdateGrievanceTicketsUrgencyMutation;
  BusinessAreaNode: BusinessAreaNode;
  BusinessAreaNodeConnection: BusinessAreaNodeConnection;
  BusinessAreaNodeEdge: BusinessAreaNodeEdge;
  CashPlanAndPaymentPlanEdges: CashPlanAndPaymentPlanEdges;
  CashPlanAndPaymentPlanNode: CashPlanAndPaymentPlanNode;
  CashPlanNode: CashPlanNode;
  CashPlanNodeConnection: CashPlanNodeConnection;
  CashPlanNodeEdge: CashPlanNodeEdge;
  CategoryExtrasInput: CategoryExtrasInput;
  ChartDatasetNode: ChartDatasetNode;
  ChartDetailedDatasetsNode: ChartDetailedDatasetsNode;
  ChartGrievanceTicketsNode: ChartGrievanceTicketsNode;
  ChartPaymentVerification: ChartPaymentVerification;
  CheckAgainstSanctionListMutation: CheckAgainstSanctionListMutation;
  ChoiceObject: ChoiceObject;
  ChoiceObjectInt: ChoiceObjectInt;
  ChooseDeliveryMechanismsForPaymentPlanInput: ChooseDeliveryMechanismsForPaymentPlanInput;
  ChooseDeliveryMechanismsForPaymentPlanMutation: ChooseDeliveryMechanismsForPaymentPlanMutation;
  CommunicationMessageNode: CommunicationMessageNode;
  CommunicationMessageNodeConnection: CommunicationMessageNodeConnection;
  CommunicationMessageNodeEdge: CommunicationMessageNodeEdge;
  CommunicationMessageRecipientMapNode: CommunicationMessageRecipientMapNode;
  CommunicationMessageRecipientMapNodeConnection: CommunicationMessageRecipientMapNodeConnection;
  CommunicationMessageRecipientMapNodeEdge: CommunicationMessageRecipientMapNodeEdge;
  ContentTypeObjectType: ContentTypeObjectType;
  CopyProgram: CopyProgram;
  CopyProgramInput: CopyProgramInput;
  CopyTargetPopulationInput: CopyTargetPopulationInput;
  CopyTargetPopulationMutationInput: CopyTargetPopulationMutationInput;
  CopyTargetPopulationMutationPayload: CopyTargetPopulationMutationPayload;
  CoreFieldChoiceObject: CoreFieldChoiceObject;
  CountAndPercentageNode: CountAndPercentageNode;
  CreateAccountabilityCommunicationMessageInput: CreateAccountabilityCommunicationMessageInput;
  CreateCommunicationMessageMutation: CreateCommunicationMessageMutation;
  CreateDashboardReport: CreateDashboardReport;
  CreateDashboardReportInput: CreateDashboardReportInput;
  CreateFeedbackInput: CreateFeedbackInput;
  CreateFeedbackMessageInput: CreateFeedbackMessageInput;
  CreateFeedbackMessageMutation: CreateFeedbackMessageMutation;
  CreateFeedbackMutation: CreateFeedbackMutation;
  CreateFollowUpPaymentPlanMutation: CreateFollowUpPaymentPlanMutation;
  CreateGrievanceTicketExtrasInput: CreateGrievanceTicketExtrasInput;
  CreateGrievanceTicketInput: CreateGrievanceTicketInput;
  CreateGrievanceTicketMutation: CreateGrievanceTicketMutation;
  CreatePaymentPlanInput: CreatePaymentPlanInput;
  CreatePaymentPlanMutation: CreatePaymentPlanMutation;
  CreatePaymentVerificationInput: CreatePaymentVerificationInput;
  CreateProgram: CreateProgram;
  CreateProgramInput: CreateProgramInput;
  CreateReport: CreateReport;
  CreateReportInput: CreateReportInput;
  CreateSurveyInput: CreateSurveyInput;
  CreateSurveyMutation: CreateSurveyMutation;
  CreateTargetPopulationInput: CreateTargetPopulationInput;
  CreateTargetPopulationMutation: CreateTargetPopulationMutation;
  CreateTicketNoteInput: CreateTicketNoteInput;
  CreateTicketNoteMutation: CreateTicketNoteMutation;
  CreateVerificationPlanMutation: CreateVerificationPlanMutation;
  DataCollectingTypeChoiceObject: DataCollectingTypeChoiceObject;
  DataCollectingTypeNode: DataCollectingTypeNode;
  DataCollectingTypeNodeConnection: DataCollectingTypeNodeConnection;
  DataCollectingTypeNodeEdge: DataCollectingTypeNodeEdge;
  Date: Scalars['Date']['output'];
  DateTime: Scalars['DateTime']['output'];
  Decimal: Scalars['Decimal']['output'];
  DeduplicationResultNode: DeduplicationResultNode;
  DeleteHouseholdApproveMutation: DeleteHouseholdApproveMutation;
  DeletePaymentPlanMutation: DeletePaymentPlanMutation;
  DeletePaymentVerificationPlan: DeletePaymentVerificationPlan;
  DeleteProgram: DeleteProgram;
  DeleteRegistrationDataImport: DeleteRegistrationDataImport;
  DeleteTargetPopulationMutationInput: DeleteTargetPopulationMutationInput;
  DeleteTargetPopulationMutationPayload: DeleteTargetPopulationMutationPayload;
  DeliveredQuantityNode: DeliveredQuantityNode;
  DeliveryMechanismNode: DeliveryMechanismNode;
  DeliveryMechanismNodeConnection: DeliveryMechanismNodeConnection;
  DeliveryMechanismNodeEdge: DeliveryMechanismNodeEdge;
  DiscardPaymentVerificationPlan: DiscardPaymentVerificationPlan;
  DjangoDebug: DjangoDebug;
  DjangoDebugSQL: DjangoDebugSql;
  DocumentNode: DocumentNode;
  DocumentNodeConnection: DocumentNodeConnection;
  DocumentNodeEdge: DocumentNodeEdge;
  DocumentTypeNode: DocumentTypeNode;
  EditBankTransferObjectType: EditBankTransferObjectType;
  EditIndividualDocumentObjectType: EditIndividualDocumentObjectType;
  EditIndividualIdentityObjectType: EditIndividualIdentityObjectType;
  EditPaymentVerificationInput: EditPaymentVerificationInput;
  EditPaymentVerificationMutation: EditPaymentVerificationMutation;
  EraseRegistrationDataImportMutation: EraseRegistrationDataImportMutation;
  ExcludeHouseholdsMutation: ExcludeHouseholdsMutation;
  ExportPDFPaymentPlanSummaryMutation: ExportPdfPaymentPlanSummaryMutation;
  ExportSurveySampleMutationMutation: ExportSurveySampleMutationMutation;
  ExportXLSXPaymentPlanPaymentListMutation: ExportXlsxPaymentPlanPaymentListMutation;
  ExportXLSXPaymentPlanPaymentListPerFSPMutation: ExportXlsxPaymentPlanPaymentListPerFspMutation;
  ExportXlsxPaymentVerificationPlanFile: ExportXlsxPaymentVerificationPlanFile;
  FSPToDeliveryMechanismMappingInput: FspToDeliveryMechanismMappingInput;
  FeedbackMessageNode: FeedbackMessageNode;
  FeedbackMessageNodeConnection: FeedbackMessageNodeConnection;
  FeedbackMessageNodeEdge: FeedbackMessageNodeEdge;
  FeedbackNode: FeedbackNode;
  FeedbackNodeConnection: FeedbackNodeConnection;
  FeedbackNodeEdge: FeedbackNodeEdge;
  FieldAttributeNode: FieldAttributeNode;
  FilteredActionsListNode: FilteredActionsListNode;
  FinalizeTargetPopulationMutation: FinalizeTargetPopulationMutation;
  FinancialServiceProviderNode: FinancialServiceProviderNode;
  FinancialServiceProviderNodeConnection: FinancialServiceProviderNodeConnection;
  FinancialServiceProviderNodeEdge: FinancialServiceProviderNodeEdge;
  FinancialServiceProviderXlsxReportNode: FinancialServiceProviderXlsxReportNode;
  FinancialServiceProviderXlsxReportNodeConnection: FinancialServiceProviderXlsxReportNodeConnection;
  FinancialServiceProviderXlsxReportNodeEdge: FinancialServiceProviderXlsxReportNodeEdge;
  FinancialServiceProviderXlsxTemplateNode: FinancialServiceProviderXlsxTemplateNode;
  FinancialServiceProviderXlsxTemplateNodeConnection: FinancialServiceProviderXlsxTemplateNodeConnection;
  FinancialServiceProviderXlsxTemplateNodeEdge: FinancialServiceProviderXlsxTemplateNodeEdge;
  FinishPaymentVerificationPlan: FinishPaymentVerificationPlan;
  FlexFieldsScalar: Scalars['FlexFieldsScalar']['output'];
  Float: Scalars['Float']['output'];
  FspChoice: FspChoice;
  FspChoices: FspChoices;
  FspConfiguration: FspConfiguration;
  FullListArguments: FullListArguments;
  GenericPaymentNode: GenericPaymentNode;
  GenericPaymentPlanNode: GenericPaymentPlanNode;
  GeoJSON: Scalars['GeoJSON']['output'];
  GetAccountabilityCommunicationMessageSampleSizeInput: GetAccountabilityCommunicationMessageSampleSizeInput;
  GetCashplanVerificationSampleSizeInput: GetCashplanVerificationSampleSizeInput;
  GetCashplanVerificationSampleSizeObject: GetCashplanVerificationSampleSizeObject;
  GetCommunicationMessageSampleSizeNode: GetCommunicationMessageSampleSizeNode;
  GrievanceComplaintTicketExtras: GrievanceComplaintTicketExtras;
  GrievanceDocumentInput: GrievanceDocumentInput;
  GrievanceDocumentNode: GrievanceDocumentNode;
  GrievanceDocumentNodeConnection: GrievanceDocumentNodeConnection;
  GrievanceDocumentNodeEdge: GrievanceDocumentNodeEdge;
  GrievanceDocumentUpdateInput: GrievanceDocumentUpdateInput;
  GrievanceStatusChangeMutation: GrievanceStatusChangeMutation;
  GrievanceTicketNode: GrievanceTicketNode;
  GrievanceTicketNodeConnection: GrievanceTicketNodeConnection;
  GrievanceTicketNodeEdge: GrievanceTicketNodeEdge;
  GroupAttributeNode: GroupAttributeNode;
  HouseholdDataChangeApproveMutation: HouseholdDataChangeApproveMutation;
  HouseholdDataUpdateIssueTypeExtras: HouseholdDataUpdateIssueTypeExtras;
  HouseholdDeleteIssueTypeExtras: HouseholdDeleteIssueTypeExtras;
  HouseholdNode: HouseholdNode;
  HouseholdNodeConnection: HouseholdNodeConnection;
  HouseholdNodeEdge: HouseholdNodeEdge;
  HouseholdSelectionNode: HouseholdSelectionNode;
  HouseholdUpdateDataObjectType: HouseholdUpdateDataObjectType;
  ID: Scalars['ID']['output'];
  ImportDataNode: ImportDataNode;
  ImportXLSXPaymentPlanPaymentListMutation: ImportXlsxPaymentPlanPaymentListMutation;
  ImportXLSXPaymentPlanPaymentListPerFSPMutation: ImportXlsxPaymentPlanPaymentListPerFspMutation;
  ImportXlsxPaymentVerificationPlanFile: ImportXlsxPaymentVerificationPlanFile;
  ImportedDocumentNode: ImportedDocumentNode;
  ImportedDocumentNodeConnection: ImportedDocumentNodeConnection;
  ImportedDocumentNodeEdge: ImportedDocumentNodeEdge;
  ImportedDocumentTypeNode: ImportedDocumentTypeNode;
  ImportedHouseholdNode: ImportedHouseholdNode;
  ImportedHouseholdNodeConnection: ImportedHouseholdNodeConnection;
  ImportedHouseholdNodeEdge: ImportedHouseholdNodeEdge;
  ImportedIndividualIdentityNode: ImportedIndividualIdentityNode;
  ImportedIndividualIdentityNodeConnection: ImportedIndividualIdentityNodeConnection;
  ImportedIndividualIdentityNodeEdge: ImportedIndividualIdentityNodeEdge;
  ImportedIndividualNode: ImportedIndividualNode;
  ImportedIndividualNodeConnection: ImportedIndividualNodeConnection;
  ImportedIndividualNodeEdge: ImportedIndividualNodeEdge;
  IndividualDataChangeApproveMutation: IndividualDataChangeApproveMutation;
  IndividualDataUpdateIssueTypeExtras: IndividualDataUpdateIssueTypeExtras;
  IndividualDeleteIssueTypeExtras: IndividualDeleteIssueTypeExtras;
  IndividualDocumentObjectType: IndividualDocumentObjectType;
  IndividualIdentityNode: IndividualIdentityNode;
  IndividualIdentityNodeConnection: IndividualIdentityNodeConnection;
  IndividualIdentityNodeEdge: IndividualIdentityNodeEdge;
  IndividualIdentityObjectType: IndividualIdentityObjectType;
  IndividualNode: IndividualNode;
  IndividualNodeConnection: IndividualNodeConnection;
  IndividualNodeEdge: IndividualNodeEdge;
  IndividualRoleInHouseholdNode: IndividualRoleInHouseholdNode;
  IndividualUpdateDataObjectType: IndividualUpdateDataObjectType;
  Int: Scalars['Int']['output'];
  InvalidPaymentVerificationPlan: InvalidPaymentVerificationPlan;
  IssueTypeExtrasInput: IssueTypeExtrasInput;
  IssueTypesObject: IssueTypesObject;
  JSONString: Scalars['JSONString']['output'];
  KoboAssetObject: KoboAssetObject;
  KoboAssetObjectConnection: KoboAssetObjectConnection;
  KoboAssetObjectEdge: KoboAssetObjectEdge;
  KoboErrorNode: KoboErrorNode;
  KoboImportDataNode: KoboImportDataNode;
  LabelNode: LabelNode;
  LanguageObject: LanguageObject;
  LanguageObjectConnection: LanguageObjectConnection;
  LanguageObjectEdge: LanguageObjectEdge;
  LockTargetPopulationMutation: LockTargetPopulationMutation;
  LogEntryNode: LogEntryNode;
  LogEntryNodeConnection: LogEntryNodeConnection;
  LogEntryNodeEdge: LogEntryNodeEdge;
  MarkPaymentAsFailedMutation: MarkPaymentAsFailedMutation;
  MarkPaymentRecordAsFailedMutation: MarkPaymentRecordAsFailedMutation;
  MergeRegistrationDataImportMutation: MergeRegistrationDataImportMutation;
  Mutations: {};
  NeedsAdjudicationApproveMutation: NeedsAdjudicationApproveMutation;
  NegativeFeedbackTicketExtras: NegativeFeedbackTicketExtras;
  Node: ResolversInterfaceTypes<ResolversParentTypes>['Node'];
  PageInfo: PageInfo;
  PageInfoNode: PageInfoNode;
  PaginatedCashPlanAndPaymentPlanNode: PaginatedCashPlanAndPaymentPlanNode;
  PaginatedPaymentRecordsAndPaymentsNode: PaginatedPaymentRecordsAndPaymentsNode;
  PartnerNodeForProgram: PartnerNodeForProgram;
  PartnerProgramInput: PartnerProgramInput;
  PartnerType: PartnerType;
  PaymentConflictDataNode: PaymentConflictDataNode;
  PaymentDetailsApproveMutation: PaymentDetailsApproveMutation;
  PaymentHouseholdSnapshotNode: PaymentHouseholdSnapshotNode;
  PaymentNode: PaymentNode;
  PaymentNodeConnection: PaymentNodeConnection;
  PaymentNodeEdge: PaymentNodeEdge;
  PaymentPlanNode: PaymentPlanNode;
  PaymentPlanNodeConnection: PaymentPlanNodeConnection;
  PaymentPlanNodeEdge: PaymentPlanNodeEdge;
  PaymentRecordAndPaymentNode: PaymentRecordAndPaymentNode;
  PaymentRecordNode: PaymentRecordNode;
  PaymentRecordNodeConnection: PaymentRecordNodeConnection;
  PaymentRecordNodeEdge: PaymentRecordNodeEdge;
  PaymentRecordsAndPaymentsEdges: PaymentRecordsAndPaymentsEdges;
  PaymentVerificationLogEntryNode: PaymentVerificationLogEntryNode;
  PaymentVerificationLogEntryNodeConnection: PaymentVerificationLogEntryNodeConnection;
  PaymentVerificationLogEntryNodeEdge: PaymentVerificationLogEntryNodeEdge;
  PaymentVerificationNode: PaymentVerificationNode;
  PaymentVerificationNodeConnection: PaymentVerificationNodeConnection;
  PaymentVerificationNodeEdge: PaymentVerificationNodeEdge;
  PaymentVerificationPlanNode: PaymentVerificationPlanNode;
  PaymentVerificationPlanNodeConnection: PaymentVerificationPlanNodeConnection;
  PaymentVerificationPlanNodeEdge: PaymentVerificationPlanNodeEdge;
  PaymentVerificationSummaryNode: PaymentVerificationSummaryNode;
  PaymentVerificationSummaryNodeConnection: PaymentVerificationSummaryNodeConnection;
  PaymentVerificationSummaryNodeEdge: PaymentVerificationSummaryNodeEdge;
  PositiveFeedbackTicketExtras: PositiveFeedbackTicketExtras;
  ProgramNode: ProgramNode;
  ProgramNodeConnection: ProgramNodeConnection;
  ProgramNodeEdge: ProgramNodeEdge;
  Query: {};
  RandomSamplingArguments: RandomSamplingArguments;
  RapidProArguments: RapidProArguments;
  RapidProFlow: RapidProFlow;
  RapidProFlowNode: RapidProFlowNode;
  RapidProFlowResult: RapidProFlowResult;
  RapidProFlowRun: RapidProFlowRun;
  ReassignRoleMutation: ReassignRoleMutation;
  RebuildTargetPopulationMutation: RebuildTargetPopulationMutation;
  RecipientNode: RecipientNode;
  RecipientNodeConnection: RecipientNodeConnection;
  RecipientNodeEdge: RecipientNodeEdge;
  ReconciliationSummaryNode: ReconciliationSummaryNode;
  ReferralTicketExtras: ReferralTicketExtras;
  RefuseRegistrationDataImportMutation: RefuseRegistrationDataImportMutation;
  RegistrationDataImportDatahubNode: RegistrationDataImportDatahubNode;
  RegistrationDataImportDatahubNodeConnection: RegistrationDataImportDatahubNodeConnection;
  RegistrationDataImportDatahubNodeEdge: RegistrationDataImportDatahubNodeEdge;
  RegistrationDataImportNode: RegistrationDataImportNode;
  RegistrationDataImportNodeConnection: RegistrationDataImportNodeConnection;
  RegistrationDataImportNodeEdge: RegistrationDataImportNodeEdge;
  RegistrationDeduplicationMutation: RegistrationDeduplicationMutation;
  RegistrationKoboImportMutation: RegistrationKoboImportMutation;
  RegistrationKoboImportMutationInput: RegistrationKoboImportMutationInput;
  RegistrationXlsxImportMutation: RegistrationXlsxImportMutation;
  RegistrationXlsxImportMutationInput: RegistrationXlsxImportMutationInput;
  ReportNode: ReportNode;
  ReportNodeConnection: ReportNodeConnection;
  ReportNodeEdge: ReportNodeEdge;
  RestartCreateReport: RestartCreateReport;
  RestartCreateReportInput: RestartCreateReportInput;
  RevertMarkPaymentAsFailedMutation: RevertMarkPaymentAsFailedMutation;
  RevertMarkPaymentRecordAsFailedMutation: RevertMarkPaymentRecordAsFailedMutation;
  RoleChoiceObject: RoleChoiceObject;
  RoleNode: RoleNode;
  RuleCommitNode: RuleCommitNode;
  RuleCommitNodeConnection: RuleCommitNodeConnection;
  RuleCommitNodeEdge: RuleCommitNodeEdge;
  SanctionListIndividualAliasNameNode: SanctionListIndividualAliasNameNode;
  SanctionListIndividualAliasNameNodeConnection: SanctionListIndividualAliasNameNodeConnection;
  SanctionListIndividualAliasNameNodeEdge: SanctionListIndividualAliasNameNodeEdge;
  SanctionListIndividualCountriesNode: SanctionListIndividualCountriesNode;
  SanctionListIndividualCountriesNodeConnection: SanctionListIndividualCountriesNodeConnection;
  SanctionListIndividualCountriesNodeEdge: SanctionListIndividualCountriesNodeEdge;
  SanctionListIndividualDateOfBirthNode: SanctionListIndividualDateOfBirthNode;
  SanctionListIndividualDateOfBirthNodeConnection: SanctionListIndividualDateOfBirthNodeConnection;
  SanctionListIndividualDateOfBirthNodeEdge: SanctionListIndividualDateOfBirthNodeEdge;
  SanctionListIndividualDocumentNode: SanctionListIndividualDocumentNode;
  SanctionListIndividualDocumentNodeConnection: SanctionListIndividualDocumentNodeConnection;
  SanctionListIndividualDocumentNodeEdge: SanctionListIndividualDocumentNodeEdge;
  SanctionListIndividualNationalitiesNode: SanctionListIndividualNationalitiesNode;
  SanctionListIndividualNationalitiesNodeConnection: SanctionListIndividualNationalitiesNodeConnection;
  SanctionListIndividualNationalitiesNodeEdge: SanctionListIndividualNationalitiesNodeEdge;
  SanctionListIndividualNode: SanctionListIndividualNode;
  SanctionListIndividualNodeConnection: SanctionListIndividualNodeConnection;
  SanctionListIndividualNodeEdge: SanctionListIndividualNodeEdge;
  SaveKoboProjectImportDataAsync: SaveKoboProjectImportDataAsync;
  SectionTotalNode: SectionTotalNode;
  SensitiveGrievanceTicketExtras: SensitiveGrievanceTicketExtras;
  ServiceProviderNode: ServiceProviderNode;
  ServiceProviderNodeConnection: ServiceProviderNodeConnection;
  ServiceProviderNodeEdge: ServiceProviderNodeEdge;
  SetSteficonRuleOnPaymentPlanPaymentListMutation: SetSteficonRuleOnPaymentPlanPaymentListMutation;
  SetSteficonRuleOnTargetPopulationMutationInput: SetSteficonRuleOnTargetPopulationMutationInput;
  SetSteficonRuleOnTargetPopulationMutationPayload: SetSteficonRuleOnTargetPopulationMutationPayload;
  SimpleApproveMutation: SimpleApproveMutation;
  SplitPaymentPlanMutation: SplitPaymentPlanMutation;
  SteficonRuleNode: SteficonRuleNode;
  SteficonRuleNodeConnection: SteficonRuleNodeConnection;
  SteficonRuleNodeEdge: SteficonRuleNodeEdge;
  String: Scalars['String']['output'];
  SurveyNode: SurveyNode;
  SurveyNodeConnection: SurveyNodeConnection;
  SurveyNodeEdge: SurveyNodeEdge;
  TableTotalCashTransferred: TableTotalCashTransferred;
  TargetPopulationNode: TargetPopulationNode;
  TargetPopulationNodeConnection: TargetPopulationNodeConnection;
  TargetPopulationNodeEdge: TargetPopulationNodeEdge;
  TargetingCriteriaNode: TargetingCriteriaNode;
  TargetingCriteriaObjectType: TargetingCriteriaObjectType;
  TargetingCriteriaRuleFilterNode: TargetingCriteriaRuleFilterNode;
  TargetingCriteriaRuleFilterObjectType: TargetingCriteriaRuleFilterObjectType;
  TargetingCriteriaRuleNode: TargetingCriteriaRuleNode;
  TargetingCriteriaRuleObjectType: TargetingCriteriaRuleObjectType;
  TargetingIndividualBlockRuleFilterNode: TargetingIndividualBlockRuleFilterNode;
  TargetingIndividualRuleFilterBlockNode: TargetingIndividualRuleFilterBlockNode;
  TargetingIndividualRuleFilterBlockObjectType: TargetingIndividualRuleFilterBlockObjectType;
  TicketAddIndividualDetailsNode: TicketAddIndividualDetailsNode;
  TicketAddIndividualDetailsNodeConnection: TicketAddIndividualDetailsNodeConnection;
  TicketAddIndividualDetailsNodeEdge: TicketAddIndividualDetailsNodeEdge;
  TicketByType: TicketByType;
  TicketComplaintDetailsNode: TicketComplaintDetailsNode;
  TicketComplaintDetailsNodeConnection: TicketComplaintDetailsNodeConnection;
  TicketComplaintDetailsNodeEdge: TicketComplaintDetailsNodeEdge;
  TicketDeleteHouseholdDetailsNode: TicketDeleteHouseholdDetailsNode;
  TicketDeleteHouseholdDetailsNodeConnection: TicketDeleteHouseholdDetailsNodeConnection;
  TicketDeleteHouseholdDetailsNodeEdge: TicketDeleteHouseholdDetailsNodeEdge;
  TicketDeleteIndividualDetailsNode: TicketDeleteIndividualDetailsNode;
  TicketDeleteIndividualDetailsNodeConnection: TicketDeleteIndividualDetailsNodeConnection;
  TicketDeleteIndividualDetailsNodeEdge: TicketDeleteIndividualDetailsNodeEdge;
  TicketHouseholdDataUpdateDetailsNode: TicketHouseholdDataUpdateDetailsNode;
  TicketHouseholdDataUpdateDetailsNodeConnection: TicketHouseholdDataUpdateDetailsNodeConnection;
  TicketHouseholdDataUpdateDetailsNodeEdge: TicketHouseholdDataUpdateDetailsNodeEdge;
  TicketIndividualDataUpdateDetailsNode: TicketIndividualDataUpdateDetailsNode;
  TicketIndividualDataUpdateDetailsNodeConnection: TicketIndividualDataUpdateDetailsNodeConnection;
  TicketIndividualDataUpdateDetailsNodeEdge: TicketIndividualDataUpdateDetailsNodeEdge;
  TicketNeedsAdjudicationDetailsExtraDataNode: TicketNeedsAdjudicationDetailsExtraDataNode;
  TicketNeedsAdjudicationDetailsNode: TicketNeedsAdjudicationDetailsNode;
  TicketNeedsAdjudicationDetailsNodeConnection: TicketNeedsAdjudicationDetailsNodeConnection;
  TicketNeedsAdjudicationDetailsNodeEdge: TicketNeedsAdjudicationDetailsNodeEdge;
  TicketNegativeFeedbackDetailsNode: TicketNegativeFeedbackDetailsNode;
  TicketNegativeFeedbackDetailsNodeConnection: TicketNegativeFeedbackDetailsNodeConnection;
  TicketNegativeFeedbackDetailsNodeEdge: TicketNegativeFeedbackDetailsNodeEdge;
  TicketNoteNode: TicketNoteNode;
  TicketNoteNodeConnection: TicketNoteNodeConnection;
  TicketNoteNodeEdge: TicketNoteNodeEdge;
  TicketPaymentVerificationDetailsExtras: TicketPaymentVerificationDetailsExtras;
  TicketPaymentVerificationDetailsNode: TicketPaymentVerificationDetailsNode;
  TicketPaymentVerificationDetailsNodeConnection: TicketPaymentVerificationDetailsNodeConnection;
  TicketPaymentVerificationDetailsNodeEdge: TicketPaymentVerificationDetailsNodeEdge;
  TicketPositiveFeedbackDetailsNode: TicketPositiveFeedbackDetailsNode;
  TicketPositiveFeedbackDetailsNodeConnection: TicketPositiveFeedbackDetailsNodeConnection;
  TicketPositiveFeedbackDetailsNodeEdge: TicketPositiveFeedbackDetailsNodeEdge;
  TicketReferralDetailsNode: TicketReferralDetailsNode;
  TicketReferralDetailsNodeConnection: TicketReferralDetailsNodeConnection;
  TicketReferralDetailsNodeEdge: TicketReferralDetailsNodeEdge;
  TicketSensitiveDetailsNode: TicketSensitiveDetailsNode;
  TicketSensitiveDetailsNodeConnection: TicketSensitiveDetailsNodeConnection;
  TicketSensitiveDetailsNodeEdge: TicketSensitiveDetailsNodeEdge;
  TicketSystemFlaggingDetailsNode: TicketSystemFlaggingDetailsNode;
  TicketSystemFlaggingDetailsNodeConnection: TicketSystemFlaggingDetailsNodeConnection;
  TicketSystemFlaggingDetailsNodeEdge: TicketSystemFlaggingDetailsNodeEdge;
  UUID: Scalars['UUID']['output'];
  UnlockTargetPopulationMutation: UnlockTargetPopulationMutation;
  UpdateAddIndividualIssueTypeExtras: UpdateAddIndividualIssueTypeExtras;
  UpdateFeedbackInput: UpdateFeedbackInput;
  UpdateFeedbackMutation: UpdateFeedbackMutation;
  UpdateGrievanceTicketExtrasInput: UpdateGrievanceTicketExtrasInput;
  UpdateGrievanceTicketInput: UpdateGrievanceTicketInput;
  UpdateGrievanceTicketMutation: UpdateGrievanceTicketMutation;
  UpdateHouseholdDataUpdateIssueTypeExtras: UpdateHouseholdDataUpdateIssueTypeExtras;
  UpdateIndividualDataUpdateIssueTypeExtras: UpdateIndividualDataUpdateIssueTypeExtras;
  UpdatePaymentPlanInput: UpdatePaymentPlanInput;
  UpdatePaymentPlanMutation: UpdatePaymentPlanMutation;
  UpdatePaymentVerificationReceivedAndReceivedAmount: UpdatePaymentVerificationReceivedAndReceivedAmount;
  UpdatePaymentVerificationStatusAndReceivedAmount: UpdatePaymentVerificationStatusAndReceivedAmount;
  UpdateProgram: UpdateProgram;
  UpdateProgramInput: UpdateProgramInput;
  UpdateTargetPopulationInput: UpdateTargetPopulationInput;
  UpdateTargetPopulationMutation: UpdateTargetPopulationMutation;
  Upload: Scalars['Upload']['output'];
  UploadImportDataXLSXFileAsync: UploadImportDataXlsxFileAsync;
  UserBusinessAreaNode: UserBusinessAreaNode;
  UserBusinessAreaNodeConnection: UserBusinessAreaNodeConnection;
  UserBusinessAreaNodeEdge: UserBusinessAreaNodeEdge;
  UserNode: UserNode;
  UserNodeConnection: UserNodeConnection;
  UserNodeEdge: UserNodeEdge;
  UserRoleNode: UserRoleNode;
  VolumeByDeliveryMechanismNode: VolumeByDeliveryMechanismNode;
  XlsxErrorNode: XlsxErrorNode;
  XlsxRowErrorNode: XlsxRowErrorNode;
  _DatasetsNode: _DatasetsNode;
  _DetailedDatasetsNode: _DetailedDatasetsNode;
  _TableTotalCashTransferredDataNode: _TableTotalCashTransferredDataNode;
};

export type AccountabilitySampleSizeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountabilitySampleSizeNode'] = ResolversParentTypes['AccountabilitySampleSizeNode']> = {
  numberOfRecipients?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sampleSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionPaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPaymentPlanMutation'] = ResolversParentTypes['ActionPaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActivatePaymentVerificationPlanResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActivatePaymentVerificationPlan'] = ResolversParentTypes['ActivatePaymentVerificationPlan']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AgeFilterObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['AgeFilterObject'] = ResolversParentTypes['AgeFilterObject']> = {
  max?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  min?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalNode'] = ResolversParentTypes['ApprovalNode']> = {
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  info?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalProcessNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalProcessNode'] = ResolversParentTypes['ApprovalProcessNode']> = {
  actions?: Resolver<Maybe<ResolversTypes['FilteredActionsListNode']>, ParentType, ContextType>;
  approvalNumberRequired?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  authorizationNumberRequired?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  financeReleaseNumberRequired?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  paymentPlan?: Resolver<ResolversTypes['PaymentPlanNode'], ParentType, ContextType>;
  rejectedOn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sentForApprovalBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  sentForApprovalDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  sentForAuthorizationBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  sentForAuthorizationDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  sentForFinanceReleaseBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  sentForFinanceReleaseDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalProcessNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalProcessNodeConnection'] = ResolversParentTypes['ApprovalProcessNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ApprovalProcessNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalProcessNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalProcessNodeEdge'] = ResolversParentTypes['ApprovalProcessNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApprovalProcessNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaGroupNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaGroupNode'] = ResolversParentTypes['AreaGroupNode']> = {
  ids?: Resolver<Maybe<Array<Maybe<ResolversTypes['ID']>>>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaNode'] = ResolversParentTypes['AreaNode']> = {
  areaSet?: Resolver<ResolversTypes['AreaNodeConnection'], ParentType, ContextType, Partial<AreaNodeAreaSetArgs>>;
  areaType?: Resolver<ResolversTypes['AreaTypeNode'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  extras?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  feedbackSet?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<AreaNodeFeedbackSetArgs>>;
  grievanceticketSet?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<AreaNodeGrievanceticketSetArgs>>;
  householdSet?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<AreaNodeHouseholdSetArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  lft?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  originalId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  pCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  programs?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<AreaNodeProgramsArgs>>;
  reports?: Resolver<ResolversTypes['ReportNodeConnection'], ParentType, ContextType, Partial<AreaNodeReportsArgs>>;
  rght?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  treeId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaNodeConnection'] = ResolversParentTypes['AreaNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['AreaNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaNodeEdge'] = ResolversParentTypes['AreaNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaTreeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaTreeNode'] = ResolversParentTypes['AreaTreeNode']> = {
  areas?: Resolver<Maybe<Array<Maybe<ResolversTypes['AreaTreeNode']>>>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaTypeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaTypeNode'] = ResolversParentTypes['AreaTypeNode']> = {
  areaLevel?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  areaSet?: Resolver<ResolversTypes['AreaNodeConnection'], ParentType, ContextType, Partial<AreaTypeNodeAreaSetArgs>>;
  areatypeSet?: Resolver<ResolversTypes['AreaTypeNodeConnection'], ParentType, ContextType, Partial<AreaTypeNodeAreatypeSetArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  extras?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  lft?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  originalId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['AreaTypeNode']>, ParentType, ContextType>;
  rght?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  treeId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaTypeNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaTypeNodeConnection'] = ResolversParentTypes['AreaTypeNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['AreaTypeNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AreaTypeNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AreaTypeNodeEdge'] = ResolversParentTypes['AreaTypeNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AreaTypeNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface ArgScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Arg'], any> {
  name: 'Arg';
}

export type AssignFspToDeliveryMechanismMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignFspToDeliveryMechanismMutation'] = ResolversParentTypes['AssignFspToDeliveryMechanismMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BankAccountInfoNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BankAccountInfoNode'] = ResolversParentTypes['BankAccountInfoNode']> = {
  accountHolderName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bankAccountNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bankBranchName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bankName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['BankAccountInfoNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['BankAccountInfoNodeConnection'], ParentType, ContextType, Partial<BankAccountInfoNodeCopiedToArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastSyncAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  removedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BankAccountInfoNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['BankAccountInfoNodeConnection'] = ResolversParentTypes['BankAccountInfoNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['BankAccountInfoNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BankAccountInfoNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BankAccountInfoNodeEdge'] = ResolversParentTypes['BankAccountInfoNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BankAccountInfoNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type BulkGrievanceAddNoteMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkGrievanceAddNoteMutation'] = ResolversParentTypes['BulkGrievanceAddNoteMutation']> = {
  grievanceTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkUpdateGrievanceTicketsAssigneesMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkUpdateGrievanceTicketsAssigneesMutation'] = ResolversParentTypes['BulkUpdateGrievanceTicketsAssigneesMutation']> = {
  grievanceTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkUpdateGrievanceTicketsPriorityMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkUpdateGrievanceTicketsPriorityMutation'] = ResolversParentTypes['BulkUpdateGrievanceTicketsPriorityMutation']> = {
  grievanceTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkUpdateGrievanceTicketsUrgencyMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkUpdateGrievanceTicketsUrgencyMutation'] = ResolversParentTypes['BulkUpdateGrievanceTicketsUrgencyMutation']> = {
  grievanceTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessAreaNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessAreaNode'] = ResolversParentTypes['BusinessAreaNode']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  cashplanSet?: Resolver<ResolversTypes['CashPlanNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeCashplanSetArgs>>;
  children?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeChildrenArgs>>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  customFields?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  dataCollectingTypes?: Resolver<ResolversTypes['DataCollectingTypeNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeDataCollectingTypesArgs>>;
  deduplicationBatchDuplicatesAllowed?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationBatchDuplicatesPercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationDuplicateScore?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  deduplicationGoldenRecordDuplicatesAllowed?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationGoldenRecordDuplicatesPercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationIgnoreWithdraw?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  deduplicationPossibleDuplicateScore?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  enableEmailNotification?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  feedbackSet?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeFeedbackSetArgs>>;
  financialserviceproviderSet?: Resolver<ResolversTypes['FinancialServiceProviderNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeFinancialserviceproviderSetArgs>>;
  hasDataSharingAgreement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  householdSet?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeHouseholdSetArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualSet?: Resolver<ResolversTypes['IndividualNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeIndividualSetArgs>>;
  isAccountabilityApplicable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isPaymentPlanApplicable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSplit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  koboToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  koboUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  koboUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  logentrySet?: Resolver<ResolversTypes['PaymentVerificationLogEntryNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeLogentrySetArgs>>;
  longName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageSet?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeMessageSetArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  partnerSet?: Resolver<Array<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  paymentSet?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodePaymentSetArgs>>;
  paymentplanSet?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodePaymentplanSetArgs>>;
  paymentrecordSet?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodePaymentrecordSetArgs>>;
  postponeDeduplication?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  programSet?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeProgramSetArgs>>;
  rapidProHost?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rapidProMessagesToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rapidProPaymentVerificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rapidProSurveyToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  regionCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  regionName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  registrationdataimportSet?: Resolver<ResolversTypes['RegistrationDataImportNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeRegistrationdataimportSetArgs>>;
  reports?: Resolver<ResolversTypes['ReportNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeReportsArgs>>;
  ruleSet?: Resolver<ResolversTypes['SteficonRuleNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeRuleSetArgs>>;
  screenBeneficiary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  serviceproviderSet?: Resolver<ResolversTypes['ServiceProviderNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeServiceproviderSetArgs>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  surveySet?: Resolver<ResolversTypes['SurveyNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeSurveySetArgs>>;
  targetpopulationSet?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeTargetpopulationSetArgs>>;
  tickets?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<BusinessAreaNodeTicketsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userRoles?: Resolver<Array<ResolversTypes['UserRoleNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessAreaNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessAreaNodeConnection'] = ResolversParentTypes['BusinessAreaNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['BusinessAreaNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessAreaNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessAreaNodeEdge'] = ResolversParentTypes['BusinessAreaNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['BusinessAreaNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CashPlanAndPaymentPlanEdgesResolvers<ContextType = any, ParentType extends ResolversParentTypes['CashPlanAndPaymentPlanEdges'] = ResolversParentTypes['CashPlanAndPaymentPlanEdges']> = {
  cursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CashPlanAndPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CashPlanAndPaymentPlanNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CashPlanAndPaymentPlanNode'] = ResolversParentTypes['CashPlanAndPaymentPlanNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  assistanceMeasurement?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dispersionDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  objType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  programName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  serviceProviderFullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalDeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalNumberOfHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalUndeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verificationPlans?: Resolver<Maybe<Array<Maybe<ResolversTypes['PaymentVerificationPlanNode']>>>, ParentType, ContextType>;
  verificationStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CashPlanNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CashPlanNode'] = ResolversParentTypes['CashPlanNode']> = {
  assistanceMeasurement?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assistanceThrough?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  availablePaymentRecordsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  bankReconciliationError?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  bankReconciliationSuccess?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  caHashId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  caId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  canCreatePaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  comments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  coverageDuration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  coverageUnit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dispersionDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  distributionLevel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  downPayment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  endDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  exchangeRate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  fundsCommitment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  paymentItems?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<CashPlanNodePaymentItemsArgs>>;
  paymentVerificationSummary?: Resolver<Maybe<ResolversTypes['PaymentVerificationSummaryNode']>, ParentType, ContextType>;
  program?: Resolver<ResolversTypes['ProgramNode'], ParentType, ContextType>;
  serviceProvider?: Resolver<Maybe<ResolversTypes['ServiceProviderNode']>, ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['CashPlanStatus'], ParentType, ContextType>;
  statusDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  totalDeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalDeliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantityRevised?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantityRevisedUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalNumberOfHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalPersonsCovered?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalPersonsCoveredRevised?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUndeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalUndeliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validationAlertsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  verificationPlans?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNodeConnection']>, ParentType, ContextType, Partial<CashPlanNodeVerificationPlansArgs>>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  visionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CashPlanNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CashPlanNodeConnection'] = ResolversParentTypes['CashPlanNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['CashPlanNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CashPlanNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CashPlanNodeEdge'] = ResolversParentTypes['CashPlanNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CashPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChartDatasetNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChartDatasetNode'] = ResolversParentTypes['ChartDatasetNode']> = {
  datasets?: Resolver<Maybe<Array<Maybe<ResolversTypes['_DatasetsNode']>>>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChartDetailedDatasetsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChartDetailedDatasetsNode'] = ResolversParentTypes['ChartDetailedDatasetsNode']> = {
  datasets?: Resolver<Maybe<Array<Maybe<ResolversTypes['_DetailedDatasetsNode']>>>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChartGrievanceTicketsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChartGrievanceTicketsNode'] = ResolversParentTypes['ChartGrievanceTicketsNode']> = {
  datasets?: Resolver<Maybe<Array<Maybe<ResolversTypes['_DatasetsNode']>>>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  totalNumberOfFeedback?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalNumberOfGrievances?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalNumberOfOpenSensitive?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChartPaymentVerificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChartPaymentVerification'] = ResolversParentTypes['ChartPaymentVerification']> = {
  averageSampleSize?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  datasets?: Resolver<Maybe<Array<Maybe<ResolversTypes['_DetailedDatasetsNode']>>>, ParentType, ContextType>;
  households?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckAgainstSanctionListMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckAgainstSanctionListMutation'] = ResolversParentTypes['CheckAgainstSanctionListMutation']> = {
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['XlsxRowErrorNode']>>>, ParentType, ContextType>;
  ok?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChoiceObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChoiceObject'] = ResolversParentTypes['ChoiceObject']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChoiceObjectIntResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChoiceObjectInt'] = ResolversParentTypes['ChoiceObjectInt']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChooseDeliveryMechanismsForPaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChooseDeliveryMechanismsForPaymentPlanMutation'] = ResolversParentTypes['ChooseDeliveryMechanismsForPaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunicationMessageNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunicationMessageNode'] = ResolversParentTypes['CommunicationMessageNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['CommunicationMessageNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<CommunicationMessageNodeCopiedToArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  fullListArguments?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  households?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<CommunicationMessageNodeHouseholdsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  migratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  numberOfRecipients?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  randomSamplingArguments?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  sampleSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  samplingType?: Resolver<ResolversTypes['MessageSamplingType'], ParentType, ContextType>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunicationMessageNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunicationMessageNodeConnection'] = ResolversParentTypes['CommunicationMessageNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['CommunicationMessageNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunicationMessageNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunicationMessageNodeEdge'] = ResolversParentTypes['CommunicationMessageNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CommunicationMessageNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunicationMessageRecipientMapNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunicationMessageRecipientMapNode'] = ResolversParentTypes['CommunicationMessageRecipientMapNode']> = {
  headOfHousehold?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunicationMessageRecipientMapNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunicationMessageRecipientMapNodeConnection'] = ResolversParentTypes['CommunicationMessageRecipientMapNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['CommunicationMessageRecipientMapNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommunicationMessageRecipientMapNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommunicationMessageRecipientMapNodeEdge'] = ResolversParentTypes['CommunicationMessageRecipientMapNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['CommunicationMessageRecipientMapNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContentTypeObjectTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ContentTypeObjectType'] = ResolversParentTypes['ContentTypeObjectType']> = {
  appLabel?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  logEntries?: Resolver<ResolversTypes['PaymentVerificationLogEntryNodeConnection'], ParentType, ContextType, Partial<ContentTypeObjectTypeLogEntriesArgs>>;
  model?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentverificationSet?: Resolver<ResolversTypes['PaymentVerificationNodeConnection'], ParentType, ContextType, Partial<ContentTypeObjectTypePaymentverificationSetArgs>>;
  paymentverificationplanSet?: Resolver<ResolversTypes['PaymentVerificationPlanNodeConnection'], ParentType, ContextType, Partial<ContentTypeObjectTypePaymentverificationplanSetArgs>>;
  paymentverificationsummarySet?: Resolver<ResolversTypes['PaymentVerificationSummaryNodeConnection'], ParentType, ContextType, Partial<ContentTypeObjectTypePaymentverificationsummarySetArgs>>;
  ticketcomplaintdetailsSet?: Resolver<ResolversTypes['TicketComplaintDetailsNodeConnection'], ParentType, ContextType, Partial<ContentTypeObjectTypeTicketcomplaintdetailsSetArgs>>;
  ticketsensitivedetailsSet?: Resolver<ResolversTypes['TicketSensitiveDetailsNodeConnection'], ParentType, ContextType, Partial<ContentTypeObjectTypeTicketsensitivedetailsSetArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CopyProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['CopyProgram'] = ResolversParentTypes['CopyProgram']> = {
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CopyTargetPopulationMutationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CopyTargetPopulationMutationPayload'] = ResolversParentTypes['CopyTargetPopulationMutationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CoreFieldChoiceObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['CoreFieldChoiceObject'] = ResolversParentTypes['CoreFieldChoiceObject']> = {
  admin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labelEn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['LabelNode']>>>, ParentType, ContextType>;
  listName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountAndPercentageNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountAndPercentageNode'] = ResolversParentTypes['CountAndPercentageNode']> = {
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  percentage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCommunicationMessageMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCommunicationMessageMutation'] = ResolversParentTypes['CreateCommunicationMessageMutation']> = {
  message?: Resolver<Maybe<ResolversTypes['CommunicationMessageNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDashboardReportResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDashboardReport'] = ResolversParentTypes['CreateDashboardReport']> = {
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFeedbackMessageMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFeedbackMessageMutation'] = ResolversParentTypes['CreateFeedbackMessageMutation']> = {
  feedbackMessage?: Resolver<Maybe<ResolversTypes['FeedbackMessageNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFeedbackMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFeedbackMutation'] = ResolversParentTypes['CreateFeedbackMutation']> = {
  feedback?: Resolver<Maybe<ResolversTypes['FeedbackNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFollowUpPaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFollowUpPaymentPlanMutation'] = ResolversParentTypes['CreateFollowUpPaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateGrievanceTicketMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateGrievanceTicketMutation'] = ResolversParentTypes['CreateGrievanceTicketMutation']> = {
  grievanceTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePaymentPlanMutation'] = ResolversParentTypes['CreatePaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateProgram'] = ResolversParentTypes['CreateProgram']> = {
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReportResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReport'] = ResolversParentTypes['CreateReport']> = {
  report?: Resolver<Maybe<ResolversTypes['ReportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateSurveyMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateSurveyMutation'] = ResolversParentTypes['CreateSurveyMutation']> = {
  survey?: Resolver<Maybe<ResolversTypes['SurveyNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTargetPopulationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTargetPopulationMutation'] = ResolversParentTypes['CreateTargetPopulationMutation']> = {
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTicketNoteMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTicketNoteMutation'] = ResolversParentTypes['CreateTicketNoteMutation']> = {
  grievanceTicketNote?: Resolver<Maybe<ResolversTypes['TicketNoteNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateVerificationPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateVerificationPlanMutation'] = ResolversParentTypes['CreateVerificationPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataCollectingTypeChoiceObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataCollectingTypeChoiceObject'] = ResolversParentTypes['DataCollectingTypeChoiceObject']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataCollectingTypeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataCollectingTypeNode'] = ResolversParentTypes['DataCollectingTypeNode']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  compatibleTypes?: Resolver<ResolversTypes['DataCollectingTypeNodeConnection'], ParentType, ContextType, Partial<DataCollectingTypeNodeCompatibleTypesArgs>>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  datacollectingtypeSet?: Resolver<ResolversTypes['DataCollectingTypeNodeConnection'], ParentType, ContextType, Partial<DataCollectingTypeNodeDatacollectingtypeSetArgs>>;
  deprecated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  householdFiltersAvailable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualFiltersAvailable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  limitTo?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<DataCollectingTypeNodeLimitToArgs>>;
  modified?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  programs?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<DataCollectingTypeNodeProgramsArgs>>;
  recalculateComposition?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['DataCollectingTypeType']>, ParentType, ContextType>;
  weight?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataCollectingTypeNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataCollectingTypeNodeConnection'] = ResolversParentTypes['DataCollectingTypeNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['DataCollectingTypeNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataCollectingTypeNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataCollectingTypeNodeEdge'] = ResolversParentTypes['DataCollectingTypeNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataCollectingTypeNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export interface DecimalScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Decimal'], any> {
  name: 'Decimal';
}

export type DeduplicationResultNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeduplicationResultNode'] = ResolversParentTypes['DeduplicationResultNode']> = {
  age?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hitId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  location?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  proximityToScore?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  score?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteHouseholdApproveMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteHouseholdApproveMutation'] = ResolversParentTypes['DeleteHouseholdApproveMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePaymentPlanMutation'] = ResolversParentTypes['DeletePaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePaymentVerificationPlanResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePaymentVerificationPlan'] = ResolversParentTypes['DeletePaymentVerificationPlan']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteProgram'] = ResolversParentTypes['DeleteProgram']> = {
  ok?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteRegistrationDataImportResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteRegistrationDataImport'] = ResolversParentTypes['DeleteRegistrationDataImport']> = {
  ok?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTargetPopulationMutationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTargetPopulationMutationPayload'] = ResolversParentTypes['DeleteTargetPopulationMutationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ok?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveredQuantityNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveredQuantityNode'] = ResolversParentTypes['DeliveredQuantityNode']> = {
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalDeliveredQuantity?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryMechanismNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryMechanismNode'] = ResolversParentTypes['DeliveryMechanismNode']> = {
  chosenConfiguration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<ResolversTypes['UserNode'], ParentType, ContextType>;
  deliveryMechanism?: Resolver<Maybe<ResolversTypes['DeliveryMechanismPerPaymentPlanDeliveryMechanism']>, ParentType, ContextType>;
  deliveryMechanismOrder?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  financialServiceProvider?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNode']>, ParentType, ContextType>;
  fsp?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  paymentPlan?: Resolver<ResolversTypes['PaymentPlanNode'], ParentType, ContextType>;
  sentBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  sentDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  sentToPaymentGateway?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryMechanismNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryMechanismNodeConnection'] = ResolversParentTypes['DeliveryMechanismNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['DeliveryMechanismNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryMechanismNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryMechanismNodeEdge'] = ResolversParentTypes['DeliveryMechanismNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DeliveryMechanismNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscardPaymentVerificationPlanResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscardPaymentVerificationPlan'] = ResolversParentTypes['DiscardPaymentVerificationPlan']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DjangoDebugResolvers<ContextType = any, ParentType extends ResolversParentTypes['DjangoDebug'] = ResolversParentTypes['DjangoDebug']> = {
  sql?: Resolver<Maybe<Array<Maybe<ResolversTypes['DjangoDebugSQL']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DjangoDebugSqlResolvers<ContextType = any, ParentType extends ResolversParentTypes['DjangoDebugSQL'] = ResolversParentTypes['DjangoDebugSQL']> = {
  alias?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  duration?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  encoding?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isSelect?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSlow?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isoLevel?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  params?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rawSql?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sql?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startTime?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  stopTime?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  transId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vendor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DocumentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocumentNode'] = ResolversParentTypes['DocumentNode']> = {
  cleared?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  clearedBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  clearedDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['DocumentNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['DocumentNodeConnection'], ParentType, ContextType, Partial<DocumentNodeCopiedToArgs>>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryIso3?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  documentNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiryDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issuanceDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastSyncAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  photo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['DocumentStatus'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['DocumentTypeNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DocumentNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocumentNodeConnection'] = ResolversParentTypes['DocumentNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['DocumentNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DocumentNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocumentNodeEdge'] = ResolversParentTypes['DocumentNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DocumentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DocumentTypeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DocumentTypeNode'] = ResolversParentTypes['DocumentTypeNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  documents?: Resolver<ResolversTypes['DocumentNodeConnection'], ParentType, ContextType, Partial<DocumentTypeNodeDocumentsArgs>>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  isIdentityDocument?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uniqueForIndividual?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validForDeduplication?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EditPaymentVerificationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['EditPaymentVerificationMutation'] = ResolversParentTypes['EditPaymentVerificationMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EraseRegistrationDataImportMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['EraseRegistrationDataImportMutation'] = ResolversParentTypes['EraseRegistrationDataImportMutation']> = {
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExcludeHouseholdsMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExcludeHouseholdsMutation'] = ResolversParentTypes['ExcludeHouseholdsMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportPdfPaymentPlanSummaryMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportPDFPaymentPlanSummaryMutation'] = ResolversParentTypes['ExportPDFPaymentPlanSummaryMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportSurveySampleMutationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportSurveySampleMutationMutation'] = ResolversParentTypes['ExportSurveySampleMutationMutation']> = {
  survey?: Resolver<Maybe<ResolversTypes['SurveyNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportXlsxPaymentPlanPaymentListMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportXLSXPaymentPlanPaymentListMutation'] = ResolversParentTypes['ExportXLSXPaymentPlanPaymentListMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportXlsxPaymentPlanPaymentListPerFspMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportXLSXPaymentPlanPaymentListPerFSPMutation'] = ResolversParentTypes['ExportXLSXPaymentPlanPaymentListPerFSPMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportXlsxPaymentVerificationPlanFileResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportXlsxPaymentVerificationPlanFile'] = ResolversParentTypes['ExportXlsxPaymentVerificationPlanFile']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedbackMessageNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedbackMessageNode'] = ResolversParentTypes['FeedbackMessageNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedbackMessageNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedbackMessageNodeConnection'] = ResolversParentTypes['FeedbackMessageNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['FeedbackMessageNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedbackMessageNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedbackMessageNodeEdge'] = ResolversParentTypes['FeedbackMessageNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['FeedbackMessageNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedbackNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedbackNode'] = ResolversParentTypes['FeedbackNode']> = {
  admin2?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  area?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  comments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  consent?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['FeedbackNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<FeedbackNodeCopiedToArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  feedbackMessages?: Resolver<ResolversTypes['FeedbackMessageNodeConnection'], ParentType, ContextType, Partial<FeedbackNodeFeedbackMessagesArgs>>;
  householdLookup?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualLookup?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueType?: Resolver<ResolversTypes['FeedbackIssueType'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  linkedGrievance?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  migratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedbackNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedbackNodeConnection'] = ResolversParentTypes['FeedbackNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['FeedbackNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FeedbackNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeedbackNodeEdge'] = ResolversParentTypes['FeedbackNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['FeedbackNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FieldAttributeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FieldAttributeNode'] = ResolversParentTypes['FieldAttributeNode']> = {
  associatedWith?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  choices?: Resolver<Maybe<Array<Maybe<ResolversTypes['CoreFieldChoiceObject']>>>, ParentType, ContextType>;
  hint?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isFlexField?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  labelEn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['LabelNode']>>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  required?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilteredActionsListNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilteredActionsListNode'] = ResolversParentTypes['FilteredActionsListNode']> = {
  approval?: Resolver<Maybe<Array<Maybe<ResolversTypes['ApprovalNode']>>>, ParentType, ContextType>;
  authorization?: Resolver<Maybe<Array<Maybe<ResolversTypes['ApprovalNode']>>>, ParentType, ContextType>;
  financeRelease?: Resolver<Maybe<Array<Maybe<ResolversTypes['ApprovalNode']>>>, ParentType, ContextType>;
  reject?: Resolver<Maybe<Array<Maybe<ResolversTypes['ApprovalNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinalizeTargetPopulationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinalizeTargetPopulationMutation'] = ResolversParentTypes['FinalizeTargetPopulationMutation']> = {
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderNode'] = ResolversParentTypes['FinancialServiceProviderNode']> = {
  allowedBusinessAreas?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<FinancialServiceProviderNodeAllowedBusinessAreasArgs>>;
  communicationChannel?: Resolver<ResolversTypes['FinancialServiceProviderCommunicationChannel'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  dataTransferConfiguration?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  deliveryMechanisms?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryMechanismsPerPaymentPlan?: Resolver<ResolversTypes['DeliveryMechanismNodeConnection'], ParentType, ContextType, Partial<FinancialServiceProviderNodeDeliveryMechanismsPerPaymentPlanArgs>>;
  distributionLimit?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  financialserviceproviderxlsxreportSet?: Resolver<ResolversTypes['FinancialServiceProviderXlsxReportNodeConnection'], ParentType, ContextType, Partial<FinancialServiceProviderNodeFinancialserviceproviderxlsxreportSetArgs>>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPaymentGateway?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  paymentGatewayId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentSet?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<FinancialServiceProviderNodePaymentSetArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  visionVendorNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  xlsxTemplates?: Resolver<ResolversTypes['FinancialServiceProviderXlsxTemplateNodeConnection'], ParentType, ContextType, Partial<FinancialServiceProviderNodeXlsxTemplatesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderNodeConnection'] = ResolversParentTypes['FinancialServiceProviderNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['FinancialServiceProviderNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderNodeEdge'] = ResolversParentTypes['FinancialServiceProviderNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderXlsxReportNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderXlsxReportNode'] = ResolversParentTypes['FinancialServiceProviderXlsxReportNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  financialServiceProvider?: Resolver<ResolversTypes['FinancialServiceProviderNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reportUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderXlsxReportNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderXlsxReportNodeConnection'] = ResolversParentTypes['FinancialServiceProviderXlsxReportNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['FinancialServiceProviderXlsxReportNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderXlsxReportNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderXlsxReportNodeEdge'] = ResolversParentTypes['FinancialServiceProviderXlsxReportNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderXlsxReportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderXlsxTemplateNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderXlsxTemplateNode'] = ResolversParentTypes['FinancialServiceProviderXlsxTemplateNode']> = {
  columns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  coreFields?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  financialServiceProviders?: Resolver<ResolversTypes['FinancialServiceProviderNodeConnection'], ParentType, ContextType, Partial<FinancialServiceProviderXlsxTemplateNodeFinancialServiceProvidersArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderXlsxTemplateNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderXlsxTemplateNodeConnection'] = ResolversParentTypes['FinancialServiceProviderXlsxTemplateNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['FinancialServiceProviderXlsxTemplateNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinancialServiceProviderXlsxTemplateNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinancialServiceProviderXlsxTemplateNodeEdge'] = ResolversParentTypes['FinancialServiceProviderXlsxTemplateNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderXlsxTemplateNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FinishPaymentVerificationPlanResolvers<ContextType = any, ParentType extends ResolversParentTypes['FinishPaymentVerificationPlan'] = ResolversParentTypes['FinishPaymentVerificationPlan']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface FlexFieldsScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['FlexFieldsScalar'], any> {
  name: 'FlexFieldsScalar';
}

export type FspChoiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['FspChoice'] = ResolversParentTypes['FspChoice']> = {
  configurations?: Resolver<Maybe<Array<Maybe<ResolversTypes['FspConfiguration']>>>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FspChoicesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FspChoices'] = ResolversParentTypes['FspChoices']> = {
  deliveryMechanism?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fsps?: Resolver<Maybe<Array<Maybe<ResolversTypes['FspChoice']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FspConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['FspConfiguration'] = ResolversParentTypes['FspConfiguration']> = {
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GenericPaymentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GenericPaymentNode'] = ResolversParentTypes['GenericPaymentNode']> = {
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  objType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GenericPaymentPlanNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GenericPaymentPlanNode'] = ResolversParentTypes['GenericPaymentPlanNode']> = {
  availablePaymentRecordsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  bankReconciliationError?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  bankReconciliationSuccess?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  canCreatePaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  objType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentVerificationSummary?: Resolver<Maybe<ResolversTypes['PaymentVerificationSummaryNode']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statusDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  totalDeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalNumberOfHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalUndeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  verificationPlans?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNodeConnection']>, ParentType, ContextType, Partial<GenericPaymentPlanNodeVerificationPlansArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface GeoJsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GeoJSON'], any> {
  name: 'GeoJSON';
}

export type GetCashplanVerificationSampleSizeObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['GetCashplanVerificationSampleSizeObject'] = ResolversParentTypes['GetCashplanVerificationSampleSizeObject']> = {
  paymentRecordCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sampleSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GetCommunicationMessageSampleSizeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GetCommunicationMessageSampleSizeNode'] = ResolversParentTypes['GetCommunicationMessageSampleSizeNode']> = {
  numberOfRecipients?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sampleSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceDocumentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceDocumentNode'] = ResolversParentTypes['GrievanceDocumentNode']> = {
  contentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  fileName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filePath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceDocumentNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceDocumentNodeConnection'] = ResolversParentTypes['GrievanceDocumentNodeConnection']> = {
  edges?: Resolver<Array<Maybe<ResolversTypes['GrievanceDocumentNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceDocumentNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceDocumentNodeEdge'] = ResolversParentTypes['GrievanceDocumentNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['GrievanceDocumentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceStatusChangeMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceStatusChangeMutation'] = ResolversParentTypes['GrievanceStatusChangeMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceTicketNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceTicketNode'] = ResolversParentTypes['GrievanceTicketNode']> = {
  addIndividualTicketDetails?: Resolver<Maybe<ResolversTypes['TicketAddIndividualDetailsNode']>, ParentType, ContextType>;
  admin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  admin2?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  area?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  assignedTo?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  category?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  comments?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  complaintTicketDetails?: Resolver<Maybe<ResolversTypes['TicketComplaintDetailsNode']>, ParentType, ContextType>;
  consent?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<GrievanceTicketNodeCopiedToArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  deleteHouseholdTicketDetails?: Resolver<Maybe<ResolversTypes['TicketDeleteHouseholdDetailsNode']>, ParentType, ContextType>;
  deleteIndividualTicketDetails?: Resolver<Maybe<ResolversTypes['TicketDeleteIndividualDetailsNode']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  documentation?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceDocumentNode']>>>, ParentType, ContextType>;
  existingTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  extras?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  feedback?: Resolver<Maybe<ResolversTypes['FeedbackNode']>, ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  householdDataUpdateTicketDetails?: Resolver<Maybe<ResolversTypes['TicketHouseholdDataUpdateDetailsNode']>, ParentType, ContextType>;
  householdUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ignored?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  individualDataUpdateTicketDetails?: Resolver<Maybe<ResolversTypes['TicketIndividualDataUpdateDetailsNode']>, ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  issueType?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  language?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastNotificationSent?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  linkedTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  migratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  needsAdjudicationTicketDetails?: Resolver<Maybe<ResolversTypes['TicketNeedsAdjudicationDetailsNode']>, ParentType, ContextType>;
  negativeFeedbackTicketDetails?: Resolver<Maybe<ResolversTypes['TicketNegativeFeedbackDetailsNode']>, ParentType, ContextType>;
  partner?: Resolver<Maybe<ResolversTypes['PartnerType']>, ParentType, ContextType>;
  paymentRecord?: Resolver<Maybe<ResolversTypes['PaymentRecordAndPaymentNode']>, ParentType, ContextType>;
  paymentVerificationTicketDetails?: Resolver<Maybe<ResolversTypes['TicketPaymentVerificationDetailsNode']>, ParentType, ContextType>;
  positiveFeedbackTicketDetails?: Resolver<Maybe<ResolversTypes['TicketPositiveFeedbackDetailsNode']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  programs?: Resolver<Maybe<Array<Maybe<ResolversTypes['ProgramNode']>>>, ParentType, ContextType>;
  referralTicketDetails?: Resolver<Maybe<ResolversTypes['TicketReferralDetailsNode']>, ParentType, ContextType>;
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  relatedTickets?: Resolver<Maybe<Array<Maybe<ResolversTypes['GrievanceTicketNode']>>>, ParentType, ContextType>;
  sensitiveTicketDetails?: Resolver<Maybe<ResolversTypes['TicketSensitiveDetailsNode']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  supportDocuments?: Resolver<ResolversTypes['GrievanceDocumentNodeConnection'], ParentType, ContextType, Partial<GrievanceTicketNodeSupportDocumentsArgs>>;
  systemFlaggingTicketDetails?: Resolver<Maybe<ResolversTypes['TicketSystemFlaggingDetailsNode']>, ParentType, ContextType>;
  ticketNotes?: Resolver<ResolversTypes['TicketNoteNodeConnection'], ParentType, ContextType, Partial<GrievanceTicketNodeTicketNotesArgs>>;
  totalDays?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  urgency?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceTicketNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceTicketNodeConnection'] = ResolversParentTypes['GrievanceTicketNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['GrievanceTicketNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrievanceTicketNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrievanceTicketNodeEdge'] = ResolversParentTypes['GrievanceTicketNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupAttributeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupAttributeNode'] = ResolversParentTypes['GroupAttributeNode']> = {
  flexAttributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['FieldAttributeNode']>>>, ParentType, ContextType, Partial<GroupAttributeNodeFlexAttributesArgs>>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  labelEn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HouseholdDataChangeApproveMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['HouseholdDataChangeApproveMutation'] = ResolversParentTypes['HouseholdDataChangeApproveMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HouseholdNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['HouseholdNode'] = ResolversParentTypes['HouseholdNode']> = {
  activeIndividualsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  addIndividualTicketDetails?: Resolver<ResolversTypes['TicketAddIndividualDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeAddIndividualTicketDetailsArgs>>;
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin1?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  admin2?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  admin3?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  admin4?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  adminArea?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType>;
  adminAreaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  childHoh?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  childrenCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  childrenDisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  collectIndividualData?: Resolver<ResolversTypes['HouseholdCollectIndividualData'], ParentType, ContextType>;
  collectType?: Resolver<ResolversTypes['HouseholdCollectType'], ParentType, ContextType>;
  complaintTicketDetails?: Resolver<ResolversTypes['TicketComplaintDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeComplaintTicketDetailsArgs>>;
  consent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  consentSharing?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  consentSign?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeCopiedToArgs>>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryOrigin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deleteHouseholdTicketDetails?: Resolver<ResolversTypes['TicketDeleteHouseholdDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeDeleteHouseholdTicketDetailsArgs>>;
  deliveredQuantities?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeliveredQuantityNode']>>>, ParentType, ContextType>;
  detailId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deviceid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  familyId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fchildHoh?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  feedbacks?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeFeedbacksArgs>>;
  femaleAgeGroup05Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup05DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup60Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup60DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup611Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup611DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1217Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1217DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1859Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1859DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleChildrenCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleChildrenDisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  firstRegistrationDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  flexFields?: Resolver<Maybe<ResolversTypes['FlexFieldsScalar']>, ParentType, ContextType>;
  geopoint?: Resolver<Maybe<ResolversTypes['GeoJSON']>, ParentType, ContextType>;
  hasDuplicates?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  headOfHousehold?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  householdDataUpdateTicketDetails?: Resolver<ResolversTypes['TicketHouseholdDataUpdateDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeHouseholdDataUpdateTicketDetailsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individuals?: Resolver<Maybe<ResolversTypes['IndividualNodeConnection']>, ParentType, ContextType, Partial<HouseholdNodeIndividualsArgs>>;
  individualsAndRoles?: Resolver<Array<ResolversTypes['IndividualRoleInHouseholdNode']>, ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRecalculatedGroupAges?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  koboAssetId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastRegistrationDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastSyncAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  maleAgeGroup05Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup05DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup60Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup60DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup611Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup611DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1217Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1217DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1859Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1859DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleChildrenCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleChildrenDisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  messages?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeMessagesArgs>>;
  migratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  nameEnumerator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  negativeFeedbackTicketDetails?: Resolver<ResolversTypes['TicketNegativeFeedbackDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeNegativeFeedbackTicketDetailsArgs>>;
  orgEnumerator?: Resolver<ResolversTypes['HouseholdOrgEnumerator'], ParentType, ContextType>;
  orgNameEnumerator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  originUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentSet?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<HouseholdNodePaymentSetArgs>>;
  paymentrecordSet?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<HouseholdNodePaymentrecordSetArgs>>;
  positiveFeedbackTicketDetails?: Resolver<ResolversTypes['TicketPositiveFeedbackDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodePositiveFeedbackTicketDetailsArgs>>;
  pregnantCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  programs?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeProgramsArgs>>;
  referralTicketDetails?: Resolver<ResolversTypes['TicketReferralDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeReferralTicketDetailsArgs>>;
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  registrationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  registrationMethod?: Resolver<ResolversTypes['HouseholdRegistrationMethod'], ParentType, ContextType>;
  removedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  representatives?: Resolver<ResolversTypes['IndividualNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeRepresentativesArgs>>;
  residenceStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnee?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  rowId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sanctionListConfirmedMatch?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  sanctionListPossibleMatch?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  selection?: Resolver<Maybe<ResolversTypes['HouseholdSelectionNode']>, ParentType, ContextType>;
  selections?: Resolver<Array<ResolversTypes['HouseholdSelectionNode']>, ParentType, ContextType>;
  sensitiveTicketDetails?: Resolver<ResolversTypes['TicketSensitiveDetailsNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeSensitiveTicketDetailsArgs>>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  start?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  surveys?: Resolver<ResolversTypes['SurveyNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeSurveysArgs>>;
  targetPopulations?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<HouseholdNodeTargetPopulationsArgs>>;
  totalCashReceived?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  totalCashReceivedUsd?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  unhcrId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userFields?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  village?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  withdrawn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  withdrawnDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  zipCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HouseholdNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['HouseholdNodeConnection'] = ResolversParentTypes['HouseholdNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['HouseholdNodeEdge']>>, ParentType, ContextType>;
  individualsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HouseholdNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['HouseholdNodeEdge'] = ResolversParentTypes['HouseholdNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HouseholdSelectionNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['HouseholdSelectionNode'] = ResolversParentTypes['HouseholdSelectionNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<ResolversTypes['HouseholdNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  targetPopulation?: Resolver<ResolversTypes['TargetPopulationNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerabilityScore?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportDataNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportDataNode'] = ResolversParentTypes['ImportDataNode']> = {
  businessAreaSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdById?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['ImportDataDataType'], ParentType, ContextType>;
  error?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  koboimportdata?: Resolver<Maybe<ResolversTypes['KoboImportDataNode']>, ParentType, ContextType>;
  numberOfHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  numberOfIndividuals?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportDatahubNode']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ImportDataStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validationErrors?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  xlsxValidationErrors?: Resolver<Maybe<Array<Maybe<ResolversTypes['XlsxRowErrorNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportXlsxPaymentPlanPaymentListMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportXLSXPaymentPlanPaymentListMutation'] = ResolversParentTypes['ImportXLSXPaymentPlanPaymentListMutation']> = {
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['XlsxErrorNode']>>>, ParentType, ContextType>;
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportXlsxPaymentPlanPaymentListPerFspMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportXLSXPaymentPlanPaymentListPerFSPMutation'] = ResolversParentTypes['ImportXLSXPaymentPlanPaymentListPerFSPMutation']> = {
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['XlsxErrorNode']>>>, ParentType, ContextType>;
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportXlsxPaymentVerificationPlanFileResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportXlsxPaymentVerificationPlanFile'] = ResolversParentTypes['ImportXlsxPaymentVerificationPlanFile']> = {
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['XlsxErrorNode']>>>, ParentType, ContextType>;
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedDocumentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedDocumentNode'] = ResolversParentTypes['ImportedDocumentNode']> = {
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  docDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  documentNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiryDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<ResolversTypes['ImportedIndividualNode'], ParentType, ContextType>;
  issuanceDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  photo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ImportedDocumentTypeNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedDocumentNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedDocumentNodeConnection'] = ResolversParentTypes['ImportedDocumentNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ImportedDocumentNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedDocumentNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedDocumentNodeEdge'] = ResolversParentTypes['ImportedDocumentNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ImportedDocumentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedDocumentTypeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedDocumentTypeNode'] = ResolversParentTypes['ImportedDocumentTypeNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  documents?: Resolver<ResolversTypes['ImportedDocumentNodeConnection'], ParentType, ContextType, Partial<ImportedDocumentTypeNodeDocumentsArgs>>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  isIdentityDocument?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedHouseholdNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedHouseholdNode'] = ResolversParentTypes['ImportedHouseholdNode']> = {
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin1?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin1Title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin2?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin2Title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin3?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin3Title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin4?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  admin4Title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  adminArea?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  adminAreaTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  childHoh?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  collectIndividualData?: Resolver<ResolversTypes['ImportedHouseholdCollectIndividualData'], ParentType, ContextType>;
  collectType?: Resolver<ResolversTypes['ImportedHouseholdCollectType'], ParentType, ContextType>;
  consent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  consentSharing?: Resolver<ResolversTypes['ImportedHouseholdConsentSharing'], ParentType, ContextType>;
  consentSign?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryOrigin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['ImportedHouseholdCurrency'], ParentType, ContextType>;
  detailId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deviceid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  enumeratorRecId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fchildHoh?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  femaleAgeGroup05Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup05DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup60Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup60DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup611Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup611DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1217Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1217DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1859Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  femaleAgeGroup1859DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  firstRegistrationDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  flexFields?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  geopoint?: Resolver<Maybe<ResolversTypes['GeoJSON']>, ParentType, ContextType>;
  hasDuplicates?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  headOfHousehold?: Resolver<Maybe<ResolversTypes['ImportedIndividualNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  individuals?: Resolver<ResolversTypes['ImportedIndividualNodeConnection'], ParentType, ContextType, Partial<ImportedHouseholdNodeIndividualsArgs>>;
  koboAssetId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  koboSubmissionTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  koboSubmissionUuid?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  lastRegistrationDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  maleAgeGroup05Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup05DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup60Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup60DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup611Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup611DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1217Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1217DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1859Count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maleAgeGroup1859DisabledCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  misUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameEnumerator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  orgEnumerator?: Resolver<Maybe<ResolversTypes['ImportedHouseholdOrgEnumerator']>, ParentType, ContextType>;
  orgNameEnumerator?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pregnantCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  programId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  registrationDataImport?: Resolver<ResolversTypes['RegistrationDataImportDatahubNode'], ParentType, ContextType>;
  registrationMethod?: Resolver<ResolversTypes['ImportedHouseholdRegistrationMethod'], ParentType, ContextType>;
  residenceStatus?: Resolver<ResolversTypes['ImportedHouseholdResidenceStatus'], ParentType, ContextType>;
  returnee?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  rowId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  start?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  unhcrId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  village?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  zipCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedHouseholdNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedHouseholdNodeConnection'] = ResolversParentTypes['ImportedHouseholdNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ImportedHouseholdNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedHouseholdNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedHouseholdNodeEdge'] = ResolversParentTypes['ImportedHouseholdNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ImportedHouseholdNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedIndividualIdentityNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedIndividualIdentityNode'] = ResolversParentTypes['ImportedIndividualIdentityNode']> = {
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  documentNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<ResolversTypes['ImportedIndividualNode'], ParentType, ContextType>;
  partner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedIndividualIdentityNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedIndividualIdentityNodeConnection'] = ResolversParentTypes['ImportedIndividualIdentityNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ImportedIndividualIdentityNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedIndividualIdentityNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedIndividualIdentityNodeEdge'] = ResolversParentTypes['ImportedIndividualIdentityNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ImportedIndividualIdentityNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedIndividualNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedIndividualNode'] = ResolversParentTypes['ImportedIndividualNode']> = {
  age?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  ageAtRegistration?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  birthDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  commsDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deduplicationBatchResults?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeduplicationResultNode']>>>, ParentType, ContextType>;
  deduplicationBatchStatus?: Resolver<Maybe<ResolversTypes['ImportedIndividualDeduplicationBatchStatus']>, ParentType, ContextType>;
  deduplicationGoldenRecordResults?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeduplicationResultNode']>>>, ParentType, ContextType>;
  deduplicationGoldenRecordStatus?: Resolver<Maybe<ResolversTypes['ImportedIndividualDeduplicationGoldenRecordStatus']>, ParentType, ContextType>;
  detailId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  disability?: Resolver<ResolversTypes['ImportedIndividualDisability'], ParentType, ContextType>;
  disabilityCertificatePicture?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  documents?: Resolver<ResolversTypes['ImportedDocumentNodeConnection'], ParentType, ContextType, Partial<ImportedIndividualNodeDocumentsArgs>>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  estimatedBirthDate?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  familyName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstRegistrationDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  flexFields?: Resolver<Maybe<ResolversTypes['FlexFieldsScalar']>, ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  givenName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hearingDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['ImportedHouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identities?: Resolver<ResolversTypes['ImportedIndividualIdentityNodeConnection'], ParentType, ContextType, Partial<ImportedIndividualNodeIdentitiesArgs>>;
  importId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  importedhousehold?: Resolver<Maybe<ResolversTypes['ImportedHouseholdNode']>, ParentType, ContextType>;
  individualId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  koboAssetId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastRegistrationDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  maritalStatus?: Resolver<ResolversTypes['ImportedIndividualMaritalStatus'], ParentType, ContextType>;
  memoryDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  middleName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  misUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  observedDisability?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  paymentDeliveryPhoneNo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNoAlternative?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNoAlternativeValid?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  phoneNoValid?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  photo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  physicalDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preferredLanguage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pregnant?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  programId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  registrationDataImport?: Resolver<ResolversTypes['RegistrationDataImportDatahubNode'], ParentType, ContextType>;
  relationship?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rowId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  seeingDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  selfcareDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sex?: Resolver<ResolversTypes['ImportedIndividualSex'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  whoAnswersAltPhone?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  whoAnswersPhone?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  workStatus?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedIndividualNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedIndividualNodeConnection'] = ResolversParentTypes['ImportedIndividualNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ImportedIndividualNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportedIndividualNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportedIndividualNodeEdge'] = ResolversParentTypes['ImportedIndividualNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ImportedIndividualNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualDataChangeApproveMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualDataChangeApproveMutation'] = ResolversParentTypes['IndividualDataChangeApproveMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualIdentityNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualIdentityNode'] = ResolversParentTypes['IndividualIdentityNode']> = {
  copiedFrom?: Resolver<Maybe<ResolversTypes['IndividualIdentityNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['IndividualIdentityNodeConnection'], ParentType, ContextType, Partial<IndividualIdentityNodeCopiedToArgs>>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  countryIso3?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  modified?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  partner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualIdentityNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualIdentityNodeConnection'] = ResolversParentTypes['IndividualIdentityNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['IndividualIdentityNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualIdentityNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualIdentityNodeEdge'] = ResolversParentTypes['IndividualIdentityNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['IndividualIdentityNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualNode'] = ResolversParentTypes['IndividualNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  administrationOfRutf?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  age?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  ageAtRegistration?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  bankAccountInfo?: Resolver<Maybe<ResolversTypes['BankAccountInfoNode']>, ParentType, ContextType>;
  birthDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  childHoh?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  collectorPayments?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<IndividualNodeCollectorPaymentsArgs>>;
  commsDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  complaintTicketDetails?: Resolver<ResolversTypes['TicketComplaintDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeComplaintTicketDetailsArgs>>;
  copiedFrom?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<ResolversTypes['IndividualNodeConnection'], ParentType, ContextType, Partial<IndividualNodeCopiedToArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deduplicationBatchResults?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeduplicationResultNode']>>>, ParentType, ContextType>;
  deduplicationBatchStatus?: Resolver<ResolversTypes['IndividualDeduplicationBatchStatus'], ParentType, ContextType>;
  deduplicationGoldenRecordResults?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeduplicationResultNode']>>>, ParentType, ContextType>;
  deduplicationGoldenRecordStatus?: Resolver<ResolversTypes['IndividualDeduplicationGoldenRecordStatus'], ParentType, ContextType>;
  deleteIndividualTicketDetails?: Resolver<ResolversTypes['TicketDeleteIndividualDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeDeleteIndividualTicketDetailsArgs>>;
  detailId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  disability?: Resolver<ResolversTypes['IndividualDisability'], ParentType, ContextType>;
  disabilityCertificatePicture?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  documents?: Resolver<ResolversTypes['DocumentNodeConnection'], ParentType, ContextType, Partial<IndividualNodeDocumentsArgs>>;
  duplicate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  duplicateDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  enrolledInNutritionProgramme?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  estimatedBirthDate?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  familyName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fchildHoh?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  feedbacks?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<IndividualNodeFeedbacksArgs>>;
  firstRegistrationDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  flexFields?: Resolver<Maybe<ResolversTypes['FlexFieldsScalar']>, ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  givenName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headingHousehold?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  hearingDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  householdsAndRoles?: Resolver<Array<ResolversTypes['IndividualRoleInHouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  identities?: Resolver<ResolversTypes['IndividualIdentityNodeConnection'], ParentType, ContextType, Partial<IndividualNodeIdentitiesArgs>>;
  importedIndividualId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  individualDataUpdateTicketDetails?: Resolver<ResolversTypes['TicketIndividualDataUpdateDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeIndividualDataUpdateTicketDetailsArgs>>;
  individualId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  koboAssetId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastRegistrationDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  lastSyncAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  maritalStatus?: Resolver<ResolversTypes['IndividualMaritalStatus'], ParentType, ContextType>;
  memoryDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  middleName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  migratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  negativeFeedbackTicketDetails?: Resolver<ResolversTypes['TicketNegativeFeedbackDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeNegativeFeedbackTicketDetailsArgs>>;
  observedDisability?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  originUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentChannels?: Resolver<Maybe<Array<Maybe<ResolversTypes['BankAccountInfoNode']>>>, ParentType, ContextType>;
  paymentDeliveryPhoneNo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentSet?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<IndividualNodePaymentSetArgs>>;
  paymentrecordSet?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<IndividualNodePaymentrecordSetArgs>>;
  phoneNo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNoAlternative?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phoneNoAlternativeValid?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  phoneNoValid?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  photo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  physicalDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  positiveFeedbackTicketDetails?: Resolver<ResolversTypes['TicketPositiveFeedbackDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodePositiveFeedbackTicketDetailsArgs>>;
  preferredLanguage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pregnant?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  referralTicketDetails?: Resolver<ResolversTypes['TicketReferralDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeReferralTicketDetailsArgs>>;
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  registrationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  relationship?: Resolver<Maybe<ResolversTypes['IndividualRelationship']>, ParentType, ContextType>;
  relationshipConfirmed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  removedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  representedHouseholds?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<IndividualNodeRepresentedHouseholdsArgs>>;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rowId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sanctionListConfirmedMatch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sanctionListLastCheck?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  sanctionListPossibleMatch?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  seeingDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  selfcareDisability?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sensitiveTicketDetails?: Resolver<ResolversTypes['TicketSensitiveDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeSensitiveTicketDetailsArgs>>;
  sex?: Resolver<ResolversTypes['IndividualSex'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ticketDuplicates?: Resolver<ResolversTypes['TicketNeedsAdjudicationDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeTicketDuplicatesArgs>>;
  ticketGoldenRecords?: Resolver<ResolversTypes['TicketNeedsAdjudicationDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeTicketGoldenRecordsArgs>>;
  ticketSelected?: Resolver<ResolversTypes['TicketNeedsAdjudicationDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeTicketSelectedArgs>>;
  ticketsystemflaggingdetailsSet?: Resolver<ResolversTypes['TicketSystemFlaggingDetailsNodeConnection'], ParentType, ContextType, Partial<IndividualNodeTicketsystemflaggingdetailsSetArgs>>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userFields?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  whoAnswersAltPhone?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  whoAnswersPhone?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  withdrawn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  withdrawnDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  workStatus?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualNodeConnection'] = ResolversParentTypes['IndividualNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['IndividualNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualNodeEdge'] = ResolversParentTypes['IndividualNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IndividualRoleInHouseholdNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['IndividualRoleInHouseholdNode'] = ResolversParentTypes['IndividualRoleInHouseholdNode']> = {
  copiedFrom?: Resolver<Maybe<ResolversTypes['IndividualRoleInHouseholdNode']>, ParentType, ContextType>;
  copiedTo?: Resolver<Array<ResolversTypes['IndividualRoleInHouseholdNode']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<ResolversTypes['HouseholdNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  individual?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  isMigrationHandled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOriginal?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastSyncAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  migratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  role?: Resolver<Maybe<ResolversTypes['IndividualRoleInHouseholdRole']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvalidPaymentVerificationPlanResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvalidPaymentVerificationPlan'] = ResolversParentTypes['InvalidPaymentVerificationPlan']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['GenericPaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IssueTypesObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['IssueTypesObject'] = ResolversParentTypes['IssueTypesObject']> = {
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subCategories?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonStringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONString'], any> {
  name: 'JSONString';
}

export type KoboAssetObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['KoboAssetObject'] = ResolversParentTypes['KoboAssetObject']> = {
  assetType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateModified?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deploymentActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  hasDeployment?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sector?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  xlsLink?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KoboAssetObjectConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['KoboAssetObjectConnection'] = ResolversParentTypes['KoboAssetObjectConnection']> = {
  edges?: Resolver<Array<Maybe<ResolversTypes['KoboAssetObjectEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KoboAssetObjectEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['KoboAssetObjectEdge'] = ResolversParentTypes['KoboAssetObjectEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['KoboAssetObject']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KoboErrorNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['KoboErrorNode'] = ResolversParentTypes['KoboErrorNode']> = {
  header?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type KoboImportDataNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['KoboImportDataNode'] = ResolversParentTypes['KoboImportDataNode']> = {
  businessAreaSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdById?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  dataType?: Resolver<ResolversTypes['ImportDataDataType'], ParentType, ContextType>;
  error?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importdataPtr?: Resolver<ResolversTypes['ImportDataNode'], ParentType, ContextType>;
  koboAssetId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  koboValidationErrors?: Resolver<Maybe<Array<Maybe<ResolversTypes['KoboErrorNode']>>>, ParentType, ContextType>;
  numberOfHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  numberOfIndividuals?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  onlyActiveSubmissions?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ImportDataStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  validationErrors?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LabelNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LabelNode'] = ResolversParentTypes['LabelNode']> = {
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['LanguageObject'] = ResolversParentTypes['LanguageObject']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  english?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageObjectConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LanguageObjectConnection'] = ResolversParentTypes['LanguageObjectConnection']> = {
  edges?: Resolver<Array<Maybe<ResolversTypes['LanguageObjectEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LanguageObjectEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LanguageObjectEdge'] = ResolversParentTypes['LanguageObjectEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['LanguageObject']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LockTargetPopulationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['LockTargetPopulationMutation'] = ResolversParentTypes['LockTargetPopulationMutation']> = {
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogEntryNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogEntryNode'] = ResolversParentTypes['LogEntryNode']> = {
  action?: Resolver<ResolversTypes['LogEntryAction'], ParentType, ContextType>;
  businessArea?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  changes?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  contentType?: Resolver<Maybe<ResolversTypes['ContentTypeObjectType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isUserGenerated?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  objectId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  objectRepr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  programs?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<LogEntryNodeProgramsArgs>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogEntryNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogEntryNodeConnection'] = ResolversParentTypes['LogEntryNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['LogEntryNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogEntryNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LogEntryNodeEdge'] = ResolversParentTypes['LogEntryNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['LogEntryNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkPaymentAsFailedMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkPaymentAsFailedMutation'] = ResolversParentTypes['MarkPaymentAsFailedMutation']> = {
  payment?: Resolver<Maybe<ResolversTypes['PaymentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarkPaymentRecordAsFailedMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MarkPaymentRecordAsFailedMutation'] = ResolversParentTypes['MarkPaymentRecordAsFailedMutation']> = {
  paymentRecord?: Resolver<Maybe<ResolversTypes['PaymentRecordNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MergeRegistrationDataImportMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MergeRegistrationDataImportMutation'] = ResolversParentTypes['MergeRegistrationDataImportMutation']> = {
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutations'] = ResolversParentTypes['Mutations']> = {
  actionPaymentPlanMutation?: Resolver<Maybe<ResolversTypes['ActionPaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsActionPaymentPlanMutationArgs, 'input'>>;
  activatePaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['ActivatePaymentVerificationPlan']>, ParentType, ContextType, RequireFields<MutationsActivatePaymentVerificationPlanArgs, 'paymentVerificationPlanId'>>;
  approveAddIndividual?: Resolver<Maybe<ResolversTypes['SimpleApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveAddIndividualArgs, 'approveStatus' | 'grievanceTicketId'>>;
  approveDeleteHousehold?: Resolver<Maybe<ResolversTypes['DeleteHouseholdApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveDeleteHouseholdArgs, 'approveStatus' | 'grievanceTicketId'>>;
  approveDeleteIndividual?: Resolver<Maybe<ResolversTypes['SimpleApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveDeleteIndividualArgs, 'approveStatus' | 'grievanceTicketId'>>;
  approveHouseholdDataChange?: Resolver<Maybe<ResolversTypes['HouseholdDataChangeApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveHouseholdDataChangeArgs, 'grievanceTicketId'>>;
  approveIndividualDataChange?: Resolver<Maybe<ResolversTypes['IndividualDataChangeApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveIndividualDataChangeArgs, 'grievanceTicketId'>>;
  approveNeedsAdjudication?: Resolver<Maybe<ResolversTypes['NeedsAdjudicationApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveNeedsAdjudicationArgs, 'grievanceTicketId'>>;
  approvePaymentDetails?: Resolver<Maybe<ResolversTypes['PaymentDetailsApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApprovePaymentDetailsArgs, 'approveStatus' | 'grievanceTicketId'>>;
  approveSystemFlagging?: Resolver<Maybe<ResolversTypes['SimpleApproveMutation']>, ParentType, ContextType, RequireFields<MutationsApproveSystemFlaggingArgs, 'approveStatus' | 'grievanceTicketId'>>;
  assignFspToDeliveryMechanism?: Resolver<Maybe<ResolversTypes['AssignFspToDeliveryMechanismMutation']>, ParentType, ContextType, RequireFields<MutationsAssignFspToDeliveryMechanismArgs, 'input'>>;
  bulkGrievanceAddNote?: Resolver<Maybe<ResolversTypes['BulkGrievanceAddNoteMutation']>, ParentType, ContextType, RequireFields<MutationsBulkGrievanceAddNoteArgs, 'businessAreaSlug' | 'grievanceTicketIds' | 'note'>>;
  bulkUpdateGrievanceAssignee?: Resolver<Maybe<ResolversTypes['BulkUpdateGrievanceTicketsAssigneesMutation']>, ParentType, ContextType, RequireFields<MutationsBulkUpdateGrievanceAssigneeArgs, 'assignedTo' | 'businessAreaSlug' | 'grievanceTicketIds'>>;
  bulkUpdateGrievancePriority?: Resolver<Maybe<ResolversTypes['BulkUpdateGrievanceTicketsPriorityMutation']>, ParentType, ContextType, RequireFields<MutationsBulkUpdateGrievancePriorityArgs, 'businessAreaSlug' | 'grievanceTicketIds' | 'priority'>>;
  bulkUpdateGrievanceUrgency?: Resolver<Maybe<ResolversTypes['BulkUpdateGrievanceTicketsUrgencyMutation']>, ParentType, ContextType, RequireFields<MutationsBulkUpdateGrievanceUrgencyArgs, 'businessAreaSlug' | 'grievanceTicketIds' | 'urgency'>>;
  checkAgainstSanctionList?: Resolver<Maybe<ResolversTypes['CheckAgainstSanctionListMutation']>, ParentType, ContextType, RequireFields<MutationsCheckAgainstSanctionListArgs, 'file'>>;
  chooseDeliveryMechanismsForPaymentPlan?: Resolver<Maybe<ResolversTypes['ChooseDeliveryMechanismsForPaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsChooseDeliveryMechanismsForPaymentPlanArgs, 'input'>>;
  copyProgram?: Resolver<Maybe<ResolversTypes['CopyProgram']>, ParentType, ContextType, RequireFields<MutationsCopyProgramArgs, 'programData'>>;
  copyTargetPopulation?: Resolver<Maybe<ResolversTypes['CopyTargetPopulationMutationPayload']>, ParentType, ContextType, RequireFields<MutationsCopyTargetPopulationArgs, 'input'>>;
  createAccountabilityCommunicationMessage?: Resolver<Maybe<ResolversTypes['CreateCommunicationMessageMutation']>, ParentType, ContextType, RequireFields<MutationsCreateAccountabilityCommunicationMessageArgs, 'input'>>;
  createDashboardReport?: Resolver<Maybe<ResolversTypes['CreateDashboardReport']>, ParentType, ContextType, RequireFields<MutationsCreateDashboardReportArgs, 'reportData'>>;
  createFeedback?: Resolver<Maybe<ResolversTypes['CreateFeedbackMutation']>, ParentType, ContextType, RequireFields<MutationsCreateFeedbackArgs, 'input'>>;
  createFeedbackMessage?: Resolver<Maybe<ResolversTypes['CreateFeedbackMessageMutation']>, ParentType, ContextType, RequireFields<MutationsCreateFeedbackMessageArgs, 'input'>>;
  createFollowUpPaymentPlan?: Resolver<Maybe<ResolversTypes['CreateFollowUpPaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsCreateFollowUpPaymentPlanArgs, 'dispersionEndDate' | 'dispersionStartDate' | 'paymentPlanId'>>;
  createGrievanceTicket?: Resolver<Maybe<ResolversTypes['CreateGrievanceTicketMutation']>, ParentType, ContextType, RequireFields<MutationsCreateGrievanceTicketArgs, 'input'>>;
  createPaymentPlan?: Resolver<Maybe<ResolversTypes['CreatePaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsCreatePaymentPlanArgs, 'input'>>;
  createPaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['CreateVerificationPlanMutation']>, ParentType, ContextType, RequireFields<MutationsCreatePaymentVerificationPlanArgs, 'input'>>;
  createProgram?: Resolver<Maybe<ResolversTypes['CreateProgram']>, ParentType, ContextType, RequireFields<MutationsCreateProgramArgs, 'programData'>>;
  createReport?: Resolver<Maybe<ResolversTypes['CreateReport']>, ParentType, ContextType, RequireFields<MutationsCreateReportArgs, 'reportData'>>;
  createSurvey?: Resolver<Maybe<ResolversTypes['CreateSurveyMutation']>, ParentType, ContextType, RequireFields<MutationsCreateSurveyArgs, 'input'>>;
  createTargetPopulation?: Resolver<Maybe<ResolversTypes['CreateTargetPopulationMutation']>, ParentType, ContextType, RequireFields<MutationsCreateTargetPopulationArgs, 'input'>>;
  createTicketNote?: Resolver<Maybe<ResolversTypes['CreateTicketNoteMutation']>, ParentType, ContextType, RequireFields<MutationsCreateTicketNoteArgs, 'noteInput'>>;
  deletePaymentPlan?: Resolver<Maybe<ResolversTypes['DeletePaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsDeletePaymentPlanArgs, 'paymentPlanId'>>;
  deletePaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['DeletePaymentVerificationPlan']>, ParentType, ContextType, RequireFields<MutationsDeletePaymentVerificationPlanArgs, 'paymentVerificationPlanId'>>;
  deleteProgram?: Resolver<Maybe<ResolversTypes['DeleteProgram']>, ParentType, ContextType, RequireFields<MutationsDeleteProgramArgs, 'programId'>>;
  deleteRegistrationDataImport?: Resolver<Maybe<ResolversTypes['DeleteRegistrationDataImport']>, ParentType, ContextType, RequireFields<MutationsDeleteRegistrationDataImportArgs, 'registrationDataImportId'>>;
  deleteTargetPopulation?: Resolver<Maybe<ResolversTypes['DeleteTargetPopulationMutationPayload']>, ParentType, ContextType, RequireFields<MutationsDeleteTargetPopulationArgs, 'input'>>;
  discardPaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['DiscardPaymentVerificationPlan']>, ParentType, ContextType, RequireFields<MutationsDiscardPaymentVerificationPlanArgs, 'paymentVerificationPlanId'>>;
  editPaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['EditPaymentVerificationMutation']>, ParentType, ContextType, RequireFields<MutationsEditPaymentVerificationPlanArgs, 'input'>>;
  eraseRegistrationDataImport?: Resolver<Maybe<ResolversTypes['EraseRegistrationDataImportMutation']>, ParentType, ContextType, RequireFields<MutationsEraseRegistrationDataImportArgs, 'id'>>;
  excludeHouseholds?: Resolver<Maybe<ResolversTypes['ExcludeHouseholdsMutation']>, ParentType, ContextType, RequireFields<MutationsExcludeHouseholdsArgs, 'excludedHouseholdsIds' | 'paymentPlanId'>>;
  exportPdfPaymentPlanSummary?: Resolver<Maybe<ResolversTypes['ExportPDFPaymentPlanSummaryMutation']>, ParentType, ContextType, RequireFields<MutationsExportPdfPaymentPlanSummaryArgs, 'paymentPlanId'>>;
  exportSurveySample?: Resolver<Maybe<ResolversTypes['ExportSurveySampleMutationMutation']>, ParentType, ContextType, RequireFields<MutationsExportSurveySampleArgs, 'surveyId'>>;
  exportXlsxPaymentPlanPaymentList?: Resolver<Maybe<ResolversTypes['ExportXLSXPaymentPlanPaymentListMutation']>, ParentType, ContextType, RequireFields<MutationsExportXlsxPaymentPlanPaymentListArgs, 'paymentPlanId'>>;
  exportXlsxPaymentPlanPaymentListPerFsp?: Resolver<Maybe<ResolversTypes['ExportXLSXPaymentPlanPaymentListPerFSPMutation']>, ParentType, ContextType, RequireFields<MutationsExportXlsxPaymentPlanPaymentListPerFspArgs, 'paymentPlanId'>>;
  exportXlsxPaymentVerificationPlanFile?: Resolver<Maybe<ResolversTypes['ExportXlsxPaymentVerificationPlanFile']>, ParentType, ContextType, RequireFields<MutationsExportXlsxPaymentVerificationPlanFileArgs, 'paymentVerificationPlanId'>>;
  finalizeTargetPopulation?: Resolver<Maybe<ResolversTypes['FinalizeTargetPopulationMutation']>, ParentType, ContextType, RequireFields<MutationsFinalizeTargetPopulationArgs, 'id'>>;
  finishPaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['FinishPaymentVerificationPlan']>, ParentType, ContextType, RequireFields<MutationsFinishPaymentVerificationPlanArgs, 'paymentVerificationPlanId'>>;
  grievanceStatusChange?: Resolver<Maybe<ResolversTypes['GrievanceStatusChangeMutation']>, ParentType, ContextType, Partial<MutationsGrievanceStatusChangeArgs>>;
  importXlsxPaymentPlanPaymentList?: Resolver<Maybe<ResolversTypes['ImportXLSXPaymentPlanPaymentListMutation']>, ParentType, ContextType, RequireFields<MutationsImportXlsxPaymentPlanPaymentListArgs, 'file' | 'paymentPlanId'>>;
  importXlsxPaymentPlanPaymentListPerFsp?: Resolver<Maybe<ResolversTypes['ImportXLSXPaymentPlanPaymentListPerFSPMutation']>, ParentType, ContextType, RequireFields<MutationsImportXlsxPaymentPlanPaymentListPerFspArgs, 'file' | 'paymentPlanId'>>;
  importXlsxPaymentVerificationPlanFile?: Resolver<Maybe<ResolversTypes['ImportXlsxPaymentVerificationPlanFile']>, ParentType, ContextType, RequireFields<MutationsImportXlsxPaymentVerificationPlanFileArgs, 'file' | 'paymentVerificationPlanId'>>;
  invalidPaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['InvalidPaymentVerificationPlan']>, ParentType, ContextType, RequireFields<MutationsInvalidPaymentVerificationPlanArgs, 'paymentVerificationPlanId'>>;
  lockTargetPopulation?: Resolver<Maybe<ResolversTypes['LockTargetPopulationMutation']>, ParentType, ContextType, RequireFields<MutationsLockTargetPopulationArgs, 'id'>>;
  markPaymentAsFailed?: Resolver<Maybe<ResolversTypes['MarkPaymentAsFailedMutation']>, ParentType, ContextType, RequireFields<MutationsMarkPaymentAsFailedArgs, 'paymentId'>>;
  markPaymentRecordAsFailed?: Resolver<Maybe<ResolversTypes['MarkPaymentRecordAsFailedMutation']>, ParentType, ContextType, RequireFields<MutationsMarkPaymentRecordAsFailedArgs, 'paymentRecordId'>>;
  mergeRegistrationDataImport?: Resolver<Maybe<ResolversTypes['MergeRegistrationDataImportMutation']>, ParentType, ContextType, RequireFields<MutationsMergeRegistrationDataImportArgs, 'id'>>;
  reassignRole?: Resolver<Maybe<ResolversTypes['ReassignRoleMutation']>, ParentType, ContextType, RequireFields<MutationsReassignRoleArgs, 'grievanceTicketId' | 'householdId' | 'individualId' | 'role'>>;
  refuseRegistrationDataImport?: Resolver<Maybe<ResolversTypes['RefuseRegistrationDataImportMutation']>, ParentType, ContextType, RequireFields<MutationsRefuseRegistrationDataImportArgs, 'id'>>;
  registrationKoboImport?: Resolver<Maybe<ResolversTypes['RegistrationKoboImportMutation']>, ParentType, ContextType, RequireFields<MutationsRegistrationKoboImportArgs, 'registrationDataImportData'>>;
  registrationXlsxImport?: Resolver<Maybe<ResolversTypes['RegistrationXlsxImportMutation']>, ParentType, ContextType, RequireFields<MutationsRegistrationXlsxImportArgs, 'registrationDataImportData'>>;
  rerunDedupe?: Resolver<Maybe<ResolversTypes['RegistrationDeduplicationMutation']>, ParentType, ContextType, RequireFields<MutationsRerunDedupeArgs, 'registrationDataImportDatahubId'>>;
  restartCreateReport?: Resolver<Maybe<ResolversTypes['RestartCreateReport']>, ParentType, ContextType, RequireFields<MutationsRestartCreateReportArgs, 'reportData'>>;
  revertMarkPaymentAsFailed?: Resolver<Maybe<ResolversTypes['RevertMarkPaymentAsFailedMutation']>, ParentType, ContextType, RequireFields<MutationsRevertMarkPaymentAsFailedArgs, 'deliveredQuantity' | 'deliveryDate' | 'paymentId'>>;
  revertMarkPaymentRecordAsFailed?: Resolver<Maybe<ResolversTypes['RevertMarkPaymentRecordAsFailedMutation']>, ParentType, ContextType, RequireFields<MutationsRevertMarkPaymentRecordAsFailedArgs, 'deliveredQuantity' | 'deliveryDate' | 'paymentRecordId'>>;
  saveKoboImportDataAsync?: Resolver<Maybe<ResolversTypes['SaveKoboProjectImportDataAsync']>, ParentType, ContextType, RequireFields<MutationsSaveKoboImportDataAsyncArgs, 'businessAreaSlug' | 'onlyActiveSubmissions' | 'uid'>>;
  setSteficonRuleOnPaymentPlanPaymentList?: Resolver<Maybe<ResolversTypes['SetSteficonRuleOnPaymentPlanPaymentListMutation']>, ParentType, ContextType, RequireFields<MutationsSetSteficonRuleOnPaymentPlanPaymentListArgs, 'paymentPlanId' | 'steficonRuleId'>>;
  setSteficonRuleOnTargetPopulation?: Resolver<Maybe<ResolversTypes['SetSteficonRuleOnTargetPopulationMutationPayload']>, ParentType, ContextType, RequireFields<MutationsSetSteficonRuleOnTargetPopulationArgs, 'input'>>;
  splitPaymentPlan?: Resolver<Maybe<ResolversTypes['SplitPaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsSplitPaymentPlanArgs, 'paymentPlanId' | 'splitType'>>;
  targetPopulationRebuild?: Resolver<Maybe<ResolversTypes['RebuildTargetPopulationMutation']>, ParentType, ContextType, RequireFields<MutationsTargetPopulationRebuildArgs, 'id'>>;
  unlockTargetPopulation?: Resolver<Maybe<ResolversTypes['UnlockTargetPopulationMutation']>, ParentType, ContextType, RequireFields<MutationsUnlockTargetPopulationArgs, 'id'>>;
  updateFeedback?: Resolver<Maybe<ResolversTypes['UpdateFeedbackMutation']>, ParentType, ContextType, RequireFields<MutationsUpdateFeedbackArgs, 'input'>>;
  updateGrievanceTicket?: Resolver<Maybe<ResolversTypes['UpdateGrievanceTicketMutation']>, ParentType, ContextType, RequireFields<MutationsUpdateGrievanceTicketArgs, 'input'>>;
  updatePaymentPlan?: Resolver<Maybe<ResolversTypes['UpdatePaymentPlanMutation']>, ParentType, ContextType, RequireFields<MutationsUpdatePaymentPlanArgs, 'input'>>;
  updatePaymentVerificationReceivedAndReceivedAmount?: Resolver<Maybe<ResolversTypes['UpdatePaymentVerificationReceivedAndReceivedAmount']>, ParentType, ContextType, RequireFields<MutationsUpdatePaymentVerificationReceivedAndReceivedAmountArgs, 'paymentVerificationId' | 'received' | 'receivedAmount'>>;
  updatePaymentVerificationStatusAndReceivedAmount?: Resolver<Maybe<ResolversTypes['UpdatePaymentVerificationStatusAndReceivedAmount']>, ParentType, ContextType, RequireFields<MutationsUpdatePaymentVerificationStatusAndReceivedAmountArgs, 'paymentVerificationId' | 'receivedAmount'>>;
  updateProgram?: Resolver<Maybe<ResolversTypes['UpdateProgram']>, ParentType, ContextType, Partial<MutationsUpdateProgramArgs>>;
  updateTargetPopulation?: Resolver<Maybe<ResolversTypes['UpdateTargetPopulationMutation']>, ParentType, ContextType, RequireFields<MutationsUpdateTargetPopulationArgs, 'input'>>;
  uploadImportDataXlsxFileAsync?: Resolver<Maybe<ResolversTypes['UploadImportDataXLSXFileAsync']>, ParentType, ContextType, RequireFields<MutationsUploadImportDataXlsxFileAsyncArgs, 'businessAreaSlug' | 'file'>>;
};

export type NeedsAdjudicationApproveMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['NeedsAdjudicationApproveMutation'] = ResolversParentTypes['NeedsAdjudicationApproveMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'ApprovalProcessNode' | 'AreaNode' | 'AreaTypeNode' | 'BankAccountInfoNode' | 'BusinessAreaNode' | 'CashPlanNode' | 'CommunicationMessageNode' | 'CommunicationMessageRecipientMapNode' | 'DataCollectingTypeNode' | 'DeliveryMechanismNode' | 'DocumentNode' | 'FeedbackMessageNode' | 'FeedbackNode' | 'FinancialServiceProviderNode' | 'FinancialServiceProviderXlsxReportNode' | 'FinancialServiceProviderXlsxTemplateNode' | 'GrievanceDocumentNode' | 'GrievanceTicketNode' | 'HouseholdNode' | 'ImportDataNode' | 'ImportedDocumentNode' | 'ImportedHouseholdNode' | 'ImportedIndividualIdentityNode' | 'ImportedIndividualNode' | 'IndividualIdentityNode' | 'IndividualNode' | 'KoboImportDataNode' | 'LogEntryNode' | 'PaymentHouseholdSnapshotNode' | 'PaymentNode' | 'PaymentPlanNode' | 'PaymentRecordNode' | 'PaymentVerificationLogEntryNode' | 'PaymentVerificationNode' | 'PaymentVerificationPlanNode' | 'PaymentVerificationSummaryNode' | 'ProgramNode' | 'RecipientNode' | 'RegistrationDataImportDatahubNode' | 'RegistrationDataImportNode' | 'ReportNode' | 'RuleCommitNode' | 'SanctionListIndividualAliasNameNode' | 'SanctionListIndividualCountriesNode' | 'SanctionListIndividualDateOfBirthNode' | 'SanctionListIndividualDocumentNode' | 'SanctionListIndividualNationalitiesNode' | 'SanctionListIndividualNode' | 'ServiceProviderNode' | 'SteficonRuleNode' | 'SurveyNode' | 'TargetPopulationNode' | 'TicketAddIndividualDetailsNode' | 'TicketComplaintDetailsNode' | 'TicketDeleteHouseholdDetailsNode' | 'TicketDeleteIndividualDetailsNode' | 'TicketHouseholdDataUpdateDetailsNode' | 'TicketIndividualDataUpdateDetailsNode' | 'TicketNeedsAdjudicationDetailsNode' | 'TicketNegativeFeedbackDetailsNode' | 'TicketNoteNode' | 'TicketPaymentVerificationDetailsNode' | 'TicketPositiveFeedbackDetailsNode' | 'TicketReferralDetailsNode' | 'TicketSensitiveDetailsNode' | 'TicketSystemFlaggingDetailsNode' | 'UserBusinessAreaNode' | 'UserNode' | 'VolumeByDeliveryMechanismNode', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfoNode'] = ResolversParentTypes['PageInfoNode']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  hasPreviousPage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaginatedCashPlanAndPaymentPlanNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaginatedCashPlanAndPaymentPlanNode'] = ResolversParentTypes['PaginatedCashPlanAndPaymentPlanNode']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['CashPlanAndPaymentPlanEdges']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<Maybe<ResolversTypes['PageInfoNode']>, ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaginatedPaymentRecordsAndPaymentsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaginatedPaymentRecordsAndPaymentsNode'] = ResolversParentTypes['PaginatedPaymentRecordsAndPaymentsNode']> = {
  edges?: Resolver<Maybe<Array<Maybe<ResolversTypes['PaymentRecordsAndPaymentsEdges']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<Maybe<ResolversTypes['PageInfoNode']>, ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PartnerNodeForProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['PartnerNodeForProgram'] = ResolversParentTypes['PartnerNodeForProgram']> = {
  adminAreas?: Resolver<Maybe<Array<Maybe<ResolversTypes['AreaGroupNode']>>>, ParentType, ContextType>;
  allowedBusinessAreas?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<PartnerNodeForProgramAllowedBusinessAreasArgs>>;
  areaAccess?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grievanceticketSet?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<PartnerNodeForProgramGrievanceticketSetArgs>>;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  individualIdentities?: Resolver<ResolversTypes['IndividualIdentityNodeConnection'], ParentType, ContextType, Partial<PartnerNodeForProgramIndividualIdentitiesArgs>>;
  isUn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  lft?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  partnerSet?: Resolver<Array<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  permissions?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  rght?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  treeId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userSet?: Resolver<ResolversTypes['UserNodeConnection'], ParentType, ContextType, Partial<PartnerNodeForProgramUserSetArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PartnerTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PartnerType'] = ResolversParentTypes['PartnerType']> = {
  allowedBusinessAreas?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<PartnerTypeAllowedBusinessAreasArgs>>;
  grievanceticketSet?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<PartnerTypeGrievanceticketSetArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualIdentities?: Resolver<ResolversTypes['IndividualIdentityNodeConnection'], ParentType, ContextType, Partial<PartnerTypeIndividualIdentitiesArgs>>;
  isUn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  lft?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  partnerSet?: Resolver<Array<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  permissions?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  rght?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  treeId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userSet?: Resolver<ResolversTypes['UserNodeConnection'], ParentType, ContextType, Partial<PartnerTypeUserSetArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentConflictDataNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentConflictDataNode'] = ResolversParentTypes['PaymentConflictDataNode']> = {
  paymentId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentPlanEndDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentPlanId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentPlanStartDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentPlanStatus?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentPlanUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentUnicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentDetailsApproveMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentDetailsApproveMutation'] = ResolversParentTypes['PaymentDetailsApproveMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentHouseholdSnapshotNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentHouseholdSnapshotNode'] = ResolversParentTypes['PaymentHouseholdSnapshotNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  householdId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  payment?: Resolver<ResolversTypes['PaymentNode'], ParentType, ContextType>;
  snapshotData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentNode'] = ResolversParentTypes['PaymentNode']> = {
  additionalCollectorName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalDocumentNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalDocumentType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  collector?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  conflicted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  debitCardIssuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  debitCardNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveryDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deliveryType?: Resolver<Maybe<ResolversTypes['PaymentDeliveryType']>, ParentType, ContextType>;
  distributionModality?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entitlementDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  entitlementQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  entitlementQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  excluded?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  financialServiceProvider?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNode']>, ParentType, ContextType>;
  followUps?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<PaymentNodeFollowUpsArgs>>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  headOfHousehold?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  household?: Resolver<ResolversTypes['HouseholdNode'], ParentType, ContextType>;
  householdSnapshot?: Resolver<Maybe<ResolversTypes['PaymentHouseholdSnapshotNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isFollowUp?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  orderNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  parent?: Resolver<ResolversTypes['PaymentPlanNode'], ParentType, ContextType>;
  paymentPlanHardConflicted?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  paymentPlanHardConflictedData?: Resolver<Maybe<Array<Maybe<ResolversTypes['PaymentConflictDataNode']>>>, ParentType, ContextType>;
  paymentPlanSoftConflicted?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  paymentPlanSoftConflictedData?: Resolver<Maybe<Array<Maybe<ResolversTypes['PaymentConflictDataNode']>>>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  reasonForUnsuccessfulPayment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  serviceProvider?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNode']>, ParentType, ContextType>;
  signatureHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  snapshotCollectorBankAccountNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  snapshotCollectorBankName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  snapshotCollectorDebitCardNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  snapshotCollectorDeliveryPhoneNo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  snapshotCollectorFullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sourcePayment?: Resolver<Maybe<ResolversTypes['PaymentNode']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['PaymentStatus'], ParentType, ContextType>;
  statusDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  tokenNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalPersonsCovered?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  transactionReferenceId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentNodeConnection'] = ResolversParentTypes['PaymentNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentNodeEdge'] = ResolversParentTypes['PaymentNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentPlanNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentPlanNode'] = ResolversParentTypes['PaymentPlanNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  approvalProcess?: Resolver<ResolversTypes['ApprovalProcessNodeConnection'], ParentType, ContextType, Partial<PaymentPlanNodeApprovalProcessArgs>>;
  availablePaymentRecordsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  backgroundActionStatus?: Resolver<Maybe<ResolversTypes['PaymentPlanBackgroundActionStatus']>, ParentType, ContextType>;
  bankReconciliationError?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  bankReconciliationSuccess?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  canCreateFollowUp?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  canCreatePaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  canSendToPaymentGateway?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  canSplit?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<ResolversTypes['UserNode'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['PaymentPlanCurrency'], ParentType, ContextType>;
  currencyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryMechanisms?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeliveryMechanismNode']>>>, ParentType, ContextType>;
  dispersionEndDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  dispersionStartDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  exchangeRate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  excludeHouseholdError?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excludedHouseholds?: Resolver<Maybe<Array<Maybe<ResolversTypes['HouseholdNode']>>>, ParentType, ContextType>;
  exclusionReason?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  femaleAdultsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  femaleChildrenCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  followUps?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<PaymentPlanNodeFollowUpsArgs>>;
  hasFspDeliveryMechanismXlsxTemplate?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  hasPaymentListExportFile?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importedFileDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  importedFileName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isFollowUp?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  maleAdultsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  maleChildrenCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentItems?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<PaymentPlanNodePaymentItemsArgs>>;
  paymentVerificationSummary?: Resolver<Maybe<ResolversTypes['PaymentVerificationSummaryNode']>, ParentType, ContextType>;
  paymentsConflictsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  program?: Resolver<ResolversTypes['ProgramNode'], ParentType, ContextType>;
  reconciliationSummary?: Resolver<Maybe<ResolversTypes['ReconciliationSummaryNode']>, ParentType, ContextType>;
  sourcePaymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  splitChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['PaymentPlanStatus'], ParentType, ContextType>;
  statusDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  steficonAppliedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  steficonRule?: Resolver<Maybe<ResolversTypes['RuleCommitNode']>, ParentType, ContextType>;
  targetPopulation?: Resolver<ResolversTypes['TargetPopulationNode'], ParentType, ContextType>;
  totalDeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalDeliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantityRevised?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantityRevisedUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalEntitledQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalHouseholdsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalIndividualsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalUndeliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalUndeliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalWithdrawnHouseholdsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unsuccessfulPaymentsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verificationPlans?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNodeConnection']>, ParentType, ContextType, Partial<PaymentPlanNodeVerificationPlansArgs>>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  volumeByDeliveryMechanism?: Resolver<Maybe<Array<Maybe<ResolversTypes['VolumeByDeliveryMechanismNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentPlanNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentPlanNodeConnection'] = ResolversParentTypes['PaymentPlanNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentPlanNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentPlanNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentPlanNodeEdge'] = ResolversParentTypes['PaymentPlanNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentRecordAndPaymentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentRecordAndPaymentNode'] = ResolversParentTypes['PaymentRecordAndPaymentNode']> = {
  caId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveryDate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entitlementQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  objType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['CashPlanAndPaymentPlanNode']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentRecordNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentRecordNode'] = ResolversParentTypes['PaymentRecordNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  caHashId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  caId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  deliveredQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveredQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  deliveryDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deliveryType?: Resolver<Maybe<ResolversTypes['PaymentRecordDeliveryType']>, ParentType, ContextType>;
  distributionModality?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  entitlementCardIssueDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entitlementCardNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  entitlementCardStatus?: Resolver<Maybe<ResolversTypes['PaymentRecordEntitlementCardStatus']>, ParentType, ContextType>;
  entitlementQuantity?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  entitlementQuantityUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headOfHousehold?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  household?: Resolver<ResolversTypes['HouseholdNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['CashPlanNode']>, ParentType, ContextType>;
  registrationCaId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  serviceProvider?: Resolver<ResolversTypes['ServiceProviderNode'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['PaymentRecordStatus'], ParentType, ContextType>;
  statusDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  targetPopulation?: Resolver<ResolversTypes['TargetPopulationNode'], ParentType, ContextType>;
  targetPopulationCashAssistId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalPersonsCovered?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  transactionReferenceId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  visionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentRecordNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentRecordNodeConnection'] = ResolversParentTypes['PaymentRecordNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentRecordNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentRecordNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentRecordNodeEdge'] = ResolversParentTypes['PaymentRecordNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentRecordNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentRecordsAndPaymentsEdgesResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentRecordsAndPaymentsEdges'] = ResolversParentTypes['PaymentRecordsAndPaymentsEdges']> = {
  cursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentRecordAndPaymentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationLogEntryNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationLogEntryNode'] = ResolversParentTypes['PaymentVerificationLogEntryNode']> = {
  action?: Resolver<ResolversTypes['LogEntryAction'], ParentType, ContextType>;
  businessArea?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  changes?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  contentObject?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNode']>, ParentType, ContextType>;
  contentType?: Resolver<Maybe<ResolversTypes['ContentTypeObjectType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isUserGenerated?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  objectId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  objectRepr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  programs?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<PaymentVerificationLogEntryNodeProgramsArgs>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationLogEntryNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationLogEntryNodeConnection'] = ResolversParentTypes['PaymentVerificationLogEntryNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentVerificationLogEntryNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationLogEntryNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationLogEntryNodeEdge'] = ResolversParentTypes['PaymentVerificationLogEntryNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentVerificationLogEntryNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationNode'] = ResolversParentTypes['PaymentVerificationNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isManuallyEditable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['GenericPaymentNode']>, ParentType, ContextType>;
  paymentContentType?: Resolver<ResolversTypes['ContentTypeObjectType'], ParentType, ContextType>;
  paymentObjectId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  paymentVerificationPlan?: Resolver<ResolversTypes['PaymentVerificationPlanNode'], ParentType, ContextType>;
  receivedAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  sentToRapidPro?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['PaymentVerificationStatus'], ParentType, ContextType>;
  statusDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  ticketDetail?: Resolver<ResolversTypes['TicketPaymentVerificationDetailsNodeConnection'], ParentType, ContextType, Partial<PaymentVerificationNodeTicketDetailArgs>>;
  ticketDetails?: Resolver<ResolversTypes['TicketPaymentVerificationDetailsNodeConnection'], ParentType, ContextType, Partial<PaymentVerificationNodeTicketDetailsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationNodeConnection'] = ResolversParentTypes['PaymentVerificationNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentVerificationNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationNodeEdge'] = ResolversParentTypes['PaymentVerificationNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationPlanNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationPlanNode'] = ResolversParentTypes['PaymentVerificationPlanNode']> = {
  activationDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ageFilter?: Resolver<Maybe<ResolversTypes['AgeFilterObject']>, ParentType, ContextType>;
  completionDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  confidenceInterval?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  excludedAdminAreasFilter?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  hasXlsxFile?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  marginOfError?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  notReceivedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  paymentPlanContentType?: Resolver<ResolversTypes['ContentTypeObjectType'], ParentType, ContextType>;
  paymentPlanObjectId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  paymentRecordVerifications?: Resolver<ResolversTypes['PaymentVerificationNodeConnection'], ParentType, ContextType, Partial<PaymentVerificationPlanNodePaymentRecordVerificationsArgs>>;
  rapidProFlowId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rapidProFlowStartUuids?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  receivedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  receivedWithProblemsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  respondedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sampleSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sampling?: Resolver<ResolversTypes['PaymentVerificationPlanSampling'], ParentType, ContextType>;
  sexFilter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['PaymentVerificationPlanStatus'], ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  verificationChannel?: Resolver<ResolversTypes['PaymentVerificationPlanVerificationChannel'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  xlsxFileExporting?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  xlsxFileImported?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  xlsxFileWasDownloaded?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationPlanNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationPlanNodeConnection'] = ResolversParentTypes['PaymentVerificationPlanNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentVerificationPlanNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationPlanNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationPlanNodeEdge'] = ResolversParentTypes['PaymentVerificationPlanNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationSummaryNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationSummaryNode'] = ResolversParentTypes['PaymentVerificationSummaryNode']> = {
  activationDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  completionDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  paymentPlanContentType?: Resolver<ResolversTypes['ContentTypeObjectType'], ParentType, ContextType>;
  paymentPlanObjectId?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['PaymentVerificationSummaryStatus'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationSummaryNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationSummaryNodeConnection'] = ResolversParentTypes['PaymentVerificationSummaryNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['PaymentVerificationSummaryNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVerificationSummaryNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVerificationSummaryNodeEdge'] = ResolversParentTypes['PaymentVerificationSummaryNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PaymentVerificationSummaryNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProgramNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProgramNode'] = ResolversParentTypes['ProgramNode']> = {
  activityLogs?: Resolver<ResolversTypes['PaymentVerificationLogEntryNodeConnection'], ParentType, ContextType, Partial<ProgramNodeActivityLogsArgs>>;
  adminAreas?: Resolver<ResolversTypes['AreaNodeConnection'], ParentType, ContextType, Partial<ProgramNodeAdminAreasArgs>>;
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  administrativeAreasOfImplementation?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  budget?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  caHashId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  caId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cashPlus?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  cashplanSet?: Resolver<ResolversTypes['CashPlanNodeConnection'], ParentType, ContextType, Partial<ProgramNodeCashplanSetArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataCollectingType?: Resolver<Maybe<ResolversTypes['DataCollectingTypeNode']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  endDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  feedbackSet?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<ProgramNodeFeedbackSetArgs>>;
  frequencyOfPayments?: Resolver<ResolversTypes['ProgramFrequencyOfPayments'], ParentType, ContextType>;
  grievanceTickets?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<ProgramNodeGrievanceTicketsArgs>>;
  householdCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  householdSet?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<ProgramNodeHouseholdSetArgs>>;
  households?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<ProgramNodeHouseholdsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  individuals?: Resolver<ResolversTypes['IndividualNodeConnection'], ParentType, ContextType, Partial<ProgramNodeIndividualsArgs>>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSocialWorkerProgram?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isVisible?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastSyncAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  messages?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<ProgramNodeMessagesArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  partners?: Resolver<Maybe<Array<Maybe<ResolversTypes['PartnerNodeForProgram']>>>, ParentType, ContextType>;
  paymentSet?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<ProgramNodePaymentSetArgs>>;
  paymentplanSet?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<ProgramNodePaymentplanSetArgs>>;
  populationGoal?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  programmeCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registrationImports?: Resolver<ResolversTypes['RegistrationDataImportNodeConnection'], ParentType, ContextType, Partial<ProgramNodeRegistrationImportsArgs>>;
  reports?: Resolver<ResolversTypes['ReportNodeConnection'], ParentType, ContextType, Partial<ProgramNodeReportsArgs>>;
  scope?: Resolver<Maybe<ResolversTypes['ProgramScope']>, ParentType, ContextType>;
  sector?: Resolver<ResolversTypes['ProgramSector'], ParentType, ContextType>;
  startDate?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ProgramStatus'], ParentType, ContextType>;
  surveys?: Resolver<ResolversTypes['SurveyNodeConnection'], ParentType, ContextType, Partial<ProgramNodeSurveysArgs>>;
  targetpopulationSet?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<ProgramNodeTargetpopulationSetArgs>>;
  totalDeliveredQuantity?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  totalEntitledQuantity?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  totalNumberOfHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalNumberOfHouseholdsWithTpInProgram?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalUndeliveredQuantity?: Resolver<Maybe<ResolversTypes['Decimal']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProgramNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProgramNodeConnection'] = ResolversParentTypes['ProgramNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ProgramNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProgramNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProgramNodeEdge'] = ResolversParentTypes['ProgramNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  _debug?: Resolver<Maybe<ResolversTypes['DjangoDebug']>, ParentType, ContextType>;
  accountabilityCommunicationMessage?: Resolver<Maybe<ResolversTypes['CommunicationMessageNode']>, ParentType, ContextType, RequireFields<QueryAccountabilityCommunicationMessageArgs, 'id'>>;
  accountabilityCommunicationMessageSampleSize?: Resolver<Maybe<ResolversTypes['GetCommunicationMessageSampleSizeNode']>, ParentType, ContextType, Partial<QueryAccountabilityCommunicationMessageSampleSizeArgs>>;
  accountabilitySampleSize?: Resolver<Maybe<ResolversTypes['AccountabilitySampleSizeNode']>, ParentType, ContextType, Partial<QueryAccountabilitySampleSizeArgs>>;
  adminArea?: Resolver<Maybe<ResolversTypes['AreaNode']>, ParentType, ContextType, RequireFields<QueryAdminAreaArgs, 'id'>>;
  allAccountabilityCommunicationMessageRecipients?: Resolver<Maybe<ResolversTypes['CommunicationMessageRecipientMapNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllAccountabilityCommunicationMessageRecipientsArgs, 'messageId'>>;
  allAccountabilityCommunicationMessages?: Resolver<Maybe<ResolversTypes['CommunicationMessageNodeConnection']>, ParentType, ContextType, Partial<QueryAllAccountabilityCommunicationMessagesArgs>>;
  allActivePrograms?: Resolver<Maybe<ResolversTypes['ProgramNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllActiveProgramsArgs, 'businessArea'>>;
  allActiveTargetPopulations?: Resolver<Maybe<ResolversTypes['TargetPopulationNodeConnection']>, ParentType, ContextType, Partial<QueryAllActiveTargetPopulationsArgs>>;
  allAddIndividualsFieldsAttributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['FieldAttributeNode']>>>, ParentType, ContextType>;
  allAdminAreas?: Resolver<Maybe<ResolversTypes['AreaNodeConnection']>, ParentType, ContextType, Partial<QueryAllAdminAreasArgs>>;
  allAreasTree?: Resolver<Maybe<Array<Maybe<ResolversTypes['AreaTreeNode']>>>, ParentType, ContextType, RequireFields<QueryAllAreasTreeArgs, 'businessArea'>>;
  allBusinessAreas?: Resolver<Maybe<ResolversTypes['BusinessAreaNodeConnection']>, ParentType, ContextType, Partial<QueryAllBusinessAreasArgs>>;
  allCashPlans?: Resolver<Maybe<ResolversTypes['CashPlanNodeConnection']>, ParentType, ContextType, Partial<QueryAllCashPlansArgs>>;
  allCashPlansAndPaymentPlans?: Resolver<Maybe<ResolversTypes['PaginatedCashPlanAndPaymentPlanNode']>, ParentType, ContextType, RequireFields<QueryAllCashPlansAndPaymentPlansArgs, 'businessArea'>>;
  allDeliveryMechanisms?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  allEditHouseholdFieldsAttributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['FieldAttributeNode']>>>, ParentType, ContextType>;
  allFeedbacks?: Resolver<Maybe<ResolversTypes['FeedbackNodeConnection']>, ParentType, ContextType, Partial<QueryAllFeedbacksArgs>>;
  allFieldsAttributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['FieldAttributeNode']>>>, ParentType, ContextType, Partial<QueryAllFieldsAttributesArgs>>;
  allFinancialServiceProviderXlsxReports?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderXlsxReportNodeConnection']>, ParentType, ContextType, Partial<QueryAllFinancialServiceProviderXlsxReportsArgs>>;
  allFinancialServiceProviderXlsxTemplates?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderXlsxTemplateNodeConnection']>, ParentType, ContextType, Partial<QueryAllFinancialServiceProviderXlsxTemplatesArgs>>;
  allFinancialServiceProviders?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNodeConnection']>, ParentType, ContextType, Partial<QueryAllFinancialServiceProvidersArgs>>;
  allGrievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllGrievanceTicketArgs, 'businessArea'>>;
  allGroupsWithFields?: Resolver<Maybe<Array<Maybe<ResolversTypes['GroupAttributeNode']>>>, ParentType, ContextType>;
  allHouseholds?: Resolver<Maybe<ResolversTypes['HouseholdNodeConnection']>, ParentType, ContextType, Partial<QueryAllHouseholdsArgs>>;
  allHouseholdsFlexFieldsAttributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['FieldAttributeNode']>>>, ParentType, ContextType>;
  allImportedHouseholds?: Resolver<Maybe<ResolversTypes['ImportedHouseholdNodeConnection']>, ParentType, ContextType, Partial<QueryAllImportedHouseholdsArgs>>;
  allImportedIndividuals?: Resolver<Maybe<ResolversTypes['ImportedIndividualNodeConnection']>, ParentType, ContextType, Partial<QueryAllImportedIndividualsArgs>>;
  allIndividuals?: Resolver<Maybe<ResolversTypes['IndividualNodeConnection']>, ParentType, ContextType, Partial<QueryAllIndividualsArgs>>;
  allIndividualsFlexFieldsAttributes?: Resolver<Maybe<Array<Maybe<ResolversTypes['FieldAttributeNode']>>>, ParentType, ContextType>;
  allKoboProjects?: Resolver<Maybe<ResolversTypes['KoboAssetObjectConnection']>, ParentType, ContextType, RequireFields<QueryAllKoboProjectsArgs, 'businessAreaSlug'>>;
  allLanguages?: Resolver<Maybe<ResolversTypes['LanguageObjectConnection']>, ParentType, ContextType, Partial<QueryAllLanguagesArgs>>;
  allLogEntries?: Resolver<Maybe<ResolversTypes['LogEntryNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllLogEntriesArgs, 'businessArea'>>;
  allMergedHouseholds?: Resolver<Maybe<ResolversTypes['HouseholdNodeConnection']>, ParentType, ContextType, Partial<QueryAllMergedHouseholdsArgs>>;
  allMergedIndividuals?: Resolver<Maybe<ResolversTypes['IndividualNodeConnection']>, ParentType, ContextType, Partial<QueryAllMergedIndividualsArgs>>;
  allPaymentPlans?: Resolver<Maybe<ResolversTypes['PaymentPlanNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllPaymentPlansArgs, 'businessArea'>>;
  allPaymentRecords?: Resolver<Maybe<ResolversTypes['PaymentRecordNodeConnection']>, ParentType, ContextType, Partial<QueryAllPaymentRecordsArgs>>;
  allPaymentRecordsAndPayments?: Resolver<Maybe<ResolversTypes['PaginatedPaymentRecordsAndPaymentsNode']>, ParentType, ContextType, RequireFields<QueryAllPaymentRecordsAndPaymentsArgs, 'businessArea'>>;
  allPaymentVerificationLogEntries?: Resolver<Maybe<ResolversTypes['PaymentVerificationLogEntryNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllPaymentVerificationLogEntriesArgs, 'businessArea'>>;
  allPaymentVerificationPlan?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNodeConnection']>, ParentType, ContextType, Partial<QueryAllPaymentVerificationPlanArgs>>;
  allPaymentVerifications?: Resolver<Maybe<ResolversTypes['PaymentVerificationNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllPaymentVerificationsArgs, 'businessArea'>>;
  allPayments?: Resolver<Maybe<ResolversTypes['PaymentNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllPaymentsArgs, 'businessArea' | 'paymentPlanId'>>;
  allPrograms?: Resolver<Maybe<ResolversTypes['ProgramNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllProgramsArgs, 'businessArea'>>;
  allRapidProFlows?: Resolver<Maybe<Array<Maybe<ResolversTypes['RapidProFlow']>>>, ParentType, ContextType, RequireFields<QueryAllRapidProFlowsArgs, 'businessAreaSlug'>>;
  allRegistrationDataImports?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNodeConnection']>, ParentType, ContextType, Partial<QueryAllRegistrationDataImportsArgs>>;
  allRegistrationDataImportsDatahub?: Resolver<Maybe<ResolversTypes['RegistrationDataImportDatahubNodeConnection']>, ParentType, ContextType, Partial<QueryAllRegistrationDataImportsDatahubArgs>>;
  allReports?: Resolver<Maybe<ResolversTypes['ReportNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllReportsArgs, 'businessArea'>>;
  allSanctionListIndividuals?: Resolver<Maybe<ResolversTypes['SanctionListIndividualNodeConnection']>, ParentType, ContextType, Partial<QueryAllSanctionListIndividualsArgs>>;
  allSteficonRules?: Resolver<Maybe<ResolversTypes['SteficonRuleNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllSteficonRulesArgs, 'type'>>;
  allSurveys?: Resolver<Maybe<ResolversTypes['SurveyNodeConnection']>, ParentType, ContextType, Partial<QueryAllSurveysArgs>>;
  allTargetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNodeConnection']>, ParentType, ContextType, Partial<QueryAllTargetPopulationArgs>>;
  allTicketNotes?: Resolver<Maybe<ResolversTypes['TicketNoteNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllTicketNotesArgs, 'ticket'>>;
  allUsers?: Resolver<Maybe<ResolversTypes['UserNodeConnection']>, ParentType, ContextType, RequireFields<QueryAllUsersArgs, 'businessArea'>>;
  availableFspsForDeliveryMechanisms?: Resolver<Maybe<Array<Maybe<ResolversTypes['FspChoices']>>>, ParentType, ContextType, Partial<QueryAvailableFspsForDeliveryMechanismsArgs>>;
  businessArea?: Resolver<Maybe<ResolversTypes['BusinessAreaNode']>, ParentType, ContextType, RequireFields<QueryBusinessAreaArgs, 'businessAreaSlug'>>;
  cashAssistUrlPrefix?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  cashPlan?: Resolver<Maybe<ResolversTypes['CashPlanNode']>, ParentType, ContextType, RequireFields<QueryCashPlanArgs, 'id'>>;
  cashPlanStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  cashPlanVerificationSamplingChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  cashPlanVerificationStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  cashPlanVerificationVerificationChannelChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  chartGrievances?: Resolver<Maybe<ResolversTypes['ChartGrievanceTicketsNode']>, ParentType, ContextType, RequireFields<QueryChartGrievancesArgs, 'businessAreaSlug' | 'year'>>;
  chartIndividualsReachedByAgeAndGender?: Resolver<Maybe<ResolversTypes['ChartDatasetNode']>, ParentType, ContextType, RequireFields<QueryChartIndividualsReachedByAgeAndGenderArgs, 'businessAreaSlug' | 'year'>>;
  chartIndividualsWithDisabilityReachedByAge?: Resolver<Maybe<ResolversTypes['ChartDetailedDatasetsNode']>, ParentType, ContextType, RequireFields<QueryChartIndividualsWithDisabilityReachedByAgeArgs, 'businessAreaSlug' | 'year'>>;
  chartPayment?: Resolver<Maybe<ResolversTypes['ChartDatasetNode']>, ParentType, ContextType, RequireFields<QueryChartPaymentArgs, 'businessAreaSlug' | 'year'>>;
  chartPaymentVerification?: Resolver<Maybe<ResolversTypes['ChartPaymentVerification']>, ParentType, ContextType, RequireFields<QueryChartPaymentVerificationArgs, 'businessAreaSlug' | 'year'>>;
  chartProgrammesBySector?: Resolver<Maybe<ResolversTypes['ChartDetailedDatasetsNode']>, ParentType, ContextType, RequireFields<QueryChartProgrammesBySectorArgs, 'businessAreaSlug' | 'year'>>;
  chartTotalTransferredByMonth?: Resolver<Maybe<ResolversTypes['ChartDetailedDatasetsNode']>, ParentType, ContextType, RequireFields<QueryChartTotalTransferredByMonthArgs, 'businessAreaSlug' | 'year'>>;
  chartTotalTransferredCashByCountry?: Resolver<Maybe<ResolversTypes['ChartDetailedDatasetsNode']>, ParentType, ContextType, RequireFields<QueryChartTotalTransferredCashByCountryArgs, 'year'>>;
  chartVolumeByDeliveryMechanism?: Resolver<Maybe<ResolversTypes['ChartDatasetNode']>, ParentType, ContextType, RequireFields<QueryChartVolumeByDeliveryMechanismArgs, 'businessAreaSlug' | 'year'>>;
  countriesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  crossAreaFilterAvailable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  currencyChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  dashboardReportTypesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType, RequireFields<QueryDashboardReportTypesChoicesArgs, 'businessAreaSlug'>>;
  dashboardYearsChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType, RequireFields<QueryDashboardYearsChoicesArgs, 'businessAreaSlug'>>;
  dataCollectingType?: Resolver<Maybe<ResolversTypes['DataCollectingTypeNode']>, ParentType, ContextType, RequireFields<QueryDataCollectingTypeArgs, 'id'>>;
  dataCollectingTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  dataCollectionTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['DataCollectingTypeChoiceObject']>>>, ParentType, ContextType>;
  deduplicationBatchStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  deduplicationGoldenRecordStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  documentTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  existingGrievanceTickets?: Resolver<Maybe<ResolversTypes['GrievanceTicketNodeConnection']>, ParentType, ContextType, RequireFields<QueryExistingGrievanceTicketsArgs, 'businessArea'>>;
  feedback?: Resolver<Maybe<ResolversTypes['FeedbackNode']>, ParentType, ContextType, RequireFields<QueryFeedbackArgs, 'id'>>;
  feedbackIssueTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  financialServiceProvider?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderNode']>, ParentType, ContextType, RequireFields<QueryFinancialServiceProviderArgs, 'id'>>;
  financialServiceProviderXlsxReport?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderXlsxReportNode']>, ParentType, ContextType, RequireFields<QueryFinancialServiceProviderXlsxReportArgs, 'id'>>;
  financialServiceProviderXlsxTemplate?: Resolver<Maybe<ResolversTypes['FinancialServiceProviderXlsxTemplateNode']>, ParentType, ContextType, RequireFields<QueryFinancialServiceProviderXlsxTemplateArgs, 'id'>>;
  flagChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType, RequireFields<QueryGrievanceTicketArgs, 'id'>>;
  grievanceTicketCategoryChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  grievanceTicketIssueTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['IssueTypesObject']>>>, ParentType, ContextType>;
  grievanceTicketManualCategoryChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  grievanceTicketPriorityChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObjectInt']>>>, ParentType, ContextType>;
  grievanceTicketSearchTypesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  grievanceTicketStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  grievanceTicketSystemCategoryChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  grievanceTicketUrgencyChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObjectInt']>>>, ParentType, ContextType>;
  hasAvailableUsersToExport?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryHasAvailableUsersToExportArgs, 'businessAreaSlug'>>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType, RequireFields<QueryHouseholdArgs, 'id'>>;
  householdSearchTypesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  identityTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  importData?: Resolver<Maybe<ResolversTypes['ImportDataNode']>, ParentType, ContextType, RequireFields<QueryImportDataArgs, 'id'>>;
  importedHousehold?: Resolver<Maybe<ResolversTypes['ImportedHouseholdNode']>, ParentType, ContextType, RequireFields<QueryImportedHouseholdArgs, 'id'>>;
  importedIndividual?: Resolver<Maybe<ResolversTypes['ImportedIndividualNode']>, ParentType, ContextType, RequireFields<QueryImportedIndividualArgs, 'id'>>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType, RequireFields<QueryIndividualArgs, 'id'>>;
  individualSearchTypesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  koboImportData?: Resolver<Maybe<ResolversTypes['KoboImportDataNode']>, ParentType, ContextType, RequireFields<QueryKoboImportDataArgs, 'id'>>;
  koboProject?: Resolver<Maybe<ResolversTypes['KoboAssetObject']>, ParentType, ContextType, RequireFields<QueryKoboProjectArgs, 'businessAreaSlug' | 'uid'>>;
  logEntryActionChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  maritalStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  observedDisabilityChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  partnerForGrievanceChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType, Partial<QueryPartnerForGrievanceChoicesArgs>>;
  payment?: Resolver<Maybe<ResolversTypes['PaymentNode']>, ParentType, ContextType, RequireFields<QueryPaymentArgs, 'id'>>;
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType, RequireFields<QueryPaymentPlanArgs, 'id'>>;
  paymentPlanBackgroundActionStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  paymentPlanStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  paymentRecord?: Resolver<Maybe<ResolversTypes['PaymentRecordNode']>, ParentType, ContextType, RequireFields<QueryPaymentRecordArgs, 'id'>>;
  paymentRecordDeliveryTypeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  paymentRecordEntitlementCardStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  paymentRecordStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  paymentRecordVerification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType, RequireFields<QueryPaymentRecordVerificationArgs, 'id'>>;
  paymentVerificationPlan?: Resolver<Maybe<ResolversTypes['PaymentVerificationPlanNode']>, ParentType, ContextType, RequireFields<QueryPaymentVerificationPlanArgs, 'id'>>;
  paymentVerificationStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType, RequireFields<QueryProgramArgs, 'id'>>;
  programFrequencyOfPaymentsChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  programScopeChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  programSectorChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  programStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  recipients?: Resolver<Maybe<ResolversTypes['RecipientNodeConnection']>, ParentType, ContextType, RequireFields<QueryRecipientsArgs, 'survey'>>;
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType, RequireFields<QueryRegistrationDataImportArgs, 'id'>>;
  registrationDataImportDatahub?: Resolver<Maybe<ResolversTypes['RegistrationDataImportDatahubNode']>, ParentType, ContextType, RequireFields<QueryRegistrationDataImportDatahubArgs, 'id'>>;
  registrationDataStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  relationshipChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  report?: Resolver<Maybe<ResolversTypes['ReportNode']>, ParentType, ContextType, RequireFields<QueryReportArgs, 'id'>>;
  reportStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  reportTypesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  residenceStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  roleChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  sampleSize?: Resolver<Maybe<ResolversTypes['GetCashplanVerificationSampleSizeObject']>, ParentType, ContextType, Partial<QuerySampleSizeArgs>>;
  sanctionListIndividual?: Resolver<Maybe<ResolversTypes['SanctionListIndividualNode']>, ParentType, ContextType, RequireFields<QuerySanctionListIndividualArgs, 'id'>>;
  sectionChildReached?: Resolver<Maybe<ResolversTypes['SectionTotalNode']>, ParentType, ContextType, RequireFields<QuerySectionChildReachedArgs, 'businessAreaSlug' | 'year'>>;
  sectionHouseholdsReached?: Resolver<Maybe<ResolversTypes['SectionTotalNode']>, ParentType, ContextType, RequireFields<QuerySectionHouseholdsReachedArgs, 'businessAreaSlug' | 'year'>>;
  sectionIndividualsReached?: Resolver<Maybe<ResolversTypes['SectionTotalNode']>, ParentType, ContextType, RequireFields<QuerySectionIndividualsReachedArgs, 'businessAreaSlug' | 'year'>>;
  sectionTotalTransferred?: Resolver<Maybe<ResolversTypes['SectionTotalNode']>, ParentType, ContextType, RequireFields<QuerySectionTotalTransferredArgs, 'businessAreaSlug' | 'year'>>;
  severityOfDisabilityChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  sexChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  survey?: Resolver<Maybe<ResolversTypes['SurveyNode']>, ParentType, ContextType, RequireFields<QuerySurveyArgs, 'id'>>;
  surveyAvailableFlows?: Resolver<Maybe<Array<Maybe<ResolversTypes['RapidProFlowNode']>>>, ParentType, ContextType>;
  surveyCategoryChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  tableTotalCashTransferredByAdministrativeArea?: Resolver<Maybe<ResolversTypes['TableTotalCashTransferred']>, ParentType, ContextType, RequireFields<QueryTableTotalCashTransferredByAdministrativeAreaArgs, 'businessAreaSlug' | 'year'>>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType, RequireFields<QueryTargetPopulationArgs, 'id'>>;
  targetPopulationHouseholds?: Resolver<Maybe<ResolversTypes['HouseholdNodeConnection']>, ParentType, ContextType, RequireFields<QueryTargetPopulationHouseholdsArgs, 'targetPopulation'>>;
  targetPopulationStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  ticketsByCategory?: Resolver<Maybe<ResolversTypes['ChartDatasetNode']>, ParentType, ContextType, RequireFields<QueryTicketsByCategoryArgs, 'businessAreaSlug'>>;
  ticketsByLocationAndCategory?: Resolver<Maybe<ResolversTypes['ChartDetailedDatasetsNode']>, ParentType, ContextType, RequireFields<QueryTicketsByLocationAndCategoryArgs, 'businessAreaSlug'>>;
  ticketsByStatus?: Resolver<Maybe<ResolversTypes['ChartDatasetNode']>, ParentType, ContextType, RequireFields<QueryTicketsByStatusArgs, 'businessAreaSlug'>>;
  ticketsByType?: Resolver<Maybe<ResolversTypes['TicketByType']>, ParentType, ContextType, RequireFields<QueryTicketsByTypeArgs, 'businessAreaSlug'>>;
  userPartnerChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  userRolesChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['RoleChoiceObject']>>>, ParentType, ContextType>;
  userStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
  workStatusChoices?: Resolver<Maybe<Array<Maybe<ResolversTypes['ChoiceObject']>>>, ParentType, ContextType>;
};

export type RapidProFlowResolvers<ContextType = any, ParentType extends ResolversParentTypes['RapidProFlow'] = ResolversParentTypes['RapidProFlow']> = {
  archived?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  createdOn?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  expires?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  labels?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  modifiedOn?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  results?: Resolver<Maybe<Array<Maybe<ResolversTypes['RapidProFlowResult']>>>, ParentType, ContextType>;
  runs?: Resolver<Maybe<Array<Maybe<ResolversTypes['RapidProFlowRun']>>>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RapidProFlowNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RapidProFlowNode'] = ResolversParentTypes['RapidProFlowNode']> = {
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RapidProFlowResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['RapidProFlowResult'] = ResolversParentTypes['RapidProFlowResult']> = {
  categories?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeUuids?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RapidProFlowRunResolvers<ContextType = any, ParentType extends ResolversParentTypes['RapidProFlowRun'] = ResolversParentTypes['RapidProFlowRun']> = {
  active?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  completed?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  expired?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  interrupted?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReassignRoleMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReassignRoleMutation'] = ResolversParentTypes['ReassignRoleMutation']> = {
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RebuildTargetPopulationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RebuildTargetPopulationMutation'] = ResolversParentTypes['RebuildTargetPopulationMutation']> = {
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RecipientNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RecipientNode'] = ResolversParentTypes['RecipientNode']> = {
  headOfHousehold?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RecipientNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RecipientNodeConnection'] = ResolversParentTypes['RecipientNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['RecipientNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RecipientNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RecipientNodeEdge'] = ResolversParentTypes['RecipientNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RecipientNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReconciliationSummaryNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReconciliationSummaryNode'] = ResolversParentTypes['ReconciliationSummaryNode']> = {
  deliveredFully?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  deliveredPartially?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  forceFailed?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  notDelivered?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  numberOfPayments?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  pending?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reconciled?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  unsuccessful?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefuseRegistrationDataImportMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RefuseRegistrationDataImportMutation'] = ResolversParentTypes['RefuseRegistrationDataImportMutation']> = {
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDataImportDatahubNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDataImportDatahubNode'] = ResolversParentTypes['RegistrationDataImportDatahubNode']> = {
  businessAreaSlug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  hctId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  households?: Resolver<ResolversTypes['ImportedHouseholdNodeConnection'], ParentType, ContextType, Partial<RegistrationDataImportDatahubNodeHouseholdsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importData?: Resolver<Maybe<ResolversTypes['ImportDataNode']>, ParentType, ContextType>;
  importDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  importDone?: Resolver<ResolversTypes['RegistrationDataImportDatahubImportDone'], ParentType, ContextType>;
  individuals?: Resolver<ResolversTypes['ImportedIndividualNodeConnection'], ParentType, ContextType, Partial<RegistrationDataImportDatahubNodeIndividualsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDataImportDatahubNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDataImportDatahubNodeConnection'] = ResolversParentTypes['RegistrationDataImportDatahubNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['RegistrationDataImportDatahubNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDataImportDatahubNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDataImportDatahubNodeEdge'] = ResolversParentTypes['RegistrationDataImportDatahubNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RegistrationDataImportDatahubNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDataImportNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDataImportNode'] = ResolversParentTypes['RegistrationDataImportNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  batchDuplicates?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  batchDuplicatesCountAndPercentage?: Resolver<Maybe<ResolversTypes['CountAndPercentageNode']>, ParentType, ContextType>;
  batchPossibleDuplicates?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  batchPossibleDuplicatesCountAndPercentage?: Resolver<Maybe<ResolversTypes['CountAndPercentageNode']>, ParentType, ContextType>;
  batchUnique?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  batchUniqueCountAndPercentage?: Resolver<Maybe<ResolversTypes['CountAndPercentageNode']>, ParentType, ContextType>;
  businessArea?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataSource?: Resolver<ResolversTypes['RegistrationDataImportDataSource'], ParentType, ContextType>;
  datahubId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  erased?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  errorMessage?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  excluded?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  goldenRecordDuplicates?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  goldenRecordDuplicatesCountAndPercentage?: Resolver<Maybe<ResolversTypes['CountAndPercentageNode']>, ParentType, ContextType>;
  goldenRecordPossibleDuplicates?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  goldenRecordPossibleDuplicatesCountAndPercentage?: Resolver<Maybe<ResolversTypes['CountAndPercentageNode']>, ParentType, ContextType>;
  goldenRecordUnique?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  goldenRecordUniqueCountAndPercentage?: Resolver<Maybe<ResolversTypes['CountAndPercentageNode']>, ParentType, ContextType>;
  grievanceticketSet?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<RegistrationDataImportNodeGrievanceticketSetArgs>>;
  households?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<RegistrationDataImportNodeHouseholdsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  importDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  importedBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  individuals?: Resolver<ResolversTypes['IndividualNodeConnection'], ParentType, ContextType, Partial<RegistrationDataImportNodeIndividualsArgs>>;
  messages?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<RegistrationDataImportNodeMessagesArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  numberOfHouseholds?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  numberOfIndividuals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  pullPictures?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  refuseReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  screenBeneficiary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sentryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['RegistrationDataImportStatus'], ParentType, ContextType>;
  totalHouseholdsCountWithValidPhoneNo?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDataImportNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDataImportNodeConnection'] = ResolversParentTypes['RegistrationDataImportNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['RegistrationDataImportNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDataImportNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDataImportNodeEdge'] = ResolversParentTypes['RegistrationDataImportNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationDeduplicationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationDeduplicationMutation'] = ResolversParentTypes['RegistrationDeduplicationMutation']> = {
  ok?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationKoboImportMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationKoboImportMutation'] = ResolversParentTypes['RegistrationKoboImportMutation']> = {
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegistrationXlsxImportMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RegistrationXlsxImportMutation'] = ResolversParentTypes['RegistrationXlsxImportMutation']> = {
  registrationDataImport?: Resolver<Maybe<ResolversTypes['RegistrationDataImportNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportNode'] = ResolversParentTypes['ReportNode']> = {
  adminArea?: Resolver<ResolversTypes['AreaNodeConnection'], ParentType, ContextType, Partial<ReportNodeAdminAreaArgs>>;
  adminArea1?: Resolver<Maybe<ResolversTypes['AreaNodeConnection']>, ParentType, ContextType, Partial<ReportNodeAdminArea1Args>>;
  adminArea2?: Resolver<Maybe<ResolversTypes['AreaNodeConnection']>, ParentType, ContextType, Partial<ReportNodeAdminArea2Args>>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<ResolversTypes['UserNode'], ParentType, ContextType>;
  dateFrom?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  dateTo?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fileUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  numberOfRecords?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  reportType?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportNodeConnection'] = ResolversParentTypes['ReportNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ReportNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReportNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReportNodeEdge'] = ResolversParentTypes['ReportNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RestartCreateReportResolvers<ContextType = any, ParentType extends ResolversParentTypes['RestartCreateReport'] = ResolversParentTypes['RestartCreateReport']> = {
  report?: Resolver<Maybe<ResolversTypes['ReportNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevertMarkPaymentAsFailedMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RevertMarkPaymentAsFailedMutation'] = ResolversParentTypes['RevertMarkPaymentAsFailedMutation']> = {
  payment?: Resolver<Maybe<ResolversTypes['PaymentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevertMarkPaymentRecordAsFailedMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['RevertMarkPaymentRecordAsFailedMutation'] = ResolversParentTypes['RevertMarkPaymentRecordAsFailedMutation']> = {
  paymentRecord?: Resolver<Maybe<ResolversTypes['PaymentRecordNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleChoiceObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleChoiceObject'] = ResolversParentTypes['RoleChoiceObject']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subsystem?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RoleNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RoleNode'] = ResolversParentTypes['RoleNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  subsystem?: Resolver<ResolversTypes['RoleSubsystem'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userRoles?: Resolver<Array<ResolversTypes['UserRoleNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleCommitNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleCommitNode'] = ResolversParentTypes['RuleCommitNode']> = {
  affectedFields?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  after?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  before?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  definition?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  deprecated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRelease?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['RuleCommitLanguage'], ParentType, ContextType>;
  paymentPlans?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<RuleCommitNodePaymentPlansArgs>>;
  rule?: Resolver<Maybe<ResolversTypes['SteficonRuleNode']>, ParentType, ContextType>;
  targetPopulations?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<RuleCommitNodeTargetPopulationsArgs>>;
  timestamp?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  updatedBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleCommitNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleCommitNodeConnection'] = ResolversParentTypes['RuleCommitNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['RuleCommitNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleCommitNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleCommitNodeEdge'] = ResolversParentTypes['RuleCommitNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['RuleCommitNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualAliasNameNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualAliasNameNode'] = ResolversParentTypes['SanctionListIndividualAliasNameNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualAliasNameNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualAliasNameNodeConnection'] = ResolversParentTypes['SanctionListIndividualAliasNameNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SanctionListIndividualAliasNameNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualAliasNameNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualAliasNameNodeEdge'] = ResolversParentTypes['SanctionListIndividualAliasNameNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SanctionListIndividualAliasNameNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualCountriesNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualCountriesNode'] = ResolversParentTypes['SanctionListIndividualCountriesNode']> = {
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualCountriesNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualCountriesNodeConnection'] = ResolversParentTypes['SanctionListIndividualCountriesNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SanctionListIndividualCountriesNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualCountriesNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualCountriesNodeEdge'] = ResolversParentTypes['SanctionListIndividualCountriesNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SanctionListIndividualCountriesNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualDateOfBirthNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualDateOfBirthNode'] = ResolversParentTypes['SanctionListIndividualDateOfBirthNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  date?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualDateOfBirthNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualDateOfBirthNodeConnection'] = ResolversParentTypes['SanctionListIndividualDateOfBirthNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SanctionListIndividualDateOfBirthNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualDateOfBirthNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualDateOfBirthNodeEdge'] = ResolversParentTypes['SanctionListIndividualDateOfBirthNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SanctionListIndividualDateOfBirthNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualDocumentNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualDocumentNode'] = ResolversParentTypes['SanctionListIndividualDocumentNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dateOfIssue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  documentNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  issuingCountry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  note?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeOfDocument?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualDocumentNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualDocumentNodeConnection'] = ResolversParentTypes['SanctionListIndividualDocumentNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SanctionListIndividualDocumentNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualDocumentNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualDocumentNodeEdge'] = ResolversParentTypes['SanctionListIndividualDocumentNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SanctionListIndividualDocumentNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualNationalitiesNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualNationalitiesNode'] = ResolversParentTypes['SanctionListIndividualNationalitiesNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  nationality?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualNationalitiesNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualNationalitiesNodeConnection'] = ResolversParentTypes['SanctionListIndividualNationalitiesNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SanctionListIndividualNationalitiesNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualNationalitiesNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualNationalitiesNodeEdge'] = ResolversParentTypes['SanctionListIndividualNationalitiesNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SanctionListIndividualNationalitiesNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualNode'] = ResolversParentTypes['SanctionListIndividualNode']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  addressNote?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  aliasNames?: Resolver<ResolversTypes['SanctionListIndividualAliasNameNodeConnection'], ParentType, ContextType, Partial<SanctionListIndividualNodeAliasNamesArgs>>;
  city?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  countries?: Resolver<ResolversTypes['SanctionListIndividualCountriesNodeConnection'], ParentType, ContextType, Partial<SanctionListIndividualNodeCountriesArgs>>;
  countryOfBirth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  dataId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  datesOfBirth?: Resolver<ResolversTypes['SanctionListIndividualDateOfBirthNodeConnection'], ParentType, ContextType, Partial<SanctionListIndividualNodeDatesOfBirthArgs>>;
  designation?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  documents?: Resolver<ResolversTypes['SanctionListIndividualDocumentNodeConnection'], ParentType, ContextType, Partial<SanctionListIndividualNodeDocumentsArgs>>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fourthName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  listType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  listedOn?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  nameOriginalScript?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nationalities?: Resolver<ResolversTypes['SanctionListIndividualNationalitiesNodeConnection'], ParentType, ContextType, Partial<SanctionListIndividualNodeNationalitiesArgs>>;
  referenceNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  secondName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stateProvince?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  street?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  thirdName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unListType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  versionNum?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualNodeConnection'] = ResolversParentTypes['SanctionListIndividualNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SanctionListIndividualNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SanctionListIndividualNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SanctionListIndividualNodeEdge'] = ResolversParentTypes['SanctionListIndividualNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SanctionListIndividualNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaveKoboProjectImportDataAsyncResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaveKoboProjectImportDataAsync'] = ResolversParentTypes['SaveKoboProjectImportDataAsync']> = {
  importData?: Resolver<Maybe<ResolversTypes['KoboImportDataNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SectionTotalNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SectionTotalNode'] = ResolversParentTypes['SectionTotalNode']> = {
  total?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ServiceProviderNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceProviderNode'] = ResolversParentTypes['ServiceProviderNode']> = {
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  caId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  cashPlans?: Resolver<ResolversTypes['CashPlanNodeConnection'], ParentType, ContextType, Partial<ServiceProviderNodeCashPlansArgs>>;
  country?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  paymentrecordSet?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<ServiceProviderNodePaymentrecordSetArgs>>;
  shortName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  visionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ServiceProviderNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceProviderNodeConnection'] = ResolversParentTypes['ServiceProviderNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['ServiceProviderNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ServiceProviderNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceProviderNodeEdge'] = ResolversParentTypes['ServiceProviderNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ServiceProviderNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetSteficonRuleOnPaymentPlanPaymentListMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetSteficonRuleOnPaymentPlanPaymentListMutation'] = ResolversParentTypes['SetSteficonRuleOnPaymentPlanPaymentListMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetSteficonRuleOnTargetPopulationMutationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetSteficonRuleOnTargetPopulationMutationPayload'] = ResolversParentTypes['SetSteficonRuleOnTargetPopulationMutationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SimpleApproveMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SimpleApproveMutation'] = ResolversParentTypes['SimpleApproveMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SplitPaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplitPaymentPlanMutation'] = ResolversParentTypes['SplitPaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SteficonRuleNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SteficonRuleNode'] = ResolversParentTypes['SteficonRuleNode']> = {
  allowedBusinessAreas?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<SteficonRuleNodeAllowedBusinessAreasArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  definition?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  deprecated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  flags?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  history?: Resolver<ResolversTypes['RuleCommitNodeConnection'], ParentType, ContextType, Partial<SteficonRuleNodeHistoryArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['RuleLanguage'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  security?: Resolver<ResolversTypes['RuleSecurity'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['RuleType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  updatedBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SteficonRuleNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SteficonRuleNodeConnection'] = ResolversParentTypes['SteficonRuleNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SteficonRuleNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SteficonRuleNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SteficonRuleNodeEdge'] = ResolversParentTypes['SteficonRuleNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SteficonRuleNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SurveyNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SurveyNode'] = ResolversParentTypes['SurveyNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  category?: Resolver<ResolversTypes['SurveyCategory'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  flowId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullListArguments?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  hasValidSampleFile?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  numberOfRecipients?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  randomSamplingArguments?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  rapidProUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recipients?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<SurveyNodeRecipientsArgs>>;
  sampleFile?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sampleFileGeneratedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  sampleFilePath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sampleSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  samplingType?: Resolver<ResolversTypes['SurveySamplingType'], ParentType, ContextType>;
  successfulRapidProCalls?: Resolver<Array<ResolversTypes['JSONString']>, ParentType, ContextType>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  unicefId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SurveyNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SurveyNodeConnection'] = ResolversParentTypes['SurveyNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['SurveyNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SurveyNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SurveyNodeEdge'] = ResolversParentTypes['SurveyNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SurveyNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TableTotalCashTransferredResolvers<ContextType = any, ParentType extends ResolversParentTypes['TableTotalCashTransferred'] = ResolversParentTypes['TableTotalCashTransferred']> = {
  data?: Resolver<Maybe<Array<Maybe<ResolversTypes['_TableTotalCashTransferredDataNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetPopulationNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetPopulationNode'] = ResolversParentTypes['TargetPopulationNode']> = {
  adminUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  adultFemaleCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  adultMaleCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  buildStatus?: Resolver<ResolversTypes['TargetPopulationBuildStatus'], ParentType, ContextType>;
  builtAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  businessArea?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  caHashId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  caId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  changeDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  changedBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  childFemaleCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  childMaleCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  excludedIds?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  exclusionReason?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  finalizedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  finalizedBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  hasEmptyCriteria?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  householdList?: Resolver<Maybe<ResolversTypes['HouseholdNodeConnection']>, ParentType, ContextType, Partial<TargetPopulationNodeHouseholdListArgs>>;
  households?: Resolver<Maybe<ResolversTypes['HouseholdNodeConnection']>, ParentType, ContextType, Partial<TargetPopulationNodeHouseholdsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isRemoved?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  messages?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<TargetPopulationNodeMessagesArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  paymentPlans?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<TargetPopulationNodePaymentPlansArgs>>;
  paymentRecords?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<TargetPopulationNodePaymentRecordsArgs>>;
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  selections?: Resolver<Array<ResolversTypes['HouseholdSelectionNode']>, ParentType, ContextType>;
  sentToDatahub?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['TargetPopulationStatus'], ParentType, ContextType>;
  steficonAppliedDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  steficonRule?: Resolver<Maybe<ResolversTypes['RuleCommitNode']>, ParentType, ContextType>;
  surveys?: Resolver<ResolversTypes['SurveyNodeConnection'], ParentType, ContextType, Partial<TargetPopulationNodeSurveysArgs>>;
  targetingCriteria?: Resolver<Maybe<ResolversTypes['TargetingCriteriaNode']>, ParentType, ContextType>;
  totalFamilySize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalHouseholdsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalHouseholdsCountWithValidPhoneNo?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  totalIndividualsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  vulnerabilityScoreMax?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  vulnerabilityScoreMin?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetPopulationNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetPopulationNodeConnection'] = ResolversParentTypes['TargetPopulationNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TargetPopulationNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetPopulationNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetPopulationNodeEdge'] = ResolversParentTypes['TargetPopulationNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetingCriteriaNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetingCriteriaNode'] = ResolversParentTypes['TargetingCriteriaNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  flagExcludeIfActiveAdjudicationTicket?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  flagExcludeIfOnSanctionList?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  rules?: Resolver<Maybe<Array<Maybe<ResolversTypes['TargetingCriteriaRuleNode']>>>, ParentType, ContextType>;
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetingCriteriaRuleFilterNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetingCriteriaRuleFilterNode'] = ResolversParentTypes['TargetingCriteriaRuleFilterNode']> = {
  arguments?: Resolver<Maybe<Array<Maybe<ResolversTypes['Arg']>>>, ParentType, ContextType>;
  comparisonMethod?: Resolver<ResolversTypes['TargetingCriteriaRuleFilterComparisonMethod'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fieldAttribute?: Resolver<Maybe<ResolversTypes['FieldAttributeNode']>, ParentType, ContextType>;
  fieldName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  isFlexField?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  targetingCriteriaRule?: Resolver<ResolversTypes['TargetingCriteriaRuleNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetingCriteriaRuleNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetingCriteriaRuleNode'] = ResolversParentTypes['TargetingCriteriaRuleNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  filters?: Resolver<Maybe<Array<Maybe<ResolversTypes['TargetingCriteriaRuleFilterNode']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  individualsFiltersBlocks?: Resolver<Maybe<Array<Maybe<ResolversTypes['TargetingIndividualRuleFilterBlockNode']>>>, ParentType, ContextType>;
  targetingCriteria?: Resolver<ResolversTypes['TargetingCriteriaNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetingIndividualBlockRuleFilterNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetingIndividualBlockRuleFilterNode'] = ResolversParentTypes['TargetingIndividualBlockRuleFilterNode']> = {
  arguments?: Resolver<Maybe<Array<Maybe<ResolversTypes['Arg']>>>, ParentType, ContextType>;
  comparisonMethod?: Resolver<ResolversTypes['TargetingIndividualBlockRuleFilterComparisonMethod'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fieldAttribute?: Resolver<Maybe<ResolversTypes['FieldAttributeNode']>, ParentType, ContextType>;
  fieldName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  individualsFiltersBlock?: Resolver<ResolversTypes['TargetingIndividualRuleFilterBlockNode'], ParentType, ContextType>;
  isFlexField?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TargetingIndividualRuleFilterBlockNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TargetingIndividualRuleFilterBlockNode'] = ResolversParentTypes['TargetingIndividualRuleFilterBlockNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  individualBlockFilters?: Resolver<Maybe<Array<Maybe<ResolversTypes['TargetingIndividualBlockRuleFilterNode']>>>, ParentType, ContextType>;
  targetOnlyHoh?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  targetingCriteriaRule?: Resolver<ResolversTypes['TargetingCriteriaRuleNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketAddIndividualDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketAddIndividualDetailsNode'] = ResolversParentTypes['TicketAddIndividualDetailsNode']> = {
  approveStatus?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualData?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketAddIndividualDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketAddIndividualDetailsNodeConnection'] = ResolversParentTypes['TicketAddIndividualDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketAddIndividualDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketAddIndividualDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketAddIndividualDetailsNodeEdge'] = ResolversParentTypes['TicketAddIndividualDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketAddIndividualDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketByTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketByType'] = ResolversParentTypes['TicketByType']> = {
  closedSystemGeneratedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  closedUserGeneratedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  systemGeneratedAvgResolution?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  systemGeneratedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userGeneratedAvgResolution?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  userGeneratedCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketComplaintDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketComplaintDetailsNode'] = ResolversParentTypes['TicketComplaintDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  paymentContentType?: Resolver<Maybe<ResolversTypes['ContentTypeObjectType']>, ParentType, ContextType>;
  paymentObjectId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  paymentRecord?: Resolver<Maybe<ResolversTypes['PaymentRecordAndPaymentNode']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketComplaintDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketComplaintDetailsNodeConnection'] = ResolversParentTypes['TicketComplaintDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketComplaintDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketComplaintDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketComplaintDetailsNodeEdge'] = ResolversParentTypes['TicketComplaintDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketComplaintDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketDeleteHouseholdDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketDeleteHouseholdDetailsNode'] = ResolversParentTypes['TicketDeleteHouseholdDetailsNode']> = {
  approveStatus?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  householdData?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reasonHousehold?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  roleReassignData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketDeleteHouseholdDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketDeleteHouseholdDetailsNodeConnection'] = ResolversParentTypes['TicketDeleteHouseholdDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketDeleteHouseholdDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketDeleteHouseholdDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketDeleteHouseholdDetailsNodeEdge'] = ResolversParentTypes['TicketDeleteHouseholdDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketDeleteHouseholdDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketDeleteIndividualDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketDeleteIndividualDetailsNode'] = ResolversParentTypes['TicketDeleteIndividualDetailsNode']> = {
  approveStatus?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  individualData?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  roleReassignData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketDeleteIndividualDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketDeleteIndividualDetailsNodeConnection'] = ResolversParentTypes['TicketDeleteIndividualDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketDeleteIndividualDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketDeleteIndividualDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketDeleteIndividualDetailsNodeEdge'] = ResolversParentTypes['TicketDeleteIndividualDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketDeleteIndividualDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketHouseholdDataUpdateDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketHouseholdDataUpdateDetailsNode'] = ResolversParentTypes['TicketHouseholdDataUpdateDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  householdData?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketHouseholdDataUpdateDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketHouseholdDataUpdateDetailsNodeConnection'] = ResolversParentTypes['TicketHouseholdDataUpdateDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketHouseholdDataUpdateDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketHouseholdDataUpdateDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketHouseholdDataUpdateDetailsNodeEdge'] = ResolversParentTypes['TicketHouseholdDataUpdateDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketHouseholdDataUpdateDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketIndividualDataUpdateDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketIndividualDataUpdateDetailsNode'] = ResolversParentTypes['TicketIndividualDataUpdateDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  individualData?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  roleReassignData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketIndividualDataUpdateDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketIndividualDataUpdateDetailsNodeConnection'] = ResolversParentTypes['TicketIndividualDataUpdateDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketIndividualDataUpdateDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketIndividualDataUpdateDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketIndividualDataUpdateDetailsNodeEdge'] = ResolversParentTypes['TicketIndividualDataUpdateDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketIndividualDataUpdateDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNeedsAdjudicationDetailsExtraDataNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNeedsAdjudicationDetailsExtraDataNode'] = ResolversParentTypes['TicketNeedsAdjudicationDetailsExtraDataNode']> = {
  goldenRecords?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeduplicationResultNode']>>>, ParentType, ContextType>;
  possibleDuplicate?: Resolver<Maybe<Array<Maybe<ResolversTypes['DeduplicationResultNode']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNeedsAdjudicationDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNeedsAdjudicationDetailsNode'] = ResolversParentTypes['TicketNeedsAdjudicationDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  extraData?: Resolver<Maybe<ResolversTypes['TicketNeedsAdjudicationDetailsExtraDataNode']>, ParentType, ContextType>;
  goldenRecordsIndividual?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  hasDuplicatedDocument?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isCrossArea?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isMultipleDuplicatesVersion?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  possibleDuplicate?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  possibleDuplicates?: Resolver<Maybe<Array<Maybe<ResolversTypes['IndividualNode']>>>, ParentType, ContextType>;
  roleReassignData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  scoreMax?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  scoreMin?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  selectedIndividual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  selectedIndividuals?: Resolver<Maybe<Array<Maybe<ResolversTypes['IndividualNode']>>>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNeedsAdjudicationDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNeedsAdjudicationDetailsNodeConnection'] = ResolversParentTypes['TicketNeedsAdjudicationDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketNeedsAdjudicationDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNeedsAdjudicationDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNeedsAdjudicationDetailsNodeEdge'] = ResolversParentTypes['TicketNeedsAdjudicationDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketNeedsAdjudicationDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNegativeFeedbackDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNegativeFeedbackDetailsNode'] = ResolversParentTypes['TicketNegativeFeedbackDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNegativeFeedbackDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNegativeFeedbackDetailsNodeConnection'] = ResolversParentTypes['TicketNegativeFeedbackDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketNegativeFeedbackDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNegativeFeedbackDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNegativeFeedbackDetailsNodeEdge'] = ResolversParentTypes['TicketNegativeFeedbackDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketNegativeFeedbackDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNoteNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNoteNode'] = ResolversParentTypes['TicketNoteNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNoteNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNoteNodeConnection'] = ResolversParentTypes['TicketNoteNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketNoteNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketNoteNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketNoteNodeEdge'] = ResolversParentTypes['TicketNoteNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketNoteNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketPaymentVerificationDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketPaymentVerificationDetailsNode'] = ResolversParentTypes['TicketPaymentVerificationDetailsNode']> = {
  approveStatus?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  hasMultiplePaymentVerifications?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  newReceivedAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  newStatus?: Resolver<Maybe<ResolversTypes['TicketPaymentVerificationDetailsNewStatus']>, ParentType, ContextType>;
  oldReceivedAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  paymentVerification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  paymentVerificationStatus?: Resolver<ResolversTypes['TicketPaymentVerificationDetailsPaymentVerificationStatus'], ParentType, ContextType>;
  paymentVerifications?: Resolver<ResolversTypes['PaymentVerificationNodeConnection'], ParentType, ContextType, Partial<TicketPaymentVerificationDetailsNodePaymentVerificationsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketPaymentVerificationDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketPaymentVerificationDetailsNodeConnection'] = ResolversParentTypes['TicketPaymentVerificationDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketPaymentVerificationDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketPaymentVerificationDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketPaymentVerificationDetailsNodeEdge'] = ResolversParentTypes['TicketPaymentVerificationDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketPaymentVerificationDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketPositiveFeedbackDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketPositiveFeedbackDetailsNode'] = ResolversParentTypes['TicketPositiveFeedbackDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketPositiveFeedbackDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketPositiveFeedbackDetailsNodeConnection'] = ResolversParentTypes['TicketPositiveFeedbackDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketPositiveFeedbackDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketPositiveFeedbackDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketPositiveFeedbackDetailsNodeEdge'] = ResolversParentTypes['TicketPositiveFeedbackDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketPositiveFeedbackDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketReferralDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketReferralDetailsNode'] = ResolversParentTypes['TicketReferralDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketReferralDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketReferralDetailsNodeConnection'] = ResolversParentTypes['TicketReferralDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketReferralDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketReferralDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketReferralDetailsNodeEdge'] = ResolversParentTypes['TicketReferralDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketReferralDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketSensitiveDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketSensitiveDetailsNode'] = ResolversParentTypes['TicketSensitiveDetailsNode']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  household?: Resolver<Maybe<ResolversTypes['HouseholdNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individual?: Resolver<Maybe<ResolversTypes['IndividualNode']>, ParentType, ContextType>;
  paymentContentType?: Resolver<Maybe<ResolversTypes['ContentTypeObjectType']>, ParentType, ContextType>;
  paymentObjectId?: Resolver<Maybe<ResolversTypes['UUID']>, ParentType, ContextType>;
  paymentRecord?: Resolver<Maybe<ResolversTypes['PaymentRecordAndPaymentNode']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketSensitiveDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketSensitiveDetailsNodeConnection'] = ResolversParentTypes['TicketSensitiveDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketSensitiveDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketSensitiveDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketSensitiveDetailsNodeEdge'] = ResolversParentTypes['TicketSensitiveDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketSensitiveDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketSystemFlaggingDetailsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketSystemFlaggingDetailsNode'] = ResolversParentTypes['TicketSystemFlaggingDetailsNode']> = {
  approveStatus?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  goldenRecordsIndividual?: Resolver<ResolversTypes['IndividualNode'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  roleReassignData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  sanctionListIndividual?: Resolver<ResolversTypes['SanctionListIndividualNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketSystemFlaggingDetailsNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketSystemFlaggingDetailsNodeConnection'] = ResolversParentTypes['TicketSystemFlaggingDetailsNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['TicketSystemFlaggingDetailsNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TicketSystemFlaggingDetailsNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TicketSystemFlaggingDetailsNodeEdge'] = ResolversParentTypes['TicketSystemFlaggingDetailsNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TicketSystemFlaggingDetailsNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UuidScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UUID'], any> {
  name: 'UUID';
}

export type UnlockTargetPopulationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UnlockTargetPopulationMutation'] = ResolversParentTypes['UnlockTargetPopulationMutation']> = {
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFeedbackMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFeedbackMutation'] = ResolversParentTypes['UpdateFeedbackMutation']> = {
  feedback?: Resolver<Maybe<ResolversTypes['FeedbackNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateGrievanceTicketMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateGrievanceTicketMutation'] = ResolversParentTypes['UpdateGrievanceTicketMutation']> = {
  grievanceTicket?: Resolver<Maybe<ResolversTypes['GrievanceTicketNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePaymentPlanMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePaymentPlanMutation'] = ResolversParentTypes['UpdatePaymentPlanMutation']> = {
  paymentPlan?: Resolver<Maybe<ResolversTypes['PaymentPlanNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePaymentVerificationReceivedAndReceivedAmountResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePaymentVerificationReceivedAndReceivedAmount'] = ResolversParentTypes['UpdatePaymentVerificationReceivedAndReceivedAmount']> = {
  paymentVerification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePaymentVerificationStatusAndReceivedAmountResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePaymentVerificationStatusAndReceivedAmount'] = ResolversParentTypes['UpdatePaymentVerificationStatusAndReceivedAmount']> = {
  paymentVerification?: Resolver<Maybe<ResolversTypes['PaymentVerificationNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateProgram'] = ResolversParentTypes['UpdateProgram']> = {
  program?: Resolver<Maybe<ResolversTypes['ProgramNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTargetPopulationMutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTargetPopulationMutation'] = ResolversParentTypes['UpdateTargetPopulationMutation']> = {
  targetPopulation?: Resolver<Maybe<ResolversTypes['TargetPopulationNode']>, ParentType, ContextType>;
  validationErrors?: Resolver<Maybe<ResolversTypes['Arg']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UploadScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Upload'], any> {
  name: 'Upload';
}

export type UploadImportDataXlsxFileAsyncResolvers<ContextType = any, ParentType extends ResolversParentTypes['UploadImportDataXLSXFileAsync'] = ResolversParentTypes['UploadImportDataXLSXFileAsync']> = {
  errors?: Resolver<Maybe<Array<Maybe<ResolversTypes['XlsxRowErrorNode']>>>, ParentType, ContextType>;
  importData?: Resolver<Maybe<ResolversTypes['ImportDataNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserBusinessAreaNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserBusinessAreaNode'] = ResolversParentTypes['UserBusinessAreaNode']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  cashplanSet?: Resolver<ResolversTypes['CashPlanNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeCashplanSetArgs>>;
  children?: Resolver<ResolversTypes['UserBusinessAreaNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeChildrenArgs>>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  customFields?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  dataCollectingTypes?: Resolver<ResolversTypes['DataCollectingTypeNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeDataCollectingTypesArgs>>;
  deduplicationBatchDuplicatesAllowed?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationBatchDuplicatesPercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationDuplicateScore?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  deduplicationGoldenRecordDuplicatesAllowed?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationGoldenRecordDuplicatesPercentage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  deduplicationIgnoreWithdraw?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  deduplicationPossibleDuplicateScore?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  enableEmailNotification?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  feedbackSet?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeFeedbackSetArgs>>;
  financialserviceproviderSet?: Resolver<ResolversTypes['FinancialServiceProviderNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeFinancialserviceproviderSetArgs>>;
  hasDataSharingAgreement?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  householdSet?: Resolver<ResolversTypes['HouseholdNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeHouseholdSetArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  individualSet?: Resolver<ResolversTypes['IndividualNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeIndividualSetArgs>>;
  isAccountabilityApplicable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isPaymentPlanApplicable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSplit?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  koboToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  koboUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  koboUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  logentrySet?: Resolver<ResolversTypes['PaymentVerificationLogEntryNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeLogentrySetArgs>>;
  longName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  messageSet?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeMessageSetArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  partnerSet?: Resolver<Array<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  paymentSet?: Resolver<ResolversTypes['PaymentNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodePaymentSetArgs>>;
  paymentplanSet?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodePaymentplanSetArgs>>;
  paymentrecordSet?: Resolver<ResolversTypes['PaymentRecordNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodePaymentrecordSetArgs>>;
  permissions?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  postponeDeduplication?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  programSet?: Resolver<ResolversTypes['ProgramNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeProgramSetArgs>>;
  rapidProHost?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rapidProMessagesToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rapidProPaymentVerificationToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rapidProSurveyToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  regionCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  regionName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  registrationdataimportSet?: Resolver<ResolversTypes['RegistrationDataImportNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeRegistrationdataimportSetArgs>>;
  reports?: Resolver<ResolversTypes['ReportNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeReportsArgs>>;
  ruleSet?: Resolver<ResolversTypes['SteficonRuleNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeRuleSetArgs>>;
  screenBeneficiary?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  serviceproviderSet?: Resolver<ResolversTypes['ServiceProviderNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeServiceproviderSetArgs>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  surveySet?: Resolver<ResolversTypes['SurveyNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeSurveySetArgs>>;
  targetpopulationSet?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeTargetpopulationSetArgs>>;
  tickets?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<UserBusinessAreaNodeTicketsArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userRoles?: Resolver<Array<ResolversTypes['UserRoleNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserBusinessAreaNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserBusinessAreaNodeConnection'] = ResolversParentTypes['UserBusinessAreaNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['UserBusinessAreaNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserBusinessAreaNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserBusinessAreaNodeEdge'] = ResolversParentTypes['UserBusinessAreaNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserNode'] = ResolversParentTypes['UserNode']> = {
  adUuid?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  approvalSet?: Resolver<Array<ResolversTypes['ApprovalNode']>, ParentType, ContextType>;
  assignedTickets?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<UserNodeAssignedTicketsArgs>>;
  availableForExport?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  businessAreas?: Resolver<Maybe<ResolversTypes['UserBusinessAreaNodeConnection']>, ParentType, ContextType, Partial<UserNodeBusinessAreasArgs>>;
  changedTargetPopulations?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<UserNodeChangedTargetPopulationsArgs>>;
  createdDeliveryMechanisms?: Resolver<ResolversTypes['DeliveryMechanismNodeConnection'], ParentType, ContextType, Partial<UserNodeCreatedDeliveryMechanismsArgs>>;
  createdFinancialServiceProviderXlsxTemplates?: Resolver<ResolversTypes['FinancialServiceProviderXlsxTemplateNodeConnection'], ParentType, ContextType, Partial<UserNodeCreatedFinancialServiceProviderXlsxTemplatesArgs>>;
  createdFinancialServiceProviders?: Resolver<ResolversTypes['FinancialServiceProviderNodeConnection'], ParentType, ContextType, Partial<UserNodeCreatedFinancialServiceProvidersArgs>>;
  createdPaymentPlans?: Resolver<ResolversTypes['PaymentPlanNodeConnection'], ParentType, ContextType, Partial<UserNodeCreatedPaymentPlansArgs>>;
  createdTickets?: Resolver<ResolversTypes['GrievanceTicketNodeConnection'], ParentType, ContextType, Partial<UserNodeCreatedTicketsArgs>>;
  customFields?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  dateJoined?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  doapHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  documentSet?: Resolver<ResolversTypes['DocumentNodeConnection'], ParentType, ContextType, Partial<UserNodeDocumentSetArgs>>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  feedbackMessages?: Resolver<ResolversTypes['FeedbackMessageNodeConnection'], ParentType, ContextType, Partial<UserNodeFeedbackMessagesArgs>>;
  feedbacks?: Resolver<ResolversTypes['FeedbackNodeConnection'], ParentType, ContextType, Partial<UserNodeFeedbacksArgs>>;
  finalizedTargetPopulations?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<UserNodeFinalizedTargetPopulationsArgs>>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isStaff?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSuperuser?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  jobTitle?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastDoapSync?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastLogin?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastModifyDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logs?: Resolver<ResolversTypes['PaymentVerificationLogEntryNodeConnection'], ParentType, ContextType, Partial<UserNodeLogsArgs>>;
  messages?: Resolver<ResolversTypes['CommunicationMessageNodeConnection'], ParentType, ContextType, Partial<UserNodeMessagesArgs>>;
  partner?: Resolver<Maybe<ResolversTypes['PartnerNodeForProgram']>, ParentType, ContextType>;
  registrationDataImports?: Resolver<ResolversTypes['RegistrationDataImportNodeConnection'], ParentType, ContextType, Partial<UserNodeRegistrationDataImportsArgs>>;
  reports?: Resolver<ResolversTypes['ReportNodeConnection'], ParentType, ContextType, Partial<UserNodeReportsArgs>>;
  sentDeliveryMechanisms?: Resolver<ResolversTypes['DeliveryMechanismNodeConnection'], ParentType, ContextType, Partial<UserNodeSentDeliveryMechanismsArgs>>;
  status?: Resolver<ResolversTypes['UserStatus'], ParentType, ContextType>;
  surveys?: Resolver<ResolversTypes['SurveyNodeConnection'], ParentType, ContextType, Partial<UserNodeSurveysArgs>>;
  targetPopulations?: Resolver<ResolversTypes['TargetPopulationNodeConnection'], ParentType, ContextType, Partial<UserNodeTargetPopulationsArgs>>;
  ticketNotes?: Resolver<ResolversTypes['TicketNoteNodeConnection'], ParentType, ContextType, Partial<UserNodeTicketNotesArgs>>;
  userRoles?: Resolver<Array<ResolversTypes['UserRoleNode']>, ParentType, ContextType>;
  username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserNodeConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserNodeConnection'] = ResolversParentTypes['UserNodeConnection']> = {
  edgeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  edges?: Resolver<Array<Maybe<ResolversTypes['UserNodeEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserNodeEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserNodeEdge'] = ResolversParentTypes['UserNodeEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserNode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserRoleNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserRoleNode'] = ResolversParentTypes['UserRoleNode']> = {
  businessArea?: Resolver<ResolversTypes['UserBusinessAreaNode'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  expiryDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  role?: Resolver<ResolversTypes['RoleNode'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VolumeByDeliveryMechanismNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['VolumeByDeliveryMechanismNode'] = ResolversParentTypes['VolumeByDeliveryMechanismNode']> = {
  deliveryMechanism?: Resolver<Maybe<ResolversTypes['DeliveryMechanismNode']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  volume?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  volumeUsd?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XlsxErrorNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['XlsxErrorNode'] = ResolversParentTypes['XlsxErrorNode']> = {
  coordinates?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sheet?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type XlsxRowErrorNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['XlsxRowErrorNode'] = ResolversParentTypes['XlsxRowErrorNode']> = {
  header?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rowNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type _DatasetsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['_DatasetsNode'] = ResolversParentTypes['_DatasetsNode']> = {
  data?: Resolver<Maybe<Array<Maybe<ResolversTypes['Float']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type _DetailedDatasetsNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['_DetailedDatasetsNode'] = ResolversParentTypes['_DetailedDatasetsNode']> = {
  data?: Resolver<Maybe<Array<Maybe<ResolversTypes['Float']>>>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type _TableTotalCashTransferredDataNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['_TableTotalCashTransferredDataNode'] = ResolversParentTypes['_TableTotalCashTransferredDataNode']> = {
  admin2?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  totalCashTransferred?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  totalHouseholds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AccountabilitySampleSizeNode?: AccountabilitySampleSizeNodeResolvers<ContextType>;
  ActionPaymentPlanMutation?: ActionPaymentPlanMutationResolvers<ContextType>;
  ActivatePaymentVerificationPlan?: ActivatePaymentVerificationPlanResolvers<ContextType>;
  AgeFilterObject?: AgeFilterObjectResolvers<ContextType>;
  ApprovalNode?: ApprovalNodeResolvers<ContextType>;
  ApprovalProcessNode?: ApprovalProcessNodeResolvers<ContextType>;
  ApprovalProcessNodeConnection?: ApprovalProcessNodeConnectionResolvers<ContextType>;
  ApprovalProcessNodeEdge?: ApprovalProcessNodeEdgeResolvers<ContextType>;
  AreaGroupNode?: AreaGroupNodeResolvers<ContextType>;
  AreaNode?: AreaNodeResolvers<ContextType>;
  AreaNodeConnection?: AreaNodeConnectionResolvers<ContextType>;
  AreaNodeEdge?: AreaNodeEdgeResolvers<ContextType>;
  AreaTreeNode?: AreaTreeNodeResolvers<ContextType>;
  AreaTypeNode?: AreaTypeNodeResolvers<ContextType>;
  AreaTypeNodeConnection?: AreaTypeNodeConnectionResolvers<ContextType>;
  AreaTypeNodeEdge?: AreaTypeNodeEdgeResolvers<ContextType>;
  Arg?: GraphQLScalarType;
  AssignFspToDeliveryMechanismMutation?: AssignFspToDeliveryMechanismMutationResolvers<ContextType>;
  BankAccountInfoNode?: BankAccountInfoNodeResolvers<ContextType>;
  BankAccountInfoNodeConnection?: BankAccountInfoNodeConnectionResolvers<ContextType>;
  BankAccountInfoNodeEdge?: BankAccountInfoNodeEdgeResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  BulkGrievanceAddNoteMutation?: BulkGrievanceAddNoteMutationResolvers<ContextType>;
  BulkUpdateGrievanceTicketsAssigneesMutation?: BulkUpdateGrievanceTicketsAssigneesMutationResolvers<ContextType>;
  BulkUpdateGrievanceTicketsPriorityMutation?: BulkUpdateGrievanceTicketsPriorityMutationResolvers<ContextType>;
  BulkUpdateGrievanceTicketsUrgencyMutation?: BulkUpdateGrievanceTicketsUrgencyMutationResolvers<ContextType>;
  BusinessAreaNode?: BusinessAreaNodeResolvers<ContextType>;
  BusinessAreaNodeConnection?: BusinessAreaNodeConnectionResolvers<ContextType>;
  BusinessAreaNodeEdge?: BusinessAreaNodeEdgeResolvers<ContextType>;
  CashPlanAndPaymentPlanEdges?: CashPlanAndPaymentPlanEdgesResolvers<ContextType>;
  CashPlanAndPaymentPlanNode?: CashPlanAndPaymentPlanNodeResolvers<ContextType>;
  CashPlanNode?: CashPlanNodeResolvers<ContextType>;
  CashPlanNodeConnection?: CashPlanNodeConnectionResolvers<ContextType>;
  CashPlanNodeEdge?: CashPlanNodeEdgeResolvers<ContextType>;
  ChartDatasetNode?: ChartDatasetNodeResolvers<ContextType>;
  ChartDetailedDatasetsNode?: ChartDetailedDatasetsNodeResolvers<ContextType>;
  ChartGrievanceTicketsNode?: ChartGrievanceTicketsNodeResolvers<ContextType>;
  ChartPaymentVerification?: ChartPaymentVerificationResolvers<ContextType>;
  CheckAgainstSanctionListMutation?: CheckAgainstSanctionListMutationResolvers<ContextType>;
  ChoiceObject?: ChoiceObjectResolvers<ContextType>;
  ChoiceObjectInt?: ChoiceObjectIntResolvers<ContextType>;
  ChooseDeliveryMechanismsForPaymentPlanMutation?: ChooseDeliveryMechanismsForPaymentPlanMutationResolvers<ContextType>;
  CommunicationMessageNode?: CommunicationMessageNodeResolvers<ContextType>;
  CommunicationMessageNodeConnection?: CommunicationMessageNodeConnectionResolvers<ContextType>;
  CommunicationMessageNodeEdge?: CommunicationMessageNodeEdgeResolvers<ContextType>;
  CommunicationMessageRecipientMapNode?: CommunicationMessageRecipientMapNodeResolvers<ContextType>;
  CommunicationMessageRecipientMapNodeConnection?: CommunicationMessageRecipientMapNodeConnectionResolvers<ContextType>;
  CommunicationMessageRecipientMapNodeEdge?: CommunicationMessageRecipientMapNodeEdgeResolvers<ContextType>;
  ContentTypeObjectType?: ContentTypeObjectTypeResolvers<ContextType>;
  CopyProgram?: CopyProgramResolvers<ContextType>;
  CopyTargetPopulationMutationPayload?: CopyTargetPopulationMutationPayloadResolvers<ContextType>;
  CoreFieldChoiceObject?: CoreFieldChoiceObjectResolvers<ContextType>;
  CountAndPercentageNode?: CountAndPercentageNodeResolvers<ContextType>;
  CreateCommunicationMessageMutation?: CreateCommunicationMessageMutationResolvers<ContextType>;
  CreateDashboardReport?: CreateDashboardReportResolvers<ContextType>;
  CreateFeedbackMessageMutation?: CreateFeedbackMessageMutationResolvers<ContextType>;
  CreateFeedbackMutation?: CreateFeedbackMutationResolvers<ContextType>;
  CreateFollowUpPaymentPlanMutation?: CreateFollowUpPaymentPlanMutationResolvers<ContextType>;
  CreateGrievanceTicketMutation?: CreateGrievanceTicketMutationResolvers<ContextType>;
  CreatePaymentPlanMutation?: CreatePaymentPlanMutationResolvers<ContextType>;
  CreateProgram?: CreateProgramResolvers<ContextType>;
  CreateReport?: CreateReportResolvers<ContextType>;
  CreateSurveyMutation?: CreateSurveyMutationResolvers<ContextType>;
  CreateTargetPopulationMutation?: CreateTargetPopulationMutationResolvers<ContextType>;
  CreateTicketNoteMutation?: CreateTicketNoteMutationResolvers<ContextType>;
  CreateVerificationPlanMutation?: CreateVerificationPlanMutationResolvers<ContextType>;
  DataCollectingTypeChoiceObject?: DataCollectingTypeChoiceObjectResolvers<ContextType>;
  DataCollectingTypeNode?: DataCollectingTypeNodeResolvers<ContextType>;
  DataCollectingTypeNodeConnection?: DataCollectingTypeNodeConnectionResolvers<ContextType>;
  DataCollectingTypeNodeEdge?: DataCollectingTypeNodeEdgeResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  Decimal?: GraphQLScalarType;
  DeduplicationResultNode?: DeduplicationResultNodeResolvers<ContextType>;
  DeleteHouseholdApproveMutation?: DeleteHouseholdApproveMutationResolvers<ContextType>;
  DeletePaymentPlanMutation?: DeletePaymentPlanMutationResolvers<ContextType>;
  DeletePaymentVerificationPlan?: DeletePaymentVerificationPlanResolvers<ContextType>;
  DeleteProgram?: DeleteProgramResolvers<ContextType>;
  DeleteRegistrationDataImport?: DeleteRegistrationDataImportResolvers<ContextType>;
  DeleteTargetPopulationMutationPayload?: DeleteTargetPopulationMutationPayloadResolvers<ContextType>;
  DeliveredQuantityNode?: DeliveredQuantityNodeResolvers<ContextType>;
  DeliveryMechanismNode?: DeliveryMechanismNodeResolvers<ContextType>;
  DeliveryMechanismNodeConnection?: DeliveryMechanismNodeConnectionResolvers<ContextType>;
  DeliveryMechanismNodeEdge?: DeliveryMechanismNodeEdgeResolvers<ContextType>;
  DiscardPaymentVerificationPlan?: DiscardPaymentVerificationPlanResolvers<ContextType>;
  DjangoDebug?: DjangoDebugResolvers<ContextType>;
  DjangoDebugSQL?: DjangoDebugSqlResolvers<ContextType>;
  DocumentNode?: DocumentNodeResolvers<ContextType>;
  DocumentNodeConnection?: DocumentNodeConnectionResolvers<ContextType>;
  DocumentNodeEdge?: DocumentNodeEdgeResolvers<ContextType>;
  DocumentTypeNode?: DocumentTypeNodeResolvers<ContextType>;
  EditPaymentVerificationMutation?: EditPaymentVerificationMutationResolvers<ContextType>;
  EraseRegistrationDataImportMutation?: EraseRegistrationDataImportMutationResolvers<ContextType>;
  ExcludeHouseholdsMutation?: ExcludeHouseholdsMutationResolvers<ContextType>;
  ExportPDFPaymentPlanSummaryMutation?: ExportPdfPaymentPlanSummaryMutationResolvers<ContextType>;
  ExportSurveySampleMutationMutation?: ExportSurveySampleMutationMutationResolvers<ContextType>;
  ExportXLSXPaymentPlanPaymentListMutation?: ExportXlsxPaymentPlanPaymentListMutationResolvers<ContextType>;
  ExportXLSXPaymentPlanPaymentListPerFSPMutation?: ExportXlsxPaymentPlanPaymentListPerFspMutationResolvers<ContextType>;
  ExportXlsxPaymentVerificationPlanFile?: ExportXlsxPaymentVerificationPlanFileResolvers<ContextType>;
  FeedbackMessageNode?: FeedbackMessageNodeResolvers<ContextType>;
  FeedbackMessageNodeConnection?: FeedbackMessageNodeConnectionResolvers<ContextType>;
  FeedbackMessageNodeEdge?: FeedbackMessageNodeEdgeResolvers<ContextType>;
  FeedbackNode?: FeedbackNodeResolvers<ContextType>;
  FeedbackNodeConnection?: FeedbackNodeConnectionResolvers<ContextType>;
  FeedbackNodeEdge?: FeedbackNodeEdgeResolvers<ContextType>;
  FieldAttributeNode?: FieldAttributeNodeResolvers<ContextType>;
  FilteredActionsListNode?: FilteredActionsListNodeResolvers<ContextType>;
  FinalizeTargetPopulationMutation?: FinalizeTargetPopulationMutationResolvers<ContextType>;
  FinancialServiceProviderNode?: FinancialServiceProviderNodeResolvers<ContextType>;
  FinancialServiceProviderNodeConnection?: FinancialServiceProviderNodeConnectionResolvers<ContextType>;
  FinancialServiceProviderNodeEdge?: FinancialServiceProviderNodeEdgeResolvers<ContextType>;
  FinancialServiceProviderXlsxReportNode?: FinancialServiceProviderXlsxReportNodeResolvers<ContextType>;
  FinancialServiceProviderXlsxReportNodeConnection?: FinancialServiceProviderXlsxReportNodeConnectionResolvers<ContextType>;
  FinancialServiceProviderXlsxReportNodeEdge?: FinancialServiceProviderXlsxReportNodeEdgeResolvers<ContextType>;
  FinancialServiceProviderXlsxTemplateNode?: FinancialServiceProviderXlsxTemplateNodeResolvers<ContextType>;
  FinancialServiceProviderXlsxTemplateNodeConnection?: FinancialServiceProviderXlsxTemplateNodeConnectionResolvers<ContextType>;
  FinancialServiceProviderXlsxTemplateNodeEdge?: FinancialServiceProviderXlsxTemplateNodeEdgeResolvers<ContextType>;
  FinishPaymentVerificationPlan?: FinishPaymentVerificationPlanResolvers<ContextType>;
  FlexFieldsScalar?: GraphQLScalarType;
  FspChoice?: FspChoiceResolvers<ContextType>;
  FspChoices?: FspChoicesResolvers<ContextType>;
  FspConfiguration?: FspConfigurationResolvers<ContextType>;
  GenericPaymentNode?: GenericPaymentNodeResolvers<ContextType>;
  GenericPaymentPlanNode?: GenericPaymentPlanNodeResolvers<ContextType>;
  GeoJSON?: GraphQLScalarType;
  GetCashplanVerificationSampleSizeObject?: GetCashplanVerificationSampleSizeObjectResolvers<ContextType>;
  GetCommunicationMessageSampleSizeNode?: GetCommunicationMessageSampleSizeNodeResolvers<ContextType>;
  GrievanceDocumentNode?: GrievanceDocumentNodeResolvers<ContextType>;
  GrievanceDocumentNodeConnection?: GrievanceDocumentNodeConnectionResolvers<ContextType>;
  GrievanceDocumentNodeEdge?: GrievanceDocumentNodeEdgeResolvers<ContextType>;
  GrievanceStatusChangeMutation?: GrievanceStatusChangeMutationResolvers<ContextType>;
  GrievanceTicketNode?: GrievanceTicketNodeResolvers<ContextType>;
  GrievanceTicketNodeConnection?: GrievanceTicketNodeConnectionResolvers<ContextType>;
  GrievanceTicketNodeEdge?: GrievanceTicketNodeEdgeResolvers<ContextType>;
  GroupAttributeNode?: GroupAttributeNodeResolvers<ContextType>;
  HouseholdDataChangeApproveMutation?: HouseholdDataChangeApproveMutationResolvers<ContextType>;
  HouseholdNode?: HouseholdNodeResolvers<ContextType>;
  HouseholdNodeConnection?: HouseholdNodeConnectionResolvers<ContextType>;
  HouseholdNodeEdge?: HouseholdNodeEdgeResolvers<ContextType>;
  HouseholdSelectionNode?: HouseholdSelectionNodeResolvers<ContextType>;
  ImportDataNode?: ImportDataNodeResolvers<ContextType>;
  ImportXLSXPaymentPlanPaymentListMutation?: ImportXlsxPaymentPlanPaymentListMutationResolvers<ContextType>;
  ImportXLSXPaymentPlanPaymentListPerFSPMutation?: ImportXlsxPaymentPlanPaymentListPerFspMutationResolvers<ContextType>;
  ImportXlsxPaymentVerificationPlanFile?: ImportXlsxPaymentVerificationPlanFileResolvers<ContextType>;
  ImportedDocumentNode?: ImportedDocumentNodeResolvers<ContextType>;
  ImportedDocumentNodeConnection?: ImportedDocumentNodeConnectionResolvers<ContextType>;
  ImportedDocumentNodeEdge?: ImportedDocumentNodeEdgeResolvers<ContextType>;
  ImportedDocumentTypeNode?: ImportedDocumentTypeNodeResolvers<ContextType>;
  ImportedHouseholdNode?: ImportedHouseholdNodeResolvers<ContextType>;
  ImportedHouseholdNodeConnection?: ImportedHouseholdNodeConnectionResolvers<ContextType>;
  ImportedHouseholdNodeEdge?: ImportedHouseholdNodeEdgeResolvers<ContextType>;
  ImportedIndividualIdentityNode?: ImportedIndividualIdentityNodeResolvers<ContextType>;
  ImportedIndividualIdentityNodeConnection?: ImportedIndividualIdentityNodeConnectionResolvers<ContextType>;
  ImportedIndividualIdentityNodeEdge?: ImportedIndividualIdentityNodeEdgeResolvers<ContextType>;
  ImportedIndividualNode?: ImportedIndividualNodeResolvers<ContextType>;
  ImportedIndividualNodeConnection?: ImportedIndividualNodeConnectionResolvers<ContextType>;
  ImportedIndividualNodeEdge?: ImportedIndividualNodeEdgeResolvers<ContextType>;
  IndividualDataChangeApproveMutation?: IndividualDataChangeApproveMutationResolvers<ContextType>;
  IndividualIdentityNode?: IndividualIdentityNodeResolvers<ContextType>;
  IndividualIdentityNodeConnection?: IndividualIdentityNodeConnectionResolvers<ContextType>;
  IndividualIdentityNodeEdge?: IndividualIdentityNodeEdgeResolvers<ContextType>;
  IndividualNode?: IndividualNodeResolvers<ContextType>;
  IndividualNodeConnection?: IndividualNodeConnectionResolvers<ContextType>;
  IndividualNodeEdge?: IndividualNodeEdgeResolvers<ContextType>;
  IndividualRoleInHouseholdNode?: IndividualRoleInHouseholdNodeResolvers<ContextType>;
  InvalidPaymentVerificationPlan?: InvalidPaymentVerificationPlanResolvers<ContextType>;
  IssueTypesObject?: IssueTypesObjectResolvers<ContextType>;
  JSONString?: GraphQLScalarType;
  KoboAssetObject?: KoboAssetObjectResolvers<ContextType>;
  KoboAssetObjectConnection?: KoboAssetObjectConnectionResolvers<ContextType>;
  KoboAssetObjectEdge?: KoboAssetObjectEdgeResolvers<ContextType>;
  KoboErrorNode?: KoboErrorNodeResolvers<ContextType>;
  KoboImportDataNode?: KoboImportDataNodeResolvers<ContextType>;
  LabelNode?: LabelNodeResolvers<ContextType>;
  LanguageObject?: LanguageObjectResolvers<ContextType>;
  LanguageObjectConnection?: LanguageObjectConnectionResolvers<ContextType>;
  LanguageObjectEdge?: LanguageObjectEdgeResolvers<ContextType>;
  LockTargetPopulationMutation?: LockTargetPopulationMutationResolvers<ContextType>;
  LogEntryNode?: LogEntryNodeResolvers<ContextType>;
  LogEntryNodeConnection?: LogEntryNodeConnectionResolvers<ContextType>;
  LogEntryNodeEdge?: LogEntryNodeEdgeResolvers<ContextType>;
  MarkPaymentAsFailedMutation?: MarkPaymentAsFailedMutationResolvers<ContextType>;
  MarkPaymentRecordAsFailedMutation?: MarkPaymentRecordAsFailedMutationResolvers<ContextType>;
  MergeRegistrationDataImportMutation?: MergeRegistrationDataImportMutationResolvers<ContextType>;
  Mutations?: MutationsResolvers<ContextType>;
  NeedsAdjudicationApproveMutation?: NeedsAdjudicationApproveMutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PageInfoNode?: PageInfoNodeResolvers<ContextType>;
  PaginatedCashPlanAndPaymentPlanNode?: PaginatedCashPlanAndPaymentPlanNodeResolvers<ContextType>;
  PaginatedPaymentRecordsAndPaymentsNode?: PaginatedPaymentRecordsAndPaymentsNodeResolvers<ContextType>;
  PartnerNodeForProgram?: PartnerNodeForProgramResolvers<ContextType>;
  PartnerType?: PartnerTypeResolvers<ContextType>;
  PaymentConflictDataNode?: PaymentConflictDataNodeResolvers<ContextType>;
  PaymentDetailsApproveMutation?: PaymentDetailsApproveMutationResolvers<ContextType>;
  PaymentHouseholdSnapshotNode?: PaymentHouseholdSnapshotNodeResolvers<ContextType>;
  PaymentNode?: PaymentNodeResolvers<ContextType>;
  PaymentNodeConnection?: PaymentNodeConnectionResolvers<ContextType>;
  PaymentNodeEdge?: PaymentNodeEdgeResolvers<ContextType>;
  PaymentPlanNode?: PaymentPlanNodeResolvers<ContextType>;
  PaymentPlanNodeConnection?: PaymentPlanNodeConnectionResolvers<ContextType>;
  PaymentPlanNodeEdge?: PaymentPlanNodeEdgeResolvers<ContextType>;
  PaymentRecordAndPaymentNode?: PaymentRecordAndPaymentNodeResolvers<ContextType>;
  PaymentRecordNode?: PaymentRecordNodeResolvers<ContextType>;
  PaymentRecordNodeConnection?: PaymentRecordNodeConnectionResolvers<ContextType>;
  PaymentRecordNodeEdge?: PaymentRecordNodeEdgeResolvers<ContextType>;
  PaymentRecordsAndPaymentsEdges?: PaymentRecordsAndPaymentsEdgesResolvers<ContextType>;
  PaymentVerificationLogEntryNode?: PaymentVerificationLogEntryNodeResolvers<ContextType>;
  PaymentVerificationLogEntryNodeConnection?: PaymentVerificationLogEntryNodeConnectionResolvers<ContextType>;
  PaymentVerificationLogEntryNodeEdge?: PaymentVerificationLogEntryNodeEdgeResolvers<ContextType>;
  PaymentVerificationNode?: PaymentVerificationNodeResolvers<ContextType>;
  PaymentVerificationNodeConnection?: PaymentVerificationNodeConnectionResolvers<ContextType>;
  PaymentVerificationNodeEdge?: PaymentVerificationNodeEdgeResolvers<ContextType>;
  PaymentVerificationPlanNode?: PaymentVerificationPlanNodeResolvers<ContextType>;
  PaymentVerificationPlanNodeConnection?: PaymentVerificationPlanNodeConnectionResolvers<ContextType>;
  PaymentVerificationPlanNodeEdge?: PaymentVerificationPlanNodeEdgeResolvers<ContextType>;
  PaymentVerificationSummaryNode?: PaymentVerificationSummaryNodeResolvers<ContextType>;
  PaymentVerificationSummaryNodeConnection?: PaymentVerificationSummaryNodeConnectionResolvers<ContextType>;
  PaymentVerificationSummaryNodeEdge?: PaymentVerificationSummaryNodeEdgeResolvers<ContextType>;
  ProgramNode?: ProgramNodeResolvers<ContextType>;
  ProgramNodeConnection?: ProgramNodeConnectionResolvers<ContextType>;
  ProgramNodeEdge?: ProgramNodeEdgeResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RapidProFlow?: RapidProFlowResolvers<ContextType>;
  RapidProFlowNode?: RapidProFlowNodeResolvers<ContextType>;
  RapidProFlowResult?: RapidProFlowResultResolvers<ContextType>;
  RapidProFlowRun?: RapidProFlowRunResolvers<ContextType>;
  ReassignRoleMutation?: ReassignRoleMutationResolvers<ContextType>;
  RebuildTargetPopulationMutation?: RebuildTargetPopulationMutationResolvers<ContextType>;
  RecipientNode?: RecipientNodeResolvers<ContextType>;
  RecipientNodeConnection?: RecipientNodeConnectionResolvers<ContextType>;
  RecipientNodeEdge?: RecipientNodeEdgeResolvers<ContextType>;
  ReconciliationSummaryNode?: ReconciliationSummaryNodeResolvers<ContextType>;
  RefuseRegistrationDataImportMutation?: RefuseRegistrationDataImportMutationResolvers<ContextType>;
  RegistrationDataImportDatahubNode?: RegistrationDataImportDatahubNodeResolvers<ContextType>;
  RegistrationDataImportDatahubNodeConnection?: RegistrationDataImportDatahubNodeConnectionResolvers<ContextType>;
  RegistrationDataImportDatahubNodeEdge?: RegistrationDataImportDatahubNodeEdgeResolvers<ContextType>;
  RegistrationDataImportNode?: RegistrationDataImportNodeResolvers<ContextType>;
  RegistrationDataImportNodeConnection?: RegistrationDataImportNodeConnectionResolvers<ContextType>;
  RegistrationDataImportNodeEdge?: RegistrationDataImportNodeEdgeResolvers<ContextType>;
  RegistrationDeduplicationMutation?: RegistrationDeduplicationMutationResolvers<ContextType>;
  RegistrationKoboImportMutation?: RegistrationKoboImportMutationResolvers<ContextType>;
  RegistrationXlsxImportMutation?: RegistrationXlsxImportMutationResolvers<ContextType>;
  ReportNode?: ReportNodeResolvers<ContextType>;
  ReportNodeConnection?: ReportNodeConnectionResolvers<ContextType>;
  ReportNodeEdge?: ReportNodeEdgeResolvers<ContextType>;
  RestartCreateReport?: RestartCreateReportResolvers<ContextType>;
  RevertMarkPaymentAsFailedMutation?: RevertMarkPaymentAsFailedMutationResolvers<ContextType>;
  RevertMarkPaymentRecordAsFailedMutation?: RevertMarkPaymentRecordAsFailedMutationResolvers<ContextType>;
  RoleChoiceObject?: RoleChoiceObjectResolvers<ContextType>;
  RoleNode?: RoleNodeResolvers<ContextType>;
  RuleCommitNode?: RuleCommitNodeResolvers<ContextType>;
  RuleCommitNodeConnection?: RuleCommitNodeConnectionResolvers<ContextType>;
  RuleCommitNodeEdge?: RuleCommitNodeEdgeResolvers<ContextType>;
  SanctionListIndividualAliasNameNode?: SanctionListIndividualAliasNameNodeResolvers<ContextType>;
  SanctionListIndividualAliasNameNodeConnection?: SanctionListIndividualAliasNameNodeConnectionResolvers<ContextType>;
  SanctionListIndividualAliasNameNodeEdge?: SanctionListIndividualAliasNameNodeEdgeResolvers<ContextType>;
  SanctionListIndividualCountriesNode?: SanctionListIndividualCountriesNodeResolvers<ContextType>;
  SanctionListIndividualCountriesNodeConnection?: SanctionListIndividualCountriesNodeConnectionResolvers<ContextType>;
  SanctionListIndividualCountriesNodeEdge?: SanctionListIndividualCountriesNodeEdgeResolvers<ContextType>;
  SanctionListIndividualDateOfBirthNode?: SanctionListIndividualDateOfBirthNodeResolvers<ContextType>;
  SanctionListIndividualDateOfBirthNodeConnection?: SanctionListIndividualDateOfBirthNodeConnectionResolvers<ContextType>;
  SanctionListIndividualDateOfBirthNodeEdge?: SanctionListIndividualDateOfBirthNodeEdgeResolvers<ContextType>;
  SanctionListIndividualDocumentNode?: SanctionListIndividualDocumentNodeResolvers<ContextType>;
  SanctionListIndividualDocumentNodeConnection?: SanctionListIndividualDocumentNodeConnectionResolvers<ContextType>;
  SanctionListIndividualDocumentNodeEdge?: SanctionListIndividualDocumentNodeEdgeResolvers<ContextType>;
  SanctionListIndividualNationalitiesNode?: SanctionListIndividualNationalitiesNodeResolvers<ContextType>;
  SanctionListIndividualNationalitiesNodeConnection?: SanctionListIndividualNationalitiesNodeConnectionResolvers<ContextType>;
  SanctionListIndividualNationalitiesNodeEdge?: SanctionListIndividualNationalitiesNodeEdgeResolvers<ContextType>;
  SanctionListIndividualNode?: SanctionListIndividualNodeResolvers<ContextType>;
  SanctionListIndividualNodeConnection?: SanctionListIndividualNodeConnectionResolvers<ContextType>;
  SanctionListIndividualNodeEdge?: SanctionListIndividualNodeEdgeResolvers<ContextType>;
  SaveKoboProjectImportDataAsync?: SaveKoboProjectImportDataAsyncResolvers<ContextType>;
  SectionTotalNode?: SectionTotalNodeResolvers<ContextType>;
  ServiceProviderNode?: ServiceProviderNodeResolvers<ContextType>;
  ServiceProviderNodeConnection?: ServiceProviderNodeConnectionResolvers<ContextType>;
  ServiceProviderNodeEdge?: ServiceProviderNodeEdgeResolvers<ContextType>;
  SetSteficonRuleOnPaymentPlanPaymentListMutation?: SetSteficonRuleOnPaymentPlanPaymentListMutationResolvers<ContextType>;
  SetSteficonRuleOnTargetPopulationMutationPayload?: SetSteficonRuleOnTargetPopulationMutationPayloadResolvers<ContextType>;
  SimpleApproveMutation?: SimpleApproveMutationResolvers<ContextType>;
  SplitPaymentPlanMutation?: SplitPaymentPlanMutationResolvers<ContextType>;
  SteficonRuleNode?: SteficonRuleNodeResolvers<ContextType>;
  SteficonRuleNodeConnection?: SteficonRuleNodeConnectionResolvers<ContextType>;
  SteficonRuleNodeEdge?: SteficonRuleNodeEdgeResolvers<ContextType>;
  SurveyNode?: SurveyNodeResolvers<ContextType>;
  SurveyNodeConnection?: SurveyNodeConnectionResolvers<ContextType>;
  SurveyNodeEdge?: SurveyNodeEdgeResolvers<ContextType>;
  TableTotalCashTransferred?: TableTotalCashTransferredResolvers<ContextType>;
  TargetPopulationNode?: TargetPopulationNodeResolvers<ContextType>;
  TargetPopulationNodeConnection?: TargetPopulationNodeConnectionResolvers<ContextType>;
  TargetPopulationNodeEdge?: TargetPopulationNodeEdgeResolvers<ContextType>;
  TargetingCriteriaNode?: TargetingCriteriaNodeResolvers<ContextType>;
  TargetingCriteriaRuleFilterNode?: TargetingCriteriaRuleFilterNodeResolvers<ContextType>;
  TargetingCriteriaRuleNode?: TargetingCriteriaRuleNodeResolvers<ContextType>;
  TargetingIndividualBlockRuleFilterNode?: TargetingIndividualBlockRuleFilterNodeResolvers<ContextType>;
  TargetingIndividualRuleFilterBlockNode?: TargetingIndividualRuleFilterBlockNodeResolvers<ContextType>;
  TicketAddIndividualDetailsNode?: TicketAddIndividualDetailsNodeResolvers<ContextType>;
  TicketAddIndividualDetailsNodeConnection?: TicketAddIndividualDetailsNodeConnectionResolvers<ContextType>;
  TicketAddIndividualDetailsNodeEdge?: TicketAddIndividualDetailsNodeEdgeResolvers<ContextType>;
  TicketByType?: TicketByTypeResolvers<ContextType>;
  TicketComplaintDetailsNode?: TicketComplaintDetailsNodeResolvers<ContextType>;
  TicketComplaintDetailsNodeConnection?: TicketComplaintDetailsNodeConnectionResolvers<ContextType>;
  TicketComplaintDetailsNodeEdge?: TicketComplaintDetailsNodeEdgeResolvers<ContextType>;
  TicketDeleteHouseholdDetailsNode?: TicketDeleteHouseholdDetailsNodeResolvers<ContextType>;
  TicketDeleteHouseholdDetailsNodeConnection?: TicketDeleteHouseholdDetailsNodeConnectionResolvers<ContextType>;
  TicketDeleteHouseholdDetailsNodeEdge?: TicketDeleteHouseholdDetailsNodeEdgeResolvers<ContextType>;
  TicketDeleteIndividualDetailsNode?: TicketDeleteIndividualDetailsNodeResolvers<ContextType>;
  TicketDeleteIndividualDetailsNodeConnection?: TicketDeleteIndividualDetailsNodeConnectionResolvers<ContextType>;
  TicketDeleteIndividualDetailsNodeEdge?: TicketDeleteIndividualDetailsNodeEdgeResolvers<ContextType>;
  TicketHouseholdDataUpdateDetailsNode?: TicketHouseholdDataUpdateDetailsNodeResolvers<ContextType>;
  TicketHouseholdDataUpdateDetailsNodeConnection?: TicketHouseholdDataUpdateDetailsNodeConnectionResolvers<ContextType>;
  TicketHouseholdDataUpdateDetailsNodeEdge?: TicketHouseholdDataUpdateDetailsNodeEdgeResolvers<ContextType>;
  TicketIndividualDataUpdateDetailsNode?: TicketIndividualDataUpdateDetailsNodeResolvers<ContextType>;
  TicketIndividualDataUpdateDetailsNodeConnection?: TicketIndividualDataUpdateDetailsNodeConnectionResolvers<ContextType>;
  TicketIndividualDataUpdateDetailsNodeEdge?: TicketIndividualDataUpdateDetailsNodeEdgeResolvers<ContextType>;
  TicketNeedsAdjudicationDetailsExtraDataNode?: TicketNeedsAdjudicationDetailsExtraDataNodeResolvers<ContextType>;
  TicketNeedsAdjudicationDetailsNode?: TicketNeedsAdjudicationDetailsNodeResolvers<ContextType>;
  TicketNeedsAdjudicationDetailsNodeConnection?: TicketNeedsAdjudicationDetailsNodeConnectionResolvers<ContextType>;
  TicketNeedsAdjudicationDetailsNodeEdge?: TicketNeedsAdjudicationDetailsNodeEdgeResolvers<ContextType>;
  TicketNegativeFeedbackDetailsNode?: TicketNegativeFeedbackDetailsNodeResolvers<ContextType>;
  TicketNegativeFeedbackDetailsNodeConnection?: TicketNegativeFeedbackDetailsNodeConnectionResolvers<ContextType>;
  TicketNegativeFeedbackDetailsNodeEdge?: TicketNegativeFeedbackDetailsNodeEdgeResolvers<ContextType>;
  TicketNoteNode?: TicketNoteNodeResolvers<ContextType>;
  TicketNoteNodeConnection?: TicketNoteNodeConnectionResolvers<ContextType>;
  TicketNoteNodeEdge?: TicketNoteNodeEdgeResolvers<ContextType>;
  TicketPaymentVerificationDetailsNode?: TicketPaymentVerificationDetailsNodeResolvers<ContextType>;
  TicketPaymentVerificationDetailsNodeConnection?: TicketPaymentVerificationDetailsNodeConnectionResolvers<ContextType>;
  TicketPaymentVerificationDetailsNodeEdge?: TicketPaymentVerificationDetailsNodeEdgeResolvers<ContextType>;
  TicketPositiveFeedbackDetailsNode?: TicketPositiveFeedbackDetailsNodeResolvers<ContextType>;
  TicketPositiveFeedbackDetailsNodeConnection?: TicketPositiveFeedbackDetailsNodeConnectionResolvers<ContextType>;
  TicketPositiveFeedbackDetailsNodeEdge?: TicketPositiveFeedbackDetailsNodeEdgeResolvers<ContextType>;
  TicketReferralDetailsNode?: TicketReferralDetailsNodeResolvers<ContextType>;
  TicketReferralDetailsNodeConnection?: TicketReferralDetailsNodeConnectionResolvers<ContextType>;
  TicketReferralDetailsNodeEdge?: TicketReferralDetailsNodeEdgeResolvers<ContextType>;
  TicketSensitiveDetailsNode?: TicketSensitiveDetailsNodeResolvers<ContextType>;
  TicketSensitiveDetailsNodeConnection?: TicketSensitiveDetailsNodeConnectionResolvers<ContextType>;
  TicketSensitiveDetailsNodeEdge?: TicketSensitiveDetailsNodeEdgeResolvers<ContextType>;
  TicketSystemFlaggingDetailsNode?: TicketSystemFlaggingDetailsNodeResolvers<ContextType>;
  TicketSystemFlaggingDetailsNodeConnection?: TicketSystemFlaggingDetailsNodeConnectionResolvers<ContextType>;
  TicketSystemFlaggingDetailsNodeEdge?: TicketSystemFlaggingDetailsNodeEdgeResolvers<ContextType>;
  UUID?: GraphQLScalarType;
  UnlockTargetPopulationMutation?: UnlockTargetPopulationMutationResolvers<ContextType>;
  UpdateFeedbackMutation?: UpdateFeedbackMutationResolvers<ContextType>;
  UpdateGrievanceTicketMutation?: UpdateGrievanceTicketMutationResolvers<ContextType>;
  UpdatePaymentPlanMutation?: UpdatePaymentPlanMutationResolvers<ContextType>;
  UpdatePaymentVerificationReceivedAndReceivedAmount?: UpdatePaymentVerificationReceivedAndReceivedAmountResolvers<ContextType>;
  UpdatePaymentVerificationStatusAndReceivedAmount?: UpdatePaymentVerificationStatusAndReceivedAmountResolvers<ContextType>;
  UpdateProgram?: UpdateProgramResolvers<ContextType>;
  UpdateTargetPopulationMutation?: UpdateTargetPopulationMutationResolvers<ContextType>;
  Upload?: GraphQLScalarType;
  UploadImportDataXLSXFileAsync?: UploadImportDataXlsxFileAsyncResolvers<ContextType>;
  UserBusinessAreaNode?: UserBusinessAreaNodeResolvers<ContextType>;
  UserBusinessAreaNodeConnection?: UserBusinessAreaNodeConnectionResolvers<ContextType>;
  UserBusinessAreaNodeEdge?: UserBusinessAreaNodeEdgeResolvers<ContextType>;
  UserNode?: UserNodeResolvers<ContextType>;
  UserNodeConnection?: UserNodeConnectionResolvers<ContextType>;
  UserNodeEdge?: UserNodeEdgeResolvers<ContextType>;
  UserRoleNode?: UserRoleNodeResolvers<ContextType>;
  VolumeByDeliveryMechanismNode?: VolumeByDeliveryMechanismNodeResolvers<ContextType>;
  XlsxErrorNode?: XlsxErrorNodeResolvers<ContextType>;
  XlsxRowErrorNode?: XlsxRowErrorNodeResolvers<ContextType>;
  _DatasetsNode?: _DatasetsNodeResolvers<ContextType>;
  _DetailedDatasetsNode?: _DetailedDatasetsNodeResolvers<ContextType>;
  _TableTotalCashTransferredDataNode?: _TableTotalCashTransferredDataNodeResolvers<ContextType>;
};

