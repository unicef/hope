schema {
  query: Query
  mutation: Mutations
}

input AccountabilityCommunicationMessageAgeInput {
  min: Int
  max: Int
}

input AccountabilityFullListArguments {
  excludedAdminAreas: [String]
}

input AccountabilityRandomSamplingArguments {
  excludedAdminAreas: [String]
  confidenceInterval: Float!
  marginOfError: Float!
  age: AccountabilityCommunicationMessageAgeInput
  sex: String
}

type ActivateCashPlanVerificationMutation {
  validationErrors: Arg
  cashPlan: CashPlanNode
}

input AddIndividualDataObjectType {
  fullName: String!
  givenName: String
  middleName: String
  familyName: String
  sex: String!
  birthDate: Date!
  estimatedBirthDate: Boolean!
  maritalStatus: String
  phoneNo: String
  phoneNoAlternative: String
  relationship: String!
  disability: Boolean
  workStatus: String
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String
  hearingDisability: String
  physicalDisability: String
  memoryDisability: String
  selfcareDisability: String
  commsDisability: String
  whoAnswersPhone: String
  whoAnswersAltPhone: String
  role: String!
  documents: [IndividualDocumentObjectType]
  identities: [IndividualIdentityObjectType]
  paymentChannels: [BankTransferObjectType]
  businessArea: String
  flexFields: Arg
}

input AddIndividualIssueTypeExtras {
  household: ID!
  individualData: AddIndividualDataObjectType!
}

type AgeFilterObject {
  min: Int
  max: Int
}

input AgeInput {
  min: Int
  max: Int
}

type AgencyNode {
  id: ID!
  type: AgencyType!
  label: String!
  country: String
  individualIdentities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  countryIso3: String
}

enum AgencyType {
  UNHCR
  WFP
}

type AreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  originalId: UUID
  name: String!
  parent: AreaNode
  pCode: String
  areaType: AreaTypeNode!
  validFrom: DateTime
  validUntil: DateTime
  extras: JSONString!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  areaSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
}

type AreaNodeConnection {
  pageInfo: PageInfo!
  edges: [AreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AreaNodeEdge {
  node: AreaNode
  cursor: String!
}

type AreaTypeNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  originalId: UUID
  name: String!
  areaLevel: Int!
  parent: AreaTypeNode
  validFrom: DateTime
  validUntil: DateTime
  extras: JSONString!
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  areatypeSet(offset: Int, before: String, after: String, first: Int, last: Int): AreaTypeNodeConnection!
  areaSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
}

type AreaTypeNodeConnection {
  pageInfo: PageInfo!
  edges: [AreaTypeNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type AreaTypeNodeEdge {
  node: AreaTypeNode
  cursor: String!
}

scalar Arg

type BankAccountInfoNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  individual: IndividualNode!
  bankName: String!
  bankAccountNumber: String!
  type: String
}

input BankTransferObjectType {
  type: String!
  bankName: String!
  bankAccountNumber: String!
}

scalar BigInt

type BulkUpdateGrievanceTicketsAssigneesMutation {
  grievanceTickets: [GrievanceTicketNode]
}

type BusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboUsername: String
  rapidProHost: String
  rapidProApiKey: String
  slug: String!
  customFields: JSONString!
  hasDataSharingAgreement: Boolean!
  parent: UserBusinessAreaNode
  isSplit: Boolean!
  postponeDeduplication: Boolean!
  deduplicationDuplicateScore: Float!
  deduplicationPossibleDuplicateScore: Float!
  deduplicationBatchDuplicatesPercentage: Int!
  deduplicationBatchDuplicatesAllowed: Int!
  deduplicationGoldenRecordDuplicatesPercentage: Int!
  deduplicationGoldenRecordDuplicatesAllowed: Int!
  screenBeneficiary: Boolean!
  deduplicationIgnoreWithdraw: Boolean!
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  userRoles: [UserRoleNode!]!
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  serviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): ServiceProviderNodeConnection!
  tickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualSet(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  programSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  cashplanSet(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  registrationdataimportSet(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  targetpopulationSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logentrySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messageSet(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveySet(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
}

type BusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [BusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type BusinessAreaNodeEdge {
  node: BusinessAreaNode
  cursor: String!
}

type CashPlanNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  caId: String
  caHashId: UUID
  status: CashPlanStatus!
  statusDate: DateTime!
  name: String!
  distributionLevel: String!
  startDate: DateTime!
  endDate: DateTime!
  dispersionDate: DateTime!
  coverageDuration: Int!
  coverageUnit: String!
  comments: String
  program: ProgramNode!
  deliveryType: String
  assistanceMeasurement: String!
  assistanceThrough: String!
  serviceProvider: ServiceProviderNode
  visionId: String
  fundsCommitment: String
  exchangeRate: Float
  downPayment: String
  validationAlertsCount: Int!
  totalPersonsCovered: Int!
  totalPersonsCoveredRevised: Int!
  totalEntitledQuantity: Float
  totalEntitledQuantityRevised: Float
  totalDeliveredQuantity: Float
  totalUndeliveredQuantity: Float
  paymentRecords(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  verifications(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanPaymentVerificationNodeConnection!
  cashPlanPaymentVerificationSummary: CashPlanPaymentVerificationSummaryNode
  bankReconciliationSuccess: Int
  bankReconciliationError: Int
  totalNumberOfHouseholds: Int
  currency: String
  canCreatePaymentVerificationPlan: Boolean
  availablePaymentRecordsCount: Int
}

type CashPlanNodeConnection {
  pageInfo: PageInfo!
  edges: [CashPlanNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CashPlanNodeEdge {
  node: CashPlanNode
  cursor: String!
}

type CashPlanPaymentVerificationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  status: CashPlanPaymentVerificationStatus!
  cashPlan: CashPlanNode!
  sampling: CashPlanPaymentVerificationSampling!
  verificationChannel: CashPlanPaymentVerificationVerificationChannel!
  sampleSize: Int
  respondedCount: Int
  receivedCount: Int
  notReceivedCount: Int
  receivedWithProblemsCount: Int
  confidenceInterval: Float
  marginOfError: Float
  rapidProFlowId: String!
  rapidProFlowStartUuids: [String!]!
  ageFilter: AgeFilterObject
  excludedAdminAreasFilter: [String]
  sexFilter: String
  activationDate: DateTime
  completionDate: DateTime
  xlsxFileExporting: Boolean!
  xlsxFileImported: Boolean!
  error: String
  paymentRecordVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  xlsxFileWasDownloaded: Boolean
  hasXlsxFile: Boolean
}

type CashPlanPaymentVerificationNodeConnection {
  pageInfo: PageInfo!
  edges: [CashPlanPaymentVerificationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CashPlanPaymentVerificationNodeEdge {
  node: CashPlanPaymentVerificationNode
  cursor: String!
}

enum CashPlanPaymentVerificationSampling {
  FULL_LIST
  RANDOM
}

enum CashPlanPaymentVerificationStatus {
  ACTIVE
  FINISHED
  PENDING
  INVALID
  RAPID_PRO_ERROR
}

type CashPlanPaymentVerificationSummaryNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: CashPlanPaymentVerificationSummaryStatus!
  activationDate: DateTime
  completionDate: DateTime
  cashPlan: CashPlanNode!
}

enum CashPlanPaymentVerificationSummaryStatus {
  ACTIVE
  FINISHED
  PENDING
}

enum CashPlanPaymentVerificationVerificationChannel {
  MANUAL
  RAPIDPRO
  XLSX
}

enum CashPlanStatus {
  DISTRIBUTION_COMPLETED
  DISTRIBUTION_COMPLETED_WITH_ERRORS
  TRANSACTION_COMPLETED
  TRANSACTION_COMPLETED_WITH_ERRORS
}

input CategoryExtrasInput {
  sensitiveGrievanceTicketExtras: SensitiveGrievanceTicketExtras
  grievanceComplaintTicketExtras: GrievanceComplaintTicketExtras
  positiveFeedbackTicketExtras: PositiveFeedbackTicketExtras
  negativeFeedbackTicketExtras: NegativeFeedbackTicketExtras
  referralTicketExtras: ReferralTicketExtras
}

type ChartDatasetNode {
  labels: [String]
  datasets: [_DatasetsNode]
}

type ChartDetailedDatasetsNode {
  labels: [String]
  datasets: [_DetailedDatasetsNode]
}

type ChartGrievanceTicketsNode {
  labels: [String]
  datasets: [_DatasetsNode]
  totalNumberOfGrievances: Int
  totalNumberOfFeedback: Int
  totalNumberOfOpenSensitive: Int
}

type ChartPaymentVerification {
  labels: [String]
  datasets: [_DetailedDatasetsNode]
  households: Int
  averageSampleSize: Float
}

type CheckAgainstSanctionListMutation {
  ok: Boolean
  errors: [XlsxRowErrorNode]
}

type ChoiceObject {
  name: String
  value: String
}

type ChoiceObjectInt {
  name: String
  value: Int
}

type CommunicationMessageNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  title: String!
  body: String!
  createdBy: UserNode
  numberOfRecipients: Int!
  businessArea: UserBusinessAreaNode!
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  targetPopulation: TargetPopulationNode
  registrationDataImport: RegistrationDataImportNode
  samplingType: MessageSamplingType!
  fullListArguments: JSONString
  randomSamplingArguments: JSONString
  sampleSize: Int!
}

type CommunicationMessageNodeConnection {
  pageInfo: PageInfo!
  edges: [CommunicationMessageNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CommunicationMessageNodeEdge {
  node: CommunicationMessageNode
  cursor: String!
}

type CommunicationMessageRecipientMapNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode!
}

type CommunicationMessageRecipientMapNodeConnection {
  pageInfo: PageInfo!
  edges: [CommunicationMessageRecipientMapNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type CommunicationMessageRecipientMapNodeEdge {
  node: CommunicationMessageRecipientMapNode
  cursor: String!
}

type ContentTypeObjectType {
  id: ID!
  appLabel: String!
  model: String!
  logEntries(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  name: String
}

input CopyTargetPopulationInput {
  id: ID
  name: String
}

input CopyTargetPopulationMutationInput {
  targetPopulationData: CopyTargetPopulationInput
  clientMutationId: String
}

type CopyTargetPopulationMutationPayload {
  targetPopulation: TargetPopulationNode
  validationErrors: Arg
  clientMutationId: String
}

type CoreFieldChoiceObject {
  labels: [LabelNode]
  labelEn: String
  value: String
  admin: String
  listName: String
}

type CountAndPercentageNode {
  count: Int
  percentage: Float
}

input CreateAccountabilityCommunicationMessageInput {
  households: [ID]
  targetPopulation: ID
  registrationDataImport: ID
  samplingType: SamplingChoices!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
  title: String!
  body: String!
}

type CreateCommunicationMessageMutation {
  message: CommunicationMessageNode
}

type CreateDashboardReport {
  success: Boolean
}

input CreateDashboardReportInput {
  reportTypes: [String]!
  businessAreaSlug: String!
  year: Int!
  adminArea: ID
  program: ID
}

input CreateFeedbackInput {
  businessAreaSlug: String!
  issueType: String!
  householdLookup: ID
  individualLookup: ID
  description: String!
  comments: String
  admin2: ID
  area: String
  language: String
  consent: Boolean
  program: ID
}

input CreateFeedbackMessageInput {
  description: String!
  feedback: ID!
}

type CreateFeedbackMessageMutation {
  feedbackMessage: FeedbackMessageNode
}

type CreateFeedbackMutation {
  feedback: FeedbackNode
}

input CreateGrievanceTicketExtrasInput {
  category: CategoryExtrasInput
  issueType: IssueTypeExtrasInput
}

input CreateGrievanceTicketInput {
  description: String!
  assignedTo: ID
  category: Int!
  issueType: Int
  admin: String
  area: String
  language: String!
  consent: Boolean!
  businessArea: ID!
  linkedTickets: [ID]
  extras: CreateGrievanceTicketExtrasInput
  priority: Int
  urgency: Int
  partner: Int
  programme: ID
  comments: String
  linkedFeedbackId: ID
  documentation: [GrievanceDocumentInput]
}

type CreateGrievanceTicketMutation {
  grievanceTickets: [GrievanceTicketNode]
}

input CreatePaymentVerificationInput {
  cashPlanId: ID!
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

type CreatePaymentVerificationMutation {
  cashPlan: CashPlanNode
}

type CreateProgram {
  validationErrors: Arg
  program: ProgramNode
}

input CreateProgramInput {
  name: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  scope: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  businessAreaSlug: String
  individualDataNeeded: Boolean
}

type CreateReport {
  report: ReportNode
}

input CreateReportInput {
  reportType: Int!
  businessAreaSlug: String!
  dateFrom: Date!
  dateTo: Date!
  adminArea: [ID]
  program: ID
}

input CreateSurveyInput {
  title: String!
  category: String!
  targetPopulation: ID
  program: ID
  samplingType: String!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
}

type CreateSurveyMutation {
  survey: SurveyNode
}

input CreateTargetPopulationInput {
  name: String!
  targetingCriteria: TargetingCriteriaObjectType!
  businessAreaSlug: String!
  programId: ID!
  excludedIds: String!
  exclusionReason: String
}

type CreateTargetPopulationMutation {
  validationErrors: Arg
  targetPopulation: TargetPopulationNode
}

input CreateTicketNoteInput {
  description: String!
  ticket: ID!
}

type CreateTicketNoteMutation {
  grievanceTicketNote: TicketNoteNode
}

scalar Date

scalar DateTime

scalar Decimal

type DeduplicationResultNode {
  hitId: ID
  fullName: String
  score: Float
  proximityToScore: Float
  location: String
  age: Int
}

type DeleteCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

type DeleteProgram {
  ok: Boolean
}

type DeleteRegistrationDataImport {
  ok: Boolean
}

input DeleteTargetPopulationMutationInput {
  targetId: ID!
  clientMutationId: String
}

type DeleteTargetPopulationMutationPayload {
  ok: Boolean
  clientMutationId: String
}

type DeliveredQuantityNode {
  totalDeliveredQuantity: Decimal
  currency: String
}

type DiscardCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

type DjangoDebug {
  sql: [DjangoDebugSQL]
}

type DjangoDebugSQL {
  vendor: String!
  alias: String!
  sql: String
  duration: Float!
  rawSql: String!
  params: String!
  startTime: Float!
  stopTime: Float!
  isSlow: Boolean!
  isSelect: Boolean!
  transId: String
  transStatus: String
  isoLevel: String
  encoding: String
}

type DocumentNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  photo: String
  individual: IndividualNode!
  type: DocumentTypeNode!
  country: String
  status: DocumentStatus!
  countryIso3: String
}

type DocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [DocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type DocumentNodeEdge {
  node: DocumentNode
  cursor: String!
}

enum DocumentStatus {
  PENDING
  VALID
  NEED_INVESTIGATION
  INVALID
}

type DocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  type: DocumentTypeType!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
}

enum DocumentTypeType {
  BIRTH_CERTIFICATE
  DRIVERS_LICENSE
  ELECTORAL_CARD
  NATIONAL_ID
  NATIONAL_PASSPORT
  TAX_ID
  RESIDENCE_PERMIT_NO
  OTHER
}

input EditBankTransferObjectType {
  id: ID!
  type: String!
  bankName: String!
  bankAccountNumber: String!
}

input EditCashPlanPaymentVerificationInput {
  cashPlanPaymentVerificationId: ID!
  sampling: String!
  verificationChannel: String!
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

input EditIndividualDocumentObjectType {
  id: ID!
  country: String!
  type: String!
  number: String!
  photo: Arg
  photoraw: Arg
}

input EditIndividualIdentityObjectType {
  id: ID!
  country: String!
  agency: String!
  number: String!
}

type EditPaymentVerificationMutation {
  cashPlan: CashPlanNode
}

type ExportXlsxCashPlanVerification {
  cashPlan: CashPlanNode
}

enum FeedbackIssueType {
  POSITIVE_FEEDBACK
  NEGATIVE_FEEDBACK
}

type FeedbackMessageNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  createdBy: UserNode
}

type FeedbackMessageNodeConnection {
  pageInfo: PageInfo!
  edges: [FeedbackMessageNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FeedbackMessageNodeEdge {
  node: FeedbackMessageNode
  cursor: String!
}

type FeedbackNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  businessArea: UserBusinessAreaNode!
  issueType: FeedbackIssueType!
  householdLookup: HouseholdNode
  individualLookup: IndividualNode
  description: String!
  comments: String
  admin2: AreaNode
  area: String!
  language: String!
  consent: Boolean!
  program: ProgramNode
  createdBy: UserNode
  linkedGrievance: GrievanceTicketNode
  feedbackMessages(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackMessageNodeConnection!
}

type FeedbackNodeConnection {
  pageInfo: PageInfo!
  edges: [FeedbackNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type FeedbackNodeEdge {
  node: FeedbackNode
  cursor: String!
}

type FieldAttributeNode {
  id: String
  type: String
  name: String
  labels: [LabelNode]
  labelEn: String
  hint: String
  required: Boolean
  choices: [CoreFieldChoiceObject]
  associatedWith: String
  isFlexField: Boolean
}

type FinalizeTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

type FinishCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

scalar FlexFieldsScalar

input FullListArguments {
  excludedAdminAreas: [String]
}

scalar GeoJSON

input GetAccountabilityCommunicationMessageSampleSizeInput {
  households: [ID]
  targetPopulation: ID
  registrationDataImport: ID
  samplingType: SamplingChoices!
  fullListArguments: AccountabilityFullListArguments
  randomSamplingArguments: AccountabilityRandomSamplingArguments
}

input GetCashplanVerificationSampleSizeInput {
  cashPlanId: ID
  cashPlanPaymentVerificationId: ID
  sampling: String!
  verificationChannel: String
  businessAreaSlug: String!
  fullListArguments: FullListArguments
  randomSamplingArguments: RandomSamplingArguments
  rapidProArguments: RapidProArguments
}

type GetCashplanVerificationSampleSizeObject {
  paymentRecordCount: Int
  sampleSize: Int
}

type GetCommunicationMessageSampleSizeObject {
  numberOfRecipients: Int
  sampleSize: Int
}

input GrievanceComplaintTicketExtras {
  household: ID
  individual: ID
  paymentRecord: [ID]
}

input GrievanceDocumentInput {
  name: String!
  file: Upload!
}

type GrievanceDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  createdBy: UserNode
  grievanceTicket: GrievanceTicketNode
  fileSize: Int
  contentType: String!
  filePath: String
  fileName: String
}

type GrievanceDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [GrievanceDocumentNodeEdge]!
}

type GrievanceDocumentNodeEdge {
  node: GrievanceDocumentNode
  cursor: String!
}

input GrievanceDocumentUpdateInput {
  id: ID!
  name: String
  file: Upload
}

type GrievanceStatusChangeMutation {
  grievanceTicket: GrievanceTicketNode
}

type GrievanceTicketNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  unicefId: String
  userModified: DateTime
  lastNotificationSent: DateTime
  createdBy: UserNode
  assignedTo: UserNode
  status: Int!
  category: Int!
  issueType: Int
  description: String!
  admin2: AreaNode
  area: String!
  language: String!
  consent: Boolean!
  businessArea: UserBusinessAreaNode!
  linkedTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  registrationDataImport: RegistrationDataImportNode
  extras: JSONString!
  ignored: Boolean!
  householdUnicefId: String
  priority: Int
  urgency: Int
  partner: PartnerType
  programme: ProgramNode
  comments: String
  linkedTicketsRelated(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  ticketNotes(offset: Int, before: String, after: String, first: Int, last: Int): TicketNoteNodeConnection!
  complaintTicketDetails: TicketComplaintDetailsNode
  sensitiveTicketDetails: TicketSensitiveDetailsNode
  householdDataUpdateTicketDetails: TicketHouseholdDataUpdateDetailsNode
  individualDataUpdateTicketDetails: TicketIndividualDataUpdateDetailsNode
  addIndividualTicketDetails: TicketAddIndividualDetailsNode
  deleteIndividualTicketDetails: TicketDeleteIndividualDetailsNode
  deleteHouseholdTicketDetails: TicketDeleteHouseholdDetailsNode
  systemFlaggingTicketDetails: TicketSystemFlaggingDetailsNode
  needsAdjudicationTicketDetails: TicketNeedsAdjudicationDetailsNode
  paymentVerificationTicketDetails: TicketPaymentVerificationDetailsNode
  positiveFeedbackTicketDetails: TicketPositiveFeedbackDetailsNode
  negativeFeedbackTicketDetails: TicketNegativeFeedbackDetailsNode
  referralTicketDetails: TicketReferralDetailsNode
  supportDocuments(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceDocumentNodeConnection!
  feedback: FeedbackNode
  household: HouseholdNode
  individual: IndividualNode
  paymentRecord: PaymentRecordNode
  relatedTickets: [GrievanceTicketNode]
  admin: String
  existingTickets: [GrievanceTicketNode]
  totalDays: String
  documentation: [GrievanceDocumentNode]
}

type GrievanceTicketNodeConnection {
  pageInfo: PageInfo!
  edges: [GrievanceTicketNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type GrievanceTicketNodeEdge {
  node: GrievanceTicketNode
  cursor: String!
}

type GroupAttributeNode {
  id: UUID!
  name: String!
  label: JSONString!
  flexAttributes(flexField: Boolean): [FieldAttributeNode]
  labelEn: String
}

enum HouseholdCollectIndividualData {
  A_
  A_2
  A_1
  A_0
}

type HouseholdDataChangeApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input HouseholdDataUpdateIssueTypeExtras {
  household: ID!
  householdData: HouseholdUpdateDataObjectType!
}

input HouseholdDeleteIssueTypeExtras {
  household: ID!
}

type HouseholdNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  withdrawn: Boolean!
  withdrawnDate: DateTime
  consentSign: String!
  consent: Boolean
  consentSharing: [String]
  residenceStatus: HouseholdResidenceStatus!
  countryOrigin: String
  country: String
  address: String!
  adminArea: AreaNode
  representatives(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  childrenCount: Int
  maleChildrenCount: Int
  femaleChildrenCount: Int
  childrenDisabledCount: Int
  maleChildrenDisabledCount: Int
  femaleChildrenDisabledCount: Int
  registrationDataImport: RegistrationDataImportNode
  programs(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  returnee: Boolean
  flexFields: FlexFieldsScalar
  firstRegistrationDate: DateTime!
  lastRegistrationDate: DateTime!
  fchildHoh: Boolean
  childHoh: Boolean
  unicefId: String!
  businessArea: UserBusinessAreaNode!
  start: DateTime
  deviceid: String!
  nameEnumerator: String!
  orgEnumerator: HouseholdOrgEnumerator!
  orgNameEnumerator: String!
  village: String!
  registrationMethod: HouseholdRegistrationMethod!
  collectIndividualData: HouseholdCollectIndividualData!
  currency: String
  unhcrId: String!
  userFields: JSONString!
  koboAssetId: String!
  rowId: Int
  totalCashReceivedUsd: Decimal
  totalCashReceived: Decimal
  paymentRecords(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  householdDataUpdateTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketHouseholdDataUpdateDetailsNodeConnection!
  addIndividualTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketAddIndividualDetailsNodeConnection!
  deleteHouseholdTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketDeleteHouseholdDetailsNodeConnection!
  positiveFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPositiveFeedbackDetailsNodeConnection!
  negativeFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketNegativeFeedbackDetailsNodeConnection!
  referralTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketReferralDetailsNodeConnection!
  individualsAndRoles: [IndividualRoleInHouseholdNode!]!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  selections: [HouseholdSelection!]!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  adminAreaTitle: String
  selection: HouseholdSelection
  sanctionListPossibleMatch: Boolean
  sanctionListConfirmedMatch: Boolean
  hasDuplicates: Boolean
  admin1: AreaNode
  admin2: AreaNode
  status: String
  programsWithDeliveredQuantity: [ProgramsWithDeliveredQuantityNode]
  activeIndividualsCount: Int
}

type HouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [HouseholdNodeEdge]!
  totalCount: Int
  individualsCount: Int
  edgeCount: Int
}

type HouseholdNodeEdge {
  node: HouseholdNode
  cursor: String!
}

enum HouseholdOrgEnumerator {
  A_
  PARTNER
  UNICEF
}

enum HouseholdRegistrationMethod {
  A_
  COMMUNITY
  HH_REGISTRATION
}

enum HouseholdResidenceStatus {
  A_
  IDP
  REFUGEE
  OTHERS_OF_CONCERN
  HOST
  NON_HOST
}

type HouseholdSelection {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode!
  targetPopulation: TargetPopulationNode!
  vulnerabilityScore: Float
}

input HouseholdUpdateDataObjectType {
  adminAreaTitle: String
  status: String
  consent: Boolean
  consentSharing: [String]
  residenceStatus: String
  countryOrigin: String
  country: String
  size: Int
  address: String
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  returnee: Boolean
  fchildHoh: Boolean
  childHoh: Boolean
  start: DateTime
  end: DateTime
  nameEnumerator: String
  orgEnumerator: String
  orgNameEnumerator: String
  village: String
  registrationMethod: String
  collectIndividualData: String
  currency: String
  unhcrId: String
  flexFields: Arg
}

enum ImportDataDataType {
  XLSX
  JSON
  FLEX
  DIIA
}

type ImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ImportDataStatus!
  businessAreaSlug: String!
  file: String
  dataType: ImportDataDataType!
  numberOfHouseholds: Int
  numberOfIndividuals: Int
  error: String!
  validationErrors: String!
  createdById: UUID
  registrationDataImport: RegistrationDataImportDatahubNode
  koboimportdata: KoboImportDataNode
  xlsxValidationErrors: [XlsxRowErrorNode]
}

enum ImportDataStatus {
  PENDING
  RUNNING
  FINISHED
  ERROR
  VALIDATION_ERROR
}

type ImportXlsxCashPlanVerification {
  cashPlan: CashPlanNode
  errors: [XlsxErrorNode]
}

type ImportedDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  photo: String
  individual: ImportedIndividualNode!
  type: ImportedDocumentTypeNode!
  country: String
  docDate: Date
}

type ImportedDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedDocumentNodeEdge {
  node: ImportedDocumentNode
  cursor: String!
}

type ImportedDocumentTypeNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  type: ImportedDocumentTypeType!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection!
}

enum ImportedDocumentTypeType {
  BIRTH_CERTIFICATE
  DRIVERS_LICENSE
  ELECTORAL_CARD
  NATIONAL_ID
  NATIONAL_PASSPORT
  TAX_ID
  RESIDENCE_PERMIT_NO
  OTHER
}

enum ImportedHouseholdCollectIndividualData {
  A_
  A_2
  A_1
  A_0
}

enum ImportedHouseholdConsentSharing {
  A_
  GOVERNMENT_PARTNER
  HUMANITARIAN_PARTNER
  PRIVATE_PARTNER
  UNICEF
}

enum ImportedHouseholdCurrency {
  A_
  AED
  AFN
  ALL
  AMD
  ANG
  AOA
  ARS
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BHD
  BIF
  BMD
  BND
  BOB
  BOV
  BRL
  BSD
  BTN
  BWP
  BYN
  BZD
  CAD
  CDF
  CHF
  CLP
  CNY
  COP
  CRC
  CUC
  CUP
  CVE
  CZK
  DJF
  DKK
  DOP
  DZD
  EGP
  ERN
  ETB
  EUR
  FJD
  FKP
  GBP
  GEL
  GHS
  GIP
  GMD
  GNF
  GTQ
  GYD
  HKD
  HNL
  HRK
  HTG
  HUF
  IDR
  ILS
  INR
  IQD
  IRR
  ISK
  JMD
  JOD
  JPY
  KES
  KGS
  KHR
  KMF
  KPW
  KRW
  KWD
  KYD
  KZT
  LAK
  LBP
  LKR
  LRD
  LSL
  LYD
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRU
  MUR
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NIO
  NOK
  NPR
  NZD
  OMR
  PAB
  PEN
  PGK
  PHP
  PKR
  PLN
  PYG
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SDG
  SEK
  SGD
  SHP
  SLL
  SOS
  SRD
  SSP
  STN
  SVC
  SYP
  SZL
  THB
  TJS
  TMT
  TND
  TOP
  TRY
  TTD
  TWD
  TZS
  UAH
  UGX
  USD
  UYU
  UYW
  UZS
  VES
  VND
  VUV
  WST
  XAF
  XAG
  XAU
  XCD
  XOF
  XPF
  YER
  ZAR
  ZMW
  ZWL
}

type ImportedHouseholdNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  consentSign: String!
  consent: Boolean
  consentSharing: ImportedHouseholdConsentSharing!
  residenceStatus: ImportedHouseholdResidenceStatus!
  countryOrigin: String
  size: Int!
  address: String!
  country: String
  admin1: String!
  admin1Title: String!
  admin2: String!
  admin2Title: String!
  geopoint: GeoJSON
  femaleAgeGroup05Count: Int
  femaleAgeGroup611Count: Int
  femaleAgeGroup1217Count: Int
  femaleAgeGroup1859Count: Int
  femaleAgeGroup60Count: Int
  pregnantCount: Int
  maleAgeGroup05Count: Int
  maleAgeGroup611Count: Int
  maleAgeGroup1217Count: Int
  maleAgeGroup1859Count: Int
  maleAgeGroup60Count: Int
  femaleAgeGroup05DisabledCount: Int
  femaleAgeGroup611DisabledCount: Int
  femaleAgeGroup1217DisabledCount: Int
  femaleAgeGroup1859DisabledCount: Int
  femaleAgeGroup60DisabledCount: Int
  maleAgeGroup05DisabledCount: Int
  maleAgeGroup611DisabledCount: Int
  maleAgeGroup1217DisabledCount: Int
  maleAgeGroup1859DisabledCount: Int
  maleAgeGroup60DisabledCount: Int
  headOfHousehold: ImportedIndividualNode
  fchildHoh: Boolean
  childHoh: Boolean
  registrationDataImport: RegistrationDataImportDatahubNode!
  firstRegistrationDate: DateTime!
  lastRegistrationDate: DateTime!
  returnee: Boolean
  flexFields: Arg
  start: DateTime
  deviceid: String!
  nameEnumerator: String!
  orgEnumerator: ImportedHouseholdOrgEnumerator
  orgNameEnumerator: String!
  village: String!
  registrationMethod: ImportedHouseholdRegistrationMethod!
  collectIndividualData: ImportedHouseholdCollectIndividualData!
  currency: ImportedHouseholdCurrency!
  unhcrId: String!
  koboSubmissionUuid: UUID
  koboAssetId: String!
  koboSubmissionTime: DateTime
  rowId: Int
  diiaRecId: String!
  misUnicefId: String
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection!
  hasDuplicates: Boolean
  importId: String
}

type ImportedHouseholdNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedHouseholdNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedHouseholdNodeEdge {
  node: ImportedHouseholdNode
  cursor: String!
}

enum ImportedHouseholdOrgEnumerator {
  A_
  PARTNER
  UNICEF
}

enum ImportedHouseholdRegistrationMethod {
  A_
  COMMUNITY
  HH_REGISTRATION
}

enum ImportedHouseholdResidenceStatus {
  A_
  IDP
  REFUGEE
  OTHERS_OF_CONCERN
  HOST
  NON_HOST
}

enum ImportedIndividualDeduplicationBatchStatus {
  SIMILAR_IN_BATCH
  DUPLICATE_IN_BATCH
  UNIQUE_IN_BATCH
  NOT_PROCESSED
}

enum ImportedIndividualDeduplicationGoldenRecordStatus {
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
  POSTPONE
  UNIQUE
}

enum ImportedIndividualDisability {
  DISABLED
  NOT_DISABLED
}

type ImportedIndividualIdentityNode implements Node {
  id: ID!
  individual: ImportedIndividualNode!
  documentNumber: String!
  type: String
  country: String
}

type ImportedIndividualIdentityNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedIndividualIdentityNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedIndividualIdentityNodeEdge {
  node: ImportedIndividualIdentityNode
  cursor: String!
}

enum ImportedIndividualMaritalStatus {
  A_
  DIVORCED
  MARRIED
  SEPARATED
  SINGLE
  WIDOWED
}

type ImportedIndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individualId: String!
  photo: String!
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  relationship: String
  sex: ImportedIndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: ImportedIndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  household: ImportedHouseholdNode
  registrationDataImport: RegistrationDataImportDatahubNode!
  disability: ImportedIndividualDisability!
  workStatus: String!
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  deduplicationBatchStatus: ImportedIndividualDeduplicationBatchStatus
  deduplicationGoldenRecordStatus: ImportedIndividualDeduplicationGoldenRecordStatus
  deduplicationBatchResults: [DeduplicationResultNode]
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  flexFields: FlexFieldsScalar
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String!
  hearingDisability: String!
  physicalDisability: String!
  memoryDisability: String!
  selfcareDisability: String!
  commsDisability: String!
  whoAnswersPhone: String!
  whoAnswersAltPhone: String!
  koboAssetId: String!
  rowId: Int
  disabilityCertificatePicture: String
  misUnicefId: String
  importedhousehold: ImportedHouseholdNode
  documents(offset: Int, before: String, after: String, first: Int, last: Int): ImportedDocumentNodeConnection!
  identities(offset: Int, before: String, after: String, first: Int, last: Int): ImportedIndividualIdentityNodeConnection!
  role: String
  age: Int
  importId: String
  phoneNoValid: Boolean
  phoneNoAlternativeValid: Boolean
}

type ImportedIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [ImportedIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ImportedIndividualNodeEdge {
  node: ImportedIndividualNode
  cursor: String!
}

enum ImportedIndividualSex {
  MALE
  FEMALE
}

type IndividualDataChangeApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input IndividualDataUpdateIssueTypeExtras {
  individual: ID!
  individualData: IndividualUpdateDataObjectType!
}

enum IndividualDeduplicationBatchStatus {
  DUPLICATE_IN_BATCH
  NOT_PROCESSED
  SIMILAR_IN_BATCH
  UNIQUE_IN_BATCH
}

enum IndividualDeduplicationGoldenRecordStatus {
  DUPLICATE
  NEEDS_ADJUDICATION
  NOT_PROCESSED
  POSTPONE
  UNIQUE
}

input IndividualDeleteIssueTypeExtras {
  individual: ID!
}

enum IndividualDisability {
  DISABLED
  NOT_DISABLED
}

input IndividualDocumentObjectType {
  country: String!
  type: String!
  number: String!
  photo: Arg
  photoraw: Arg
}

type IndividualIdentityNode implements Node {
  id: ID!
  agency: AgencyNode!
  individual: IndividualNode!
  number: String!
  type: String
  country: String
}

type IndividualIdentityNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualIdentityNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualIdentityNodeEdge {
  node: IndividualIdentityNode
  cursor: String!
}

input IndividualIdentityObjectType {
  country: String!
  agency: String!
  number: String!
}

enum IndividualMaritalStatus {
  A_
  DIVORCED
  MARRIED
  SEPARATED
  SINGLE
  WIDOWED
}

type IndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isRemoved: Boolean!
  removedDate: DateTime
  lastSyncAt: DateTime
  version: BigInt!
  duplicate: Boolean!
  duplicateDate: DateTime
  withdrawn: Boolean!
  withdrawnDate: DateTime
  individualId: String!
  photo: String
  fullName: String!
  givenName: String!
  middleName: String!
  familyName: String!
  sex: IndividualSex!
  birthDate: Date!
  estimatedBirthDate: Boolean
  maritalStatus: IndividualMaritalStatus!
  phoneNo: String!
  phoneNoAlternative: String!
  relationship: IndividualRelationship
  household: HouseholdNode
  registrationDataImport: RegistrationDataImportNode
  disability: IndividualDisability!
  workStatus: String!
  firstRegistrationDate: Date!
  lastRegistrationDate: Date!
  flexFields: FlexFieldsScalar
  userFields: JSONString!
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  unicefId: String!
  deduplicationGoldenRecordStatus: IndividualDeduplicationGoldenRecordStatus!
  deduplicationBatchStatus: IndividualDeduplicationBatchStatus!
  deduplicationGoldenRecordResults: [DeduplicationResultNode]
  deduplicationBatchResults: [DeduplicationResultNode]
  importedIndividualId: UUID
  sanctionListPossibleMatch: Boolean!
  sanctionListConfirmedMatch: Boolean!
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String!
  hearingDisability: String!
  physicalDisability: String!
  memoryDisability: String!
  selfcareDisability: String!
  commsDisability: String!
  whoAnswersPhone: String!
  whoAnswersAltPhone: String!
  businessArea: UserBusinessAreaNode!
  fchildHoh: Boolean!
  childHoh: Boolean!
  koboAssetId: String!
  rowId: Int
  disabilityCertificatePicture: String
  paymentRecords(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
  individualDataUpdateTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketIndividualDataUpdateDetailsNodeConnection!
  deleteIndividualTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketDeleteIndividualDetailsNodeConnection!
  ticketsystemflaggingdetailsSet(offset: Int, before: String, after: String, first: Int, last: Int): TicketSystemFlaggingDetailsNodeConnection!
  ticketDuplicates(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  ticketSelected(offset: Int, before: String, after: String, first: Int, last: Int): TicketNeedsAdjudicationDetailsNodeConnection!
  positiveFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPositiveFeedbackDetailsNodeConnection!
  negativeFeedbackTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketNegativeFeedbackDetailsNodeConnection!
  referralTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketReferralDetailsNodeConnection!
  representedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  headingHousehold: HouseholdNode
  documents(offset: Int, before: String, after: String, first: Int, last: Int): DocumentNodeConnection!
  identities(offset: Int, before: String, after: String, first: Int, last: Int): IndividualIdentityNodeConnection!
  householdsAndRoles: [IndividualRoleInHouseholdNode!]!
  bankAccountInfo: BankAccountInfoNode
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  status: String
  role: String
  age: Int
  sanctionListLastCheck: DateTime
  phoneNoValid: Boolean
  phoneNoAlternativeValid: Boolean
  paymentChannels: [BankAccountInfoNode]
}

type IndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [IndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type IndividualNodeEdge {
  node: IndividualNode
  cursor: String!
}

enum IndividualRelationship {
  UNKNOWN
  AUNT_UNCLE
  BROTHER_SISTER
  COUSIN
  DAUGHTERINLAW_SONINLAW
  GRANDDAUGHER_GRANDSON
  GRANDMOTHER_GRANDFATHER
  HEAD
  MOTHER_FATHER
  MOTHERINLAW_FATHERINLAW
  NEPHEW_NIECE
  NON_BENEFICIARY
  OTHER
  SISTERINLAW_BROTHERINLAW
  SON_DAUGHTER
  WIFE_HUSBAND
}

type IndividualRoleInHouseholdNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  individual: IndividualNode!
  household: HouseholdNode!
  role: IndividualRoleInHouseholdRole
}

enum IndividualRoleInHouseholdRole {
  NO_ROLE
  ALTERNATE
  PRIMARY
}

enum IndividualSex {
  MALE
  FEMALE
}

input IndividualUpdateDataObjectType {
  status: String
  fullName: String
  givenName: String
  middleName: String
  familyName: String
  sex: String
  birthDate: Date
  estimatedBirthDate: Boolean
  maritalStatus: String
  phoneNo: String
  phoneNoAlternative: String
  relationship: String
  disability: String
  workStatus: String
  enrolledInNutritionProgramme: Boolean
  administrationOfRutf: Boolean
  pregnant: Boolean
  observedDisability: [String]
  seeingDisability: String
  hearingDisability: String
  physicalDisability: String
  memoryDisability: String
  selfcareDisability: String
  commsDisability: String
  whoAnswersPhone: String
  whoAnswersAltPhone: String
  role: String
  documents: [IndividualDocumentObjectType]
  documentsToRemove: [ID]
  documentsToEdit: [EditIndividualDocumentObjectType]
  identities: [IndividualIdentityObjectType]
  identitiesToRemove: [ID]
  identitiesToEdit: [EditIndividualIdentityObjectType]
  paymentChannels: [BankTransferObjectType]
  paymentChannelsToEdit: [EditBankTransferObjectType]
  paymentChannelsToRemove: [ID]
  flexFields: Arg
}

type InvalidCashPlanVerificationMutation {
  cashPlan: CashPlanNode
}

input IssueTypeExtrasInput {
  householdDataUpdateIssueTypeExtras: HouseholdDataUpdateIssueTypeExtras
  individualDataUpdateIssueTypeExtras: IndividualDataUpdateIssueTypeExtras
  individualDeleteIssueTypeExtras: IndividualDeleteIssueTypeExtras
  householdDeleteIssueTypeExtras: HouseholdDeleteIssueTypeExtras
  addIndividualIssueTypeExtras: AddIndividualIssueTypeExtras
}

type IssueTypesObject {
  category: String
  label: String
  subCategories: [ChoiceObject]
}

scalar JSONString

type KoboAssetObject {
  id: String
  name: String
  sector: String
  country: String
  assetType: String
  dateModified: DateTime
  deploymentActive: Boolean
  hasDeployment: Boolean
  xlsLink: String
}

type KoboAssetObjectConnection {
  pageInfo: PageInfo!
  edges: [KoboAssetObjectEdge]!
  totalCount: Int
}

type KoboAssetObjectEdge {
  node: KoboAssetObject
  cursor: String!
}

type KoboErrorNode {
  header: String
  message: String
}

type KoboImportDataNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: ImportDataStatus!
  businessAreaSlug: String!
  file: String
  dataType: ImportDataDataType!
  numberOfHouseholds: Int
  numberOfIndividuals: Int
  error: String!
  validationErrors: String!
  createdById: UUID
  importdataPtr: ImportDataNode!
  koboAssetId: String!
  onlyActiveSubmissions: Boolean!
  koboValidationErrors: [KoboErrorNode]
}

type LabelNode {
  language: String
  label: String
}

type LockTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

enum LogEntryAction {
  CREATE
  UPDATE
  DELETE
  SOFT_DELETE
}

type LogEntryNode implements Node {
  id: ID!
  contentType: ContentTypeObjectType
  objectId: UUID
  action: LogEntryAction!
  objectRepr: String!
  changes: Arg
  user: UserNode
  businessArea: UserBusinessAreaNode
  timestamp: DateTime
}

type LogEntryNodeConnection {
  pageInfo: PageInfo!
  edges: [LogEntryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type LogEntryNodeEdge {
  node: LogEntryNode
  cursor: String!
}

type MarkPaymentRecordAsFailedMutation {
  paymentRecord: PaymentRecordNode
}

type MergeRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

enum MessageSamplingType {
  FULL_LIST
  RANDOM
}

type Mutations {
  createAccountabilityCommunicationMessage(businessAreaSlug: String!, inputs: CreateAccountabilityCommunicationMessageInput!): CreateCommunicationMessageMutation
  createFeedback(input: CreateFeedbackInput!): CreateFeedbackMutation
  updateFeedback(input: UpdateFeedbackInput!): UpdateFeedbackMutation
  createFeedbackMessage(input: CreateFeedbackMessageInput!): CreateFeedbackMessageMutation
  createSurvey(input: CreateSurveyInput!): CreateSurveyMutation
  createReport(reportData: CreateReportInput!): CreateReport
  restartCreateReport(reportData: RestartCreateReportInput!): RestartCreateReport
  createDashboardReport(reportData: CreateDashboardReportInput!): CreateDashboardReport
  createGrievanceTicket(input: CreateGrievanceTicketInput!): CreateGrievanceTicketMutation
  updateGrievanceTicket(input: UpdateGrievanceTicketInput!, version: BigInt): UpdateGrievanceTicketMutation
  grievanceStatusChange(grievanceTicketId: ID, status: Int, version: BigInt): GrievanceStatusChangeMutation
  bulkUpdateGrievanceAssignee(assignedTo: String, businessAreaSlug: String!, grievanceTicketUnicefIds: [ID]): BulkUpdateGrievanceTicketsAssigneesMutation
  createTicketNote(noteInput: CreateTicketNoteInput!, version: BigInt): CreateTicketNoteMutation
  approveIndividualDataChange(approvedDocumentsToCreate: [Int], approvedDocumentsToEdit: [Int], approvedDocumentsToRemove: [Int], approvedIdentitiesToCreate: [Int], approvedIdentitiesToEdit: [Int], approvedIdentitiesToRemove: [Int], approvedPaymentChannelsToCreate: [Int], approvedPaymentChannelsToEdit: [Int], approvedPaymentChannelsToRemove: [Int], flexFieldsApproveData: JSONString, grievanceTicketId: ID!, individualApproveData: JSONString, version: BigInt): IndividualDataChangeApproveMutation
  approveHouseholdDataChange(flexFieldsApproveData: JSONString, grievanceTicketId: ID!, householdApproveData: JSONString, version: BigInt): HouseholdDataChangeApproveMutation
  approveAddIndividual(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveDeleteIndividual(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveDeleteHousehold(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveSystemFlagging(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): SimpleApproveMutation
  approveNeedsAdjudication(grievanceTicketId: ID!, selectedIndividualId: ID, selectedIndividualIds: [ID], version: BigInt): NeedsAdjudicationApproveMutation
  approvePaymentDetails(approveStatus: Boolean!, grievanceTicketId: ID!, version: BigInt): PaymentDetailsApproveMutation
  reassignRole(grievanceTicketId: ID!, householdId: ID!, householdVersion: BigInt, individualId: ID!, individualVersion: BigInt, newIndividualId: ID, role: String!, version: BigInt): ReassignRoleMutation
  createCashPlanPaymentVerification(input: CreatePaymentVerificationInput!): CreatePaymentVerificationMutation
  editCashPlanPaymentVerification(input: EditCashPlanPaymentVerificationInput!, version: BigInt): EditPaymentVerificationMutation
  exportXlsxCashPlanVerification(cashPlanVerificationId: ID!): ExportXlsxCashPlanVerification
  importXlsxCashPlanVerification(cashPlanVerificationId: ID!, file: Upload!): ImportXlsxCashPlanVerification
  activateCashPlanPaymentVerification(cashPlanVerificationId: ID!, version: BigInt): ActivateCashPlanVerificationMutation
  finishCashPlanPaymentVerification(cashPlanVerificationId: ID!, version: BigInt): FinishCashPlanVerificationMutation
  discardCashPlanPaymentVerification(cashPlanVerificationId: ID!, version: BigInt): DiscardCashPlanVerificationMutation
  invalidCashPlanPaymentVerification(cashPlanVerificationId: ID!, version: BigInt): InvalidCashPlanVerificationMutation
  deleteCashPlanPaymentVerification(cashPlanVerificationId: ID!, version: BigInt): DeleteCashPlanVerificationMutation
  updatePaymentVerificationStatusAndReceivedAmount(paymentVerificationId: ID!, receivedAmount: Decimal!, status: PaymentVerificationStatusForUpdate, version: BigInt): UpdatePaymentVerificationStatusAndReceivedAmount
  markPaymentRecordAsFailed(paymentRecordId: ID!): MarkPaymentRecordAsFailedMutation
  updatePaymentVerificationReceivedAndReceivedAmount(paymentVerificationId: ID!, received: Boolean!, receivedAmount: Decimal!, version: BigInt): UpdatePaymentVerificationReceivedAndReceivedAmount
  createTargetPopulation(input: CreateTargetPopulationInput!): CreateTargetPopulationMutation
  updateTargetPopulation(input: UpdateTargetPopulationInput!, version: BigInt): UpdateTargetPopulationMutation
  copyTargetPopulation(input: CopyTargetPopulationMutationInput!): CopyTargetPopulationMutationPayload
  deleteTargetPopulation(input: DeleteTargetPopulationMutationInput!): DeleteTargetPopulationMutationPayload
  lockTargetPopulation(id: ID!, version: BigInt): LockTargetPopulationMutation
  unlockTargetPopulation(id: ID!, version: BigInt): UnlockTargetPopulationMutation
  finalizeTargetPopulation(id: ID!, version: BigInt): FinalizeTargetPopulationMutation
  setSteficonRuleOnTargetPopulation(input: SetSteficonRuleOnTargetPopulationMutationInput!): SetSteficonRuleOnTargetPopulationMutationPayload
  targetPopulationRebuild(id: ID!): RebuildTargetPopulationMutation
  createProgram(programData: CreateProgramInput!): CreateProgram
  updateProgram(programData: UpdateProgramInput, version: BigInt): UpdateProgram
  deleteProgram(programId: String!): DeleteProgram
  uploadImportDataXlsxFileAsync(businessAreaSlug: String!, file: Upload!): UploadImportDataXLSXFileAsync
  deleteRegistrationDataImport(registrationDataImportId: String!): DeleteRegistrationDataImport
  registrationXlsxImport(registrationDataImportData: RegistrationXlsxImportMutationInput!): RegistrationXlsxImportMutation
  registrationKoboImport(registrationDataImportData: RegistrationKoboImportMutationInput!): RegistrationKoboImportMutation
  saveKoboImportDataAsync(businessAreaSlug: String!, onlyActiveSubmissions: Boolean!, uid: Upload!): SaveKoboProjectImportDataAsync
  mergeRegistrationDataImport(id: ID!, version: BigInt): MergeRegistrationDataImportMutation
  refuseRegistrationDataImport(id: ID!, version: BigInt): RefuseRegistrationDataImportMutation
  rerunDedupe(registrationDataImportDatahubId: ID!, version: BigInt): RegistrationDeduplicationMutation
  checkAgainstSanctionList(file: Upload!): CheckAgainstSanctionListMutation
}

type NeedsAdjudicationApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

input NegativeFeedbackTicketExtras {
  household: ID
  individual: ID
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PartnerType {
  id: ID!
  name: String!
  isUn: Boolean!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserNodeConnection!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
}

type PaymentDetailsApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

enum PaymentRecordDeliveryType {
  CARDLESS_CASH_WITHDRAWAL
  CASH
  CASH_BY_FSP
  CHEQUE
  DEPOSIT_TO_CARD
  IN_KIND
  MOBILE_MONEY
  OTHER
  PRE_PAID_CARD
  REFERRAL
  TRANSFER
  TRANSFER_TO_ACCOUNT
  VOUCHER
}

enum PaymentRecordEntitlementCardStatus {
  ACTIVE
  INACTIVE
}

type PaymentRecordNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  businessArea: UserBusinessAreaNode!
  status: PaymentRecordStatus!
  statusDate: DateTime!
  caId: String
  caHashId: UUID
  cashPlan: CashPlanNode
  household: HouseholdNode!
  headOfHousehold: IndividualNode
  fullName: String!
  totalPersonsCovered: Int!
  distributionModality: String!
  targetPopulation: TargetPopulationNode!
  targetPopulationCashAssistId: String!
  entitlementCardNumber: String
  entitlementCardStatus: PaymentRecordEntitlementCardStatus
  entitlementCardIssueDate: Date
  deliveryType: PaymentRecordDeliveryType!
  currency: String!
  entitlementQuantity: Float!
  deliveredQuantity: Float!
  deliveredQuantityUsd: Float
  deliveryDate: DateTime
  serviceProvider: ServiceProviderNode!
  transactionReferenceId: String
  visionId: String
  registrationCaId: String
  verification: PaymentVerificationNode
  complaintTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketComplaintDetailsNodeConnection!
  sensitiveTicketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketSensitiveDetailsNodeConnection!
}

type PaymentRecordNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentRecordNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentRecordNodeEdge {
  node: PaymentRecordNode
  cursor: String!
}

enum PaymentRecordStatus {
  DISTRIBUTION_SUCCESSFUL
  NOT_DISTRIBUTED
  TRANSACTION_SUCCESSFUL
  TRANSACTION_ERRONEOUS
  FORCE_FAILED
}

type PaymentVerificationLogEntryNode implements Node {
  id: ID!
  contentType: ContentTypeObjectType
  objectId: UUID
  action: LogEntryAction!
  objectRepr: String!
  changes: Arg
  user: UserNode
  businessArea: UserBusinessAreaNode
  timestamp: DateTime
  contentObject: CashPlanPaymentVerificationNode
}

type PaymentVerificationLogEntryNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationLogEntryNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationLogEntryNodeEdge {
  node: PaymentVerificationLogEntryNode
  cursor: String!
}

type PaymentVerificationNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  cashPlanPaymentVerification: CashPlanPaymentVerificationNode!
  paymentRecord: PaymentRecordNode
  status: PaymentVerificationStatus!
  statusDate: DateTime
  receivedAmount: Float
  sentToRapidPro: Boolean!
  ticketDetails(offset: Int, before: String, after: String, first: Int, last: Int): TicketPaymentVerificationDetailsNodeConnection!
  ticketDetail(offset: Int, before: String, after: String, first: Int, last: Int): TicketPaymentVerificationDetailsNodeConnection!
  isManuallyEditable: Boolean
}

type PaymentVerificationNodeConnection {
  pageInfo: PageInfo!
  edges: [PaymentVerificationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type PaymentVerificationNodeEdge {
  node: PaymentVerificationNode
  cursor: String!
}

enum PaymentVerificationStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

enum PaymentVerificationStatusForUpdate {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

input PositiveFeedbackTicketExtras {
  household: ID
  individual: ID
}

enum ProgramFrequencyOfPayments {
  ONE_OFF
  REGULAR
}

type ProgramNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSyncAt: DateTime
  version: BigInt!
  name: String!
  status: ProgramStatus!
  startDate: Date!
  endDate: Date!
  description: String!
  caId: String
  caHashId: String
  adminAreas(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection!
  businessArea: UserBusinessAreaNode!
  budget: Decimal
  frequencyOfPayments: ProgramFrequencyOfPayments!
  sector: ProgramSector!
  scope: ProgramScope!
  cashPlus: Boolean!
  populationGoal: Int!
  administrativeAreasOfImplementation: String!
  individualDataNeeded: Boolean
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  cashPlans(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  targetpopulationSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  totalEntitledQuantity: Decimal
  totalDeliveredQuantity: Decimal
  totalUndeliveredQuantity: Decimal
  totalNumberOfHouseholds: Int
}

type ProgramNodeConnection {
  pageInfo: PageInfo!
  edges: [ProgramNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ProgramNodeEdge {
  node: ProgramNode
  cursor: String!
}

enum ProgramScope {
  FOR_PARTNERS
  UNICEF
}

enum ProgramSector {
  CHILD_PROTECTION
  EDUCATION
  HEALTH
  MULTI_PURPOSE
  NUTRITION
  SOCIAL_POLICY
  WASH
}

enum ProgramStatus {
  ACTIVE
  DRAFT
  FINISHED
}

type ProgramsWithDeliveredQuantityNode {
  id: ID
  name: String
  quantity: [DeliveredQuantityNode]
}

type Query {
  accountabilityCommunicationMessage(id: ID!): CommunicationMessageNode
  allAccountabilityCommunicationMessages(offset: Int, before: String, after: String, first: Int, last: Int, numberOfRecipients: Int, numberOfRecipients_Gte: Int, numberOfRecipients_Lte: Int, targetPopulation: ID, createdBy: ID, businessArea: String!, program: String, createdAtRange: String, title: String, body: String, samplingType: String, orderBy: String): CommunicationMessageNodeConnection
  accountabilityCommunicationMessageRecipient(id: ID!): CommunicationMessageRecipientMapNode
  allAccountabilityCommunicationMessageRecipients(offset: Int, before: String, after: String, first: Int, last: Int, messageId: String!, recipientId: String, fullName: String, phoneNo: String, sex: String, orderBy: String): CommunicationMessageRecipientMapNodeConnection
  accountabilityCommunicationMessageSampleSize(businessAreaSlug: String!, inputs: GetAccountabilityCommunicationMessageSampleSizeInput): GetCommunicationMessageSampleSizeObject
  feedback(id: ID!): FeedbackNode
  allFeedbacks(offset: Int, before: String, after: String, first: Int, last: Int, businessAreaSlug: String!, issueType: String, createdAtRange: String, createdBy: String, feedbackId: String, orderBy: String): FeedbackNodeConnection
  feedbackIssueTypeChoices: [ChoiceObject]
  survey(id: ID!): SurveyNode
  allSurveys(offset: Int, before: String, after: String, first: Int, last: Int, program: ID, targetPopulation: ID, createdBy: ID, createdAtRange: String, search: String, orderBy: String): SurveyNodeConnection
  recipients(offset: Int, before: String, after: String, first: Int, last: Int, survey: String!, orderBy: String): RecipientNodeConnection
  adminArea(id: ID!): AreaNode
  allAdminAreas(offset: Int, before: String, after: String, first: Int, last: Int, name: String, name_Istartswith: String, businessArea: String, level: Int): AreaNodeConnection
  allLogEntries(offset: Int, before: String, after: String, first: Int, last: Int, objectId: UUID, businessArea: String!, search: String, module: String): LogEntryNodeConnection
  logEntryActionChoices: [ChoiceObject]
  report(id: ID!): ReportNode
  allReports(offset: Int, before: String, after: String, first: Int, last: Int, createdBy: ID, reportType: [String], status: [String], businessArea: String!, createdFrom: DateTime, createdTo: DateTime, orderBy: String): ReportNodeConnection
  reportTypesChoices: [ChoiceObject]
  reportStatusChoices: [ChoiceObject]
  dashboardReportTypesChoices(businessAreaSlug: String!): [ChoiceObject]
  dashboardYearsChoices(businessAreaSlug: String!): [String]
  sanctionListIndividual(id: ID!): SanctionListIndividualNode
  allSanctionListIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, fullName: String, fullName_Startswith: String, referenceNumber: String, orderBy: String): SanctionListIndividualNodeConnection
  ticketsByType(businessAreaSlug: String!): TicketByType
  ticketsByCategory(businessAreaSlug: String!): ChartDatasetNode
  ticketsByStatus(businessAreaSlug: String!): ChartDatasetNode
  ticketsByLocationAndCategory(businessAreaSlug: String!): ChartDetailedDatasetsNode
  grievanceTicket(id: ID!): GrievanceTicketNode
  allGrievanceTicket(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, id_Startswith: UUID, category: String, area: String, area_Startswith: String, assignedTo: ID, registrationDataImport: ID, businessArea: String!, search: String, status: [String], fsp: String, admin: [ID], cashPlan: String, createdAtRange: String, permissions: [String], issueType: String, scoreMin: String, scoreMax: String, household: String, priority: String, urgency: String, grievanceType: String, grievanceStatus: String, totalDays: Int, orderBy: String): GrievanceTicketNodeConnection
  existingGrievanceTickets(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, businessArea: String!, category: String, issueType: String, household: ID, individual: ID, paymentRecord: [ID], permissions: [String], orderBy: String): GrievanceTicketNodeConnection
  allTicketNotes(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, ticket: UUID!): TicketNoteNodeConnection
  chartGrievances(businessAreaSlug: String!, year: Int!, administrativeArea: String): ChartGrievanceTicketsNode
  allAddIndividualsFieldsAttributes: [FieldAttributeNode]
  allEditHouseholdFieldsAttributes: [FieldAttributeNode]
  grievanceTicketStatusChoices: [ChoiceObject]
  grievanceTicketCategoryChoices: [ChoiceObject]
  grievanceTicketManualCategoryChoices: [ChoiceObject]
  grievanceTicketSystemCategoryChoices: [ChoiceObject]
  grievanceTicketIssueTypeChoices: [IssueTypesObject]
  grievanceTicketPriorityChoices: [ChoiceObjectInt]
  grievanceTicketUrgencyChoices: [ChoiceObjectInt]
  allSteficonRules(offset: Int, before: String, after: String, first: Int, last: Int, enabled: Boolean, deprecated: Boolean): SteficonRuleNodeConnection
  paymentRecord(id: ID!): PaymentRecordNode
  paymentRecordVerification(id: ID!): PaymentVerificationNode
  cashPlanPaymentVerification(id: ID!): CashPlanPaymentVerificationNode
  allPaymentRecords(offset: Int, before: String, after: String, first: Int, last: Int, cashPlan: ID, household: ID, individual: String, businessArea: String, orderBy: String): PaymentRecordNodeConnection
  allPaymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int, cashPlanPaymentVerification: ID, cashPlanPaymentVerification_CashPlan: ID, status: String, search: String, businessArea: String, verificationChannel: String, orderBy: String): PaymentVerificationNodeConnection
  allCashPlanPaymentVerification(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanPaymentVerificationNodeConnection
  chartPaymentVerification(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartPaymentVerification
  chartVolumeByDeliveryMechanism(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartPayment(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  sectionTotalTransferred(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  tableTotalCashTransferredByAdministrativeArea(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String, order: String, orderBy: String): TableTotalCashTransferred
  chartTotalTransferredCashByCountry(year: Int!): ChartDetailedDatasetsNode
  paymentRecordStatusChoices: [ChoiceObject]
  paymentRecordEntitlementCardStatusChoices: [ChoiceObject]
  paymentRecordDeliveryTypeChoices: [ChoiceObject]
  cashPlanVerificationStatusChoices: [ChoiceObject]
  cashPlanVerificationSamplingChoices: [ChoiceObject]
  cashPlanVerificationVerificationChannelChoices: [ChoiceObject]
  paymentVerificationStatusChoices: [ChoiceObject]
  allRapidProFlows(businessAreaSlug: String!): [RapidProFlow]
  sampleSize(input: GetCashplanVerificationSampleSizeInput): GetCashplanVerificationSampleSizeObject
  allPaymentVerificationLogEntries(offset: Int, before: String, after: String, first: Int, last: Int, objectId: UUID, businessArea: String!, search: String, module: String): PaymentVerificationLogEntryNodeConnection
  businessArea(businessAreaSlug: String!): BusinessAreaNode
  allBusinessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID, slug: String): BusinessAreaNodeConnection
  allFieldsAttributes(flexField: Boolean, businessAreaSlug: String): [FieldAttributeNode]
  allGroupsWithFields: [GroupAttributeNode]
  koboProject(uid: String!, businessAreaSlug: String!): KoboAssetObject
  allKoboProjects(businessAreaSlug: String!, onlyDeployed: Boolean, before: String, after: String, first: Int, last: Int): KoboAssetObjectConnection
  cashAssistUrlPrefix: String
  program(id: ID!): ProgramNode
  allPrograms(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String!, search: String, status: [String], sector: [String], numberOfHouseholds: String, budget: String, startDate: Date, endDate: Date, orderBy: String): ProgramNodeConnection
  chartProgrammesBySector(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  chartTotalTransferredByMonth(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  cashPlan(id: ID!): CashPlanNode
  allCashPlans(offset: Int, before: String, after: String, first: Int, last: Int, program: ID, assistanceThrough: String, assistanceThrough_Startswith: String, serviceProvider_FullName: String, serviceProvider_FullName_Startswith: String, startDate: DateTime, startDate_Lte: DateTime, startDate_Gte: DateTime, endDate: DateTime, endDate_Lte: DateTime, endDate_Gte: DateTime, businessArea: String, search: String, deliveryType: [String], verificationStatus: [String], orderBy: String): CashPlanNodeConnection
  programStatusChoices: [ChoiceObject]
  programFrequencyOfPaymentsChoices: [ChoiceObject]
  programSectorChoices: [ChoiceObject]
  programScopeChoices: [ChoiceObject]
  cashPlanStatusChoices: [ChoiceObject]
  targetPopulation(id: ID!): TargetPopulationNode
  allTargetPopulation(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection
  goldenRecordByTargetingCriteria(targetingCriteria: TargetingCriteriaObjectType!, program: ID!, excludedIds: String!, offset: Int, before: String, after: String, first: Int, last: Int, orderBy: String, businessArea: String): HouseholdNodeConnection
  targetPopulationHouseholds(targetPopulation: ID!, offset: Int, before: String, after: String, first: Int, last: Int, orderBy: String, businessArea: String): HouseholdNodeConnection
  targetPopulationStatusChoices: [ChoiceObject]
  household(id: ID!): HouseholdNode
  allHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, businessArea: String, address: String, address_Startswith: String, headOfHousehold_FullName: String, headOfHousehold_FullName_Startswith: String, size_Range: [Int], size_Lte: Int, size_Gte: Int, adminArea: ID, targetPopulations: [ID], programs: [ID], residenceStatus: String, withdrawn: Boolean, size: String, search: String, lastRegistrationDate: String, admin2: [ID], countryOrigin: String, orderBy: String): HouseholdNodeConnection
  individual(id: ID!): IndividualNode
  allIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household_Id: UUID, businessArea: String, fullName: String, fullName_Startswith: String, fullName_Endswith: String, sex: [String], household_AdminArea: ID, withdrawn: Boolean, age: String, programs: [ID], search: String, lastRegistrationDate: String, admin2: [ID], status: [String], excludedId: String, flags: [String], orderBy: String): IndividualNodeConnection
  sectionHouseholdsReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionIndividualsReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  sectionChildReached(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): SectionTotalNode
  chartIndividualsReachedByAgeAndGender(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDatasetNode
  chartIndividualsWithDisabilityReachedByAge(businessAreaSlug: String!, year: Int!, program: String, administrativeArea: String): ChartDetailedDatasetsNode
  residenceStatusChoices: [ChoiceObject]
  sexChoices: [ChoiceObject]
  maritalStatusChoices: [ChoiceObject]
  workStatusChoices: [ChoiceObject]
  relationshipChoices: [ChoiceObject]
  roleChoices: [ChoiceObject]
  documentTypeChoices: [ChoiceObject]
  identityTypeChoices: [ChoiceObject]
  countriesChoices: [ChoiceObject]
  observedDisabilityChoices: [ChoiceObject]
  severityOfDisabilityChoices: [ChoiceObject]
  flagChoices: [ChoiceObject]
  allHouseholdsFlexFieldsAttributes: [FieldAttributeNode]
  allIndividualsFlexFieldsAttributes: [FieldAttributeNode]
  me: UserNode
  allUsers(offset: Int, before: String, after: String, first: Int, last: Int, status: [String], partner: [String], businessArea: String!, search: String, roles: [String], orderBy: String): UserNodeConnection
  userRolesChoices: [ChoiceObject]
  userStatusChoices: [ChoiceObject]
  userPartnerChoices: [ChoiceObject]
  hasAvailableUsersToExport(businessAreaSlug: String!): Boolean
  importedHousehold(id: ID!): ImportedHouseholdNode
  allImportedHouseholds(offset: Int, before: String, after: String, first: Int, last: Int, rdiId: String, businessArea: String, orderBy: String): ImportedHouseholdNodeConnection
  registrationDataImportDatahub(id: ID!): RegistrationDataImportDatahubNode
  allRegistrationDataImportsDatahub(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportDatahubNodeConnection
  importedIndividual(id: ID!): ImportedIndividualNode
  allImportedIndividuals(offset: Int, before: String, after: String, first: Int, last: Int, household: ID, rdiId: String, duplicatesOnly: Boolean, businessArea: String, orderBy: String): ImportedIndividualNodeConnection
  importData(id: ID!): ImportDataNode
  koboImportData(id: ID!): KoboImportDataNode
  deduplicationBatchStatusChoices: [ChoiceObject]
  deduplicationGoldenRecordStatusChoices: [ChoiceObject]
  registrationDataImport(id: ID!): RegistrationDataImportNode
  allRegistrationDataImports(offset: Int, before: String, after: String, first: Int, last: Int, importedBy_Id: UUID, importDate: Date, status: String, name: String, name_Startswith: String, businessArea: String, importDateRange: String, size: String, orderBy: String): RegistrationDataImportNodeConnection
  registrationDataStatusChoices: [ChoiceObject]
  _debug: DjangoDebug
}

input RandomSamplingArguments {
  confidenceInterval: Float!
  marginOfError: Float!
  excludedAdminAreas: [String]
  age: AgeInput
  sex: String
}

input RapidProArguments {
  flowId: String!
}

type RapidProFlow {
  id: String
  name: String
  type: String
  archived: Boolean
  labels: [String]
  expires: Int
  runs: [RapidProFlowRun]
  results: [RapidProFlowResult]
  createdOn: DateTime
  modifiedOn: DateTime
}

type RapidProFlowResult {
  key: String
  name: String
  categories: [String]
  nodeUuids: [String]
}

type RapidProFlowRun {
  active: Int
  completed: Int
  interrupted: Int
  expired: Int
}

type ReassignRoleMutation {
  household: HouseholdNode
  individual: IndividualNode
}

type RebuildTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

type RecipientNode implements Node {
  id: ID!
  size: Int
  headOfHousehold: IndividualNode!
}

type RecipientNodeConnection {
  pageInfo: PageInfo!
  edges: [RecipientNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RecipientNodeEdge {
  node: RecipientNode
  cursor: String!
}

input ReferralTicketExtras {
  household: ID
  individual: ID
}

type RefuseRegistrationDataImportMutation {
  registrationDataImport: RegistrationDataImportNode
}

enum RegistrationDataImportDataSource {
  XLS
  KOBO
  DIIA
  FLEX_REGISTRATION
  API
}

enum RegistrationDataImportDatahubImportDone {
  LOADING
  NOT_STARTED
  STARTED
  DONE
}

type RegistrationDataImportDatahubNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  importDate: DateTime!
  hctId: UUID
  importData: ImportDataNode
  importDone: RegistrationDataImportDatahubImportDone!
  businessAreaSlug: String!
  households(offset: Int, before: String, after: String, first: Int, last: Int): ImportedHouseholdNodeConnection!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): ImportedIndividualNodeConnection!
}

type RegistrationDataImportDatahubNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportDatahubNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportDatahubNodeEdge {
  node: RegistrationDataImportDatahubNode
  cursor: String!
}

type RegistrationDataImportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  name: String!
  status: RegistrationDataImportStatus!
  importDate: DateTime!
  importedBy: UserNode
  dataSource: RegistrationDataImportDataSource!
  numberOfIndividuals: Int!
  numberOfHouseholds: Int!
  datahubId: UUID
  errorMessage: String!
  sentryId: String
  pullPictures: Boolean!
  businessArea: UserBusinessAreaNode
  screenBeneficiary: Boolean!
  grievanceticketSet(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individuals(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  batchDuplicatesCountAndPercentage: CountAndPercentageNode
  goldenRecordDuplicatesCountAndPercentage: CountAndPercentageNode
  batchPossibleDuplicatesCountAndPercentage: CountAndPercentageNode
  goldenRecordPossibleDuplicatesCountAndPercentage: CountAndPercentageNode
  batchUniqueCountAndPercentage: CountAndPercentageNode
  goldenRecordUniqueCountAndPercentage: CountAndPercentageNode
}

type RegistrationDataImportNodeConnection {
  pageInfo: PageInfo!
  edges: [RegistrationDataImportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RegistrationDataImportNodeEdge {
  node: RegistrationDataImportNode
  cursor: String!
}

enum RegistrationDataImportStatus {
  LOADING
  DEDUPLICATION
  DEDUPLICATION_FAILED
  IMPORTING
  IMPORT_ERROR
  IN_REVIEW
  MERGED
  MERGING
  MERGE_ERROR
  REFUSED
}

type RegistrationDeduplicationMutation {
  ok: Boolean
}

type RegistrationKoboImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationKoboImportMutationInput {
  importDataId: String
  name: String
  pullPictures: Boolean
  businessAreaSlug: String
  screenBeneficiary: Boolean
}

type RegistrationXlsxImportMutation {
  validationErrors: Arg
  registrationDataImport: RegistrationDataImportNode
}

input RegistrationXlsxImportMutationInput {
  importDataId: ID
  name: String
  businessAreaSlug: String
  screenBeneficiary: Boolean
}

type ReportNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  file: String
  createdBy: UserNode!
  status: Int!
  reportType: Int!
  dateFrom: Date!
  dateTo: Date!
  numberOfRecords: Int
  program: ProgramNode
  adminArea(offset: Int, before: String, after: String, first: Int, last: Int, name: String): AreaNodeConnection
  fileUrl: String
}

type ReportNodeConnection {
  pageInfo: PageInfo!
  edges: [ReportNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ReportNodeEdge {
  node: ReportNode
  cursor: String!
}

type RestartCreateReport {
  report: ReportNode
}

input RestartCreateReportInput {
  reportId: ID!
  businessAreaSlug: String!
}

type RoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  subsystem: RoleSubsystem!
  permissions: [String!]
  userRoles: [UserRoleNode!]!
}

enum RoleSubsystem {
  HOPE
  KOBO
  CA
  API
}

enum RuleCommitLanguage {
  PYTHON
}

type RuleCommitNode implements Node {
  id: ID!
  timestamp: DateTime!
  rule: SteficonRuleNode
  updatedBy: UserNode
  definition: String!
  isRelease: Boolean!
  enabled: Boolean!
  deprecated: Boolean!
  language: RuleCommitLanguage!
  affectedFields: [String!]!
  before: JSONString!
  after: JSONString!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
}

type RuleCommitNodeConnection {
  pageInfo: PageInfo!
  edges: [RuleCommitNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type RuleCommitNodeEdge {
  node: RuleCommitNode
  cursor: String!
}

enum RuleLanguage {
  PYTHON
}

enum RuleSecurity {
  A_0
  A_2
  A_4
}

enum SamplingChoices {
  FULL_LIST
  RANDOM
}

type SanctionListIndividualAliasNameNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type SanctionListIndividualAliasNameNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualAliasNameNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualAliasNameNodeEdge {
  node: SanctionListIndividualAliasNameNode
  cursor: String!
}

type SanctionListIndividualCountriesNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  country: String
}

type SanctionListIndividualCountriesNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualCountriesNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualCountriesNodeEdge {
  node: SanctionListIndividualCountriesNode
  cursor: String!
}

type SanctionListIndividualDateOfBirthNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  date: Date!
}

type SanctionListIndividualDateOfBirthNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualDateOfBirthNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualDateOfBirthNodeEdge {
  node: SanctionListIndividualDateOfBirthNode
  cursor: String!
}

type SanctionListIndividualDocumentNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  documentNumber: String!
  typeOfDocument: String!
  dateOfIssue: String
  issuingCountry: String
  note: String!
}

type SanctionListIndividualDocumentNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualDocumentNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualDocumentNodeEdge {
  node: SanctionListIndividualDocumentNode
  cursor: String!
}

type SanctionListIndividualNationalitiesNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  nationality: String
}

type SanctionListIndividualNationalitiesNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualNationalitiesNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualNationalitiesNodeEdge {
  node: SanctionListIndividualNationalitiesNode
  cursor: String!
}

type SanctionListIndividualNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  dataId: Int!
  versionNum: Int!
  firstName: String!
  secondName: String!
  thirdName: String!
  fourthName: String!
  fullName: String!
  nameOriginalScript: String!
  unListType: String!
  referenceNumber: String!
  listedOn: DateTime!
  comments: String!
  designation: String!
  listType: String!
  street: String!
  city: String!
  stateProvince: String!
  addressNote: String!
  countryOfBirth: String
  active: Boolean!
  documents(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualDocumentNodeConnection!
  nationalities(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualNationalitiesNodeConnection!
  countries(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualCountriesNodeConnection!
  aliasNames(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualAliasNameNodeConnection!
  datesOfBirth(offset: Int, before: String, after: String, first: Int, last: Int): SanctionListIndividualDateOfBirthNodeConnection!
}

type SanctionListIndividualNodeConnection {
  pageInfo: PageInfo!
  edges: [SanctionListIndividualNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SanctionListIndividualNodeEdge {
  node: SanctionListIndividualNode
  cursor: String!
}

type SaveKoboProjectImportDataAsync {
  importData: KoboImportDataNode
}

type SectionTotalNode {
  total: Float
}

input SensitiveGrievanceTicketExtras {
  household: ID
  individual: ID
}

type ServiceProviderNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  caId: String!
  fullName: String
  shortName: String
  country: String!
  visionId: String
  paymentRecords(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  cashPlans(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
}

type ServiceProviderNodeConnection {
  pageInfo: PageInfo!
  edges: [ServiceProviderNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type ServiceProviderNodeEdge {
  node: ServiceProviderNode
  cursor: String!
}

input SetSteficonRuleOnTargetPopulationMutationInput {
  targetId: ID!
  steficonRuleId: ID
  version: BigInt
  clientMutationId: String
}

type SetSteficonRuleOnTargetPopulationMutationPayload {
  targetPopulation: TargetPopulationNode
  clientMutationId: String
}

type SimpleApproveMutation {
  grievanceTicket: GrievanceTicketNode
}

type SteficonRuleNode implements Node {
  id: ID!
  name: String!
  definition: String!
  description: String
  enabled: Boolean!
  deprecated: Boolean!
  language: RuleLanguage!
  security: RuleSecurity!
  createdBy: UserNode
  updatedBy: UserNode
  createdAt: DateTime!
  updatedAt: DateTime!
  flags: JSONString!
  history(offset: Int, before: String, after: String, first: Int, last: Int): RuleCommitNodeConnection!
}

type SteficonRuleNodeConnection {
  pageInfo: PageInfo!
  edges: [SteficonRuleNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SteficonRuleNodeEdge {
  node: SteficonRuleNode
  cursor: String!
}

enum SurveyCategory {
  RAPID_PRO
  SMS
  MANUAL
}

type SurveyNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  unicefId: String
  title: String!
  body: String
  category: SurveyCategory!
  numberOfRecipients: Int!
  createdBy: UserNode
  recipients(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  targetPopulation: TargetPopulationNode
  program: ProgramNode
  businessArea: UserBusinessAreaNode!
  samplingType: SurveySamplingType!
  fullListArguments: JSONString
  randomSamplingArguments: JSONString
  sampleSize: Int!
}

type SurveyNodeConnection {
  pageInfo: PageInfo!
  edges: [SurveyNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type SurveyNodeEdge {
  node: SurveyNode
  cursor: String!
}

enum SurveySamplingType {
  FULL_LIST
  RANDOM
}

type TableTotalCashTransferred {
  data: [_TableTotalCashTransferredDataNode]
}

enum TargetPopulationBuildStatus {
  PENDING
  BUILDING
  FAILED
  OK
}

type TargetPopulationNode implements Node {
  isRemoved: Boolean!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: BigInt!
  name: String!
  caId: String
  caHashId: String
  createdBy: UserNode
  changeDate: DateTime
  changedBy: UserNode
  finalizedAt: DateTime
  finalizedBy: UserNode
  businessArea: UserBusinessAreaNode
  status: TargetPopulationStatus!
  buildStatus: TargetPopulationBuildStatus!
  builtAt: DateTime
  households(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  program: ProgramNode
  targetingCriteria: TargetingCriteriaNode
  sentToDatahub: Boolean!
  steficonRule: RuleCommitNode
  steficonAppliedDate: DateTime
  vulnerabilityScoreMin: Float
  vulnerabilityScoreMax: Float
  excludedIds: String!
  exclusionReason: String!
  totalHouseholdsCount: Int
  totalIndividualsCount: Int
  childMaleCount: Int
  childFemaleCount: Int
  adultMaleCount: Int
  adultFemaleCount: Int
  paymentRecords(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  selections: [HouseholdSelection!]!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  totalFamilySize: Int
  householdList(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection
}

type TargetPopulationNodeConnection {
  pageInfo: PageInfo!
  edges: [TargetPopulationNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TargetPopulationNodeEdge {
  node: TargetPopulationNode
  cursor: String!
}

enum TargetPopulationStatus {
  OPEN
  LOCKED
  STEFICON_WAIT
  STEFICON_RUN
  STEFICON_COMPLETED
  STEFICON_ERROR
  PROCESSING
  READY_FOR_CASH_ASSIST
}

type TargetingCriteriaNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetPopulation: TargetPopulationNode
  rules: [TargetingCriteriaRuleNode]
}

input TargetingCriteriaObjectType {
  rules: [TargetingCriteriaRuleObjectType]
}

enum TargetingCriteriaRuleFilterComparisonMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
}

type TargetingCriteriaRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisonMethod: TargetingCriteriaRuleFilterComparisonMethod!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]
  fieldAttribute: FieldAttributeNode
}

input TargetingCriteriaRuleFilterObjectType {
  comparisonMethod: String!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]!
}

type TargetingCriteriaRuleNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteria: TargetingCriteriaNode!
  individualsFiltersBlocks: [TargetingIndividualRuleFilterBlockNode]
  filters: [TargetingCriteriaRuleFilterNode]
}

input TargetingCriteriaRuleObjectType {
  filters: [TargetingCriteriaRuleFilterObjectType]
  individualsFiltersBlocks: [TargetingIndividualRuleFilterBlockObjectType]
}

enum TargetingIndividualBlockRuleFilterComparisonMethod {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  RANGE
  NOT_IN_RANGE
  GREATER_THAN
  LESS_THAN
}

type TargetingIndividualBlockRuleFilterNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  comparisonMethod: TargetingIndividualBlockRuleFilterComparisonMethod!
  individualsFiltersBlock: TargetingIndividualRuleFilterBlockNode!
  isFlexField: Boolean!
  fieldName: String!
  arguments: [Arg]
  fieldAttribute: FieldAttributeNode
}

type TargetingIndividualRuleFilterBlockNode {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  targetingCriteriaRule: TargetingCriteriaRuleNode!
  targetOnlyHoh: Boolean!
  individualBlockFilters: [TargetingIndividualBlockRuleFilterNode]
}

input TargetingIndividualRuleFilterBlockObjectType {
  individualBlockFilters: [TargetingCriteriaRuleFilterObjectType]
}

type TicketAddIndividualDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individualData: Arg
  approveStatus: Boolean!
}

type TicketAddIndividualDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketAddIndividualDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketAddIndividualDetailsNodeEdge {
  node: TicketAddIndividualDetailsNode
  cursor: String!
}

type TicketByType {
  userGeneratedCount: Int
  systemGeneratedCount: Int
  closedUserGeneratedCount: Int
  closedSystemGeneratedCount: Int
  userGeneratedAvgResolution: Float
  systemGeneratedAvgResolution: Float
}

type TicketComplaintDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentRecord: PaymentRecordNode
  household: HouseholdNode
  individual: IndividualNode
}

type TicketComplaintDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketComplaintDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketComplaintDetailsNodeEdge {
  node: TicketComplaintDetailsNode
  cursor: String!
}

type TicketDeleteHouseholdDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  roleReassignData: JSONString!
  approveStatus: Boolean!
  householdData: Arg
}

type TicketDeleteHouseholdDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketDeleteHouseholdDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketDeleteHouseholdDetailsNodeEdge {
  node: TicketDeleteHouseholdDetailsNode
  cursor: String!
}

type TicketDeleteIndividualDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode
  roleReassignData: JSONString!
  approveStatus: Boolean!
  individualData: Arg
}

type TicketDeleteIndividualDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketDeleteIndividualDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketDeleteIndividualDetailsNodeEdge {
  node: TicketDeleteIndividualDetailsNode
  cursor: String!
}

type TicketHouseholdDataUpdateDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  householdData: Arg
}

type TicketHouseholdDataUpdateDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketHouseholdDataUpdateDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketHouseholdDataUpdateDetailsNodeEdge {
  node: TicketHouseholdDataUpdateDetailsNode
  cursor: String!
}

type TicketIndividualDataUpdateDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  individual: IndividualNode
  individualData: Arg
  roleReassignData: JSONString!
}

type TicketIndividualDataUpdateDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketIndividualDataUpdateDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketIndividualDataUpdateDetailsNodeEdge {
  node: TicketIndividualDataUpdateDetailsNode
  cursor: String!
}

type TicketNeedsAdjudicationDetailsExtraDataNode {
  goldenRecords: [DeduplicationResultNode]
  possibleDuplicate: [DeduplicationResultNode]
}

type TicketNeedsAdjudicationDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  goldenRecordsIndividual: IndividualNode!
  isMultipleDuplicatesVersion: Boolean!
  possibleDuplicate: IndividualNode
  possibleDuplicates: [IndividualNode]
  selectedIndividual: IndividualNode
  selectedIndividuals: [IndividualNode]
  roleReassignData: JSONString!
  extraData: TicketNeedsAdjudicationDetailsExtraDataNode
  scoreMin: Float!
  scoreMax: Float!
  hasDuplicatedDocument: Boolean
}

type TicketNeedsAdjudicationDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNeedsAdjudicationDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNeedsAdjudicationDetailsNodeEdge {
  node: TicketNeedsAdjudicationDetailsNode
  cursor: String!
}

type TicketNegativeFeedbackDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketNegativeFeedbackDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNegativeFeedbackDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNegativeFeedbackDetailsNodeEdge {
  node: TicketNegativeFeedbackDetailsNode
  cursor: String!
}

type TicketNoteNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  createdBy: UserNode
}

type TicketNoteNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketNoteNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketNoteNodeEdge {
  node: TicketNoteNode
  cursor: String!
}

input TicketPaymentVerificationDetailsExtras {
  newReceivedAmount: Float
  newStatus: String
}

enum TicketPaymentVerificationDetailsNewStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type TicketPaymentVerificationDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentVerifications(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationNodeConnection!
  paymentVerificationStatus: TicketPaymentVerificationDetailsPaymentVerificationStatus!
  paymentVerification: PaymentVerificationNode
  newStatus: TicketPaymentVerificationDetailsNewStatus
  newReceivedAmount: Float
  approveStatus: Boolean!
  hasMultiplePaymentVerifications: Boolean
}

type TicketPaymentVerificationDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketPaymentVerificationDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketPaymentVerificationDetailsNodeEdge {
  node: TicketPaymentVerificationDetailsNode
  cursor: String!
}

enum TicketPaymentVerificationDetailsPaymentVerificationStatus {
  NOT_RECEIVED
  PENDING
  RECEIVED
  RECEIVED_WITH_ISSUES
}

type TicketPositiveFeedbackDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketPositiveFeedbackDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketPositiveFeedbackDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketPositiveFeedbackDetailsNodeEdge {
  node: TicketPositiveFeedbackDetailsNode
  cursor: String!
}

type TicketReferralDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  household: HouseholdNode
  individual: IndividualNode
}

type TicketReferralDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketReferralDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketReferralDetailsNodeEdge {
  node: TicketReferralDetailsNode
  cursor: String!
}

type TicketSensitiveDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  paymentRecord: PaymentRecordNode
  household: HouseholdNode
  individual: IndividualNode
}

type TicketSensitiveDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketSensitiveDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketSensitiveDetailsNodeEdge {
  node: TicketSensitiveDetailsNode
  cursor: String!
}

type TicketSystemFlaggingDetailsNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  goldenRecordsIndividual: IndividualNode!
  sanctionListIndividual: SanctionListIndividualNode!
  approveStatus: Boolean!
  roleReassignData: JSONString!
}

type TicketSystemFlaggingDetailsNodeConnection {
  pageInfo: PageInfo!
  edges: [TicketSystemFlaggingDetailsNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type TicketSystemFlaggingDetailsNodeEdge {
  node: TicketSystemFlaggingDetailsNode
  cursor: String!
}

scalar UUID

type UnlockTargetPopulationMutation {
  targetPopulation: TargetPopulationNode
}

input UpdateAddIndividualIssueTypeExtras {
  individualData: AddIndividualDataObjectType!
}

input UpdateFeedbackInput {
  feedbackId: ID!
  issueType: String
  householdLookup: ID
  individualLookup: ID
  description: String
  comments: String
  admin2: ID
  area: String
  language: String
  consent: Boolean
  program: ID
}

type UpdateFeedbackMutation {
  feedback: FeedbackNode
}

input UpdateGrievanceTicketExtrasInput {
  householdDataUpdateIssueTypeExtras: UpdateHouseholdDataUpdateIssueTypeExtras
  individualDataUpdateIssueTypeExtras: UpdateIndividualDataUpdateIssueTypeExtras
  addIndividualIssueTypeExtras: UpdateAddIndividualIssueTypeExtras
  category: CategoryExtrasInput
  ticketPaymentVerificationDetailsExtras: TicketPaymentVerificationDetailsExtras
}

input UpdateGrievanceTicketInput {
  ticketId: ID!
  description: String
  assignedTo: ID
  admin: String
  area: String
  language: String
  linkedTickets: [ID]
  household: ID
  individual: ID
  paymentRecord: ID
  extras: UpdateGrievanceTicketExtrasInput
  priority: Int
  urgency: Int
  partner: Int
  programme: ID
  comments: String
  documentation: [GrievanceDocumentInput]
  documentationToUpdate: [GrievanceDocumentUpdateInput]
  documentationToDelete: [ID]
}

type UpdateGrievanceTicketMutation {
  grievanceTicket: GrievanceTicketNode
}

input UpdateHouseholdDataUpdateIssueTypeExtras {
  householdData: HouseholdUpdateDataObjectType!
}

input UpdateIndividualDataUpdateIssueTypeExtras {
  individualData: IndividualUpdateDataObjectType!
}

type UpdatePaymentVerificationReceivedAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdatePaymentVerificationStatusAndReceivedAmount {
  paymentVerification: PaymentVerificationNode
}

type UpdateProgram {
  validationErrors: Arg
  program: ProgramNode
}

input UpdateProgramInput {
  id: String!
  name: String
  status: String
  startDate: Date
  endDate: Date
  description: String
  budget: Decimal
  frequencyOfPayments: String
  sector: String
  scope: String
  cashPlus: Boolean
  populationGoal: Int
  administrativeAreasOfImplementation: String
  individualDataNeeded: Boolean
}

input UpdateTargetPopulationInput {
  id: ID!
  name: String
  targetingCriteria: TargetingCriteriaObjectType
  programId: ID
  vulnerabilityScoreMin: Decimal
  vulnerabilityScoreMax: Decimal
  excludedIds: String
  exclusionReason: String
}

type UpdateTargetPopulationMutation {
  validationErrors: Arg
  targetPopulation: TargetPopulationNode
}

scalar Upload

type UploadImportDataXLSXFileAsync {
  importData: ImportDataNode
  errors: [XlsxRowErrorNode]
}

type UserBusinessAreaNode implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  name: String!
  longName: String!
  regionCode: String!
  regionName: String!
  koboUsername: String
  rapidProHost: String
  rapidProApiKey: String
  slug: String!
  customFields: JSONString!
  hasDataSharingAgreement: Boolean!
  parent: UserBusinessAreaNode
  isSplit: Boolean!
  postponeDeduplication: Boolean!
  deduplicationDuplicateScore: Float!
  deduplicationPossibleDuplicateScore: Float!
  deduplicationBatchDuplicatesPercentage: Int!
  deduplicationBatchDuplicatesAllowed: Int!
  deduplicationGoldenRecordDuplicatesPercentage: Int!
  deduplicationGoldenRecordDuplicatesAllowed: Int!
  screenBeneficiary: Boolean!
  deduplicationIgnoreWithdraw: Boolean!
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection!
  userRoles: [UserRoleNode!]!
  paymentrecordSet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentRecordNodeConnection!
  serviceproviderSet(offset: Int, before: String, after: String, first: Int, last: Int): ServiceProviderNodeConnection!
  tickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  householdSet(offset: Int, before: String, after: String, first: Int, last: Int): HouseholdNodeConnection!
  individualSet(offset: Int, before: String, after: String, first: Int, last: Int): IndividualNodeConnection!
  programSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String): ProgramNodeConnection!
  cashplanSet(offset: Int, before: String, after: String, first: Int, last: Int): CashPlanNodeConnection!
  registrationdataimportSet(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  targetpopulationSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logentrySet(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messageSet(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbackSet(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  surveySet(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  permissions: [String]
}

type UserBusinessAreaNodeConnection {
  pageInfo: PageInfo!
  edges: [UserBusinessAreaNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserBusinessAreaNodeEdge {
  node: UserBusinessAreaNode
  cursor: String!
}

type UserNode implements Node {
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  id: ID!
  status: UserStatus!
  partner: PartnerType
  email: String!
  availableForExport: Boolean!
  customFields: JSONString!
  jobTitle: String!
  adUuid: String
  lastModifyDate: DateTime
  lastDoapSync: DateTime
  doapHash: String!
  userRoles: [UserRoleNode!]!
  createdTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  assignedTickets(offset: Int, before: String, after: String, first: Int, last: Int): GrievanceTicketNodeConnection!
  ticketNotes(offset: Int, before: String, after: String, first: Int, last: Int): TicketNoteNodeConnection!
  registrationDataImports(offset: Int, before: String, after: String, first: Int, last: Int): RegistrationDataImportNodeConnection!
  targetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  changedTargetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  finalizedTargetPopulations(offset: Int, before: String, after: String, first: Int, last: Int, name: String, createdByName: String, createdAt: DateTime, updatedAt: DateTime, status: String, households: [ID], totalHouseholdsCountMin: Int, totalHouseholdsCountMax: Int, totalIndividualsCountMin: Int, totalIndividualsCountMax: Int, businessArea: String, program: [ID], createdAtRange: String, orderBy: String): TargetPopulationNodeConnection!
  reports(offset: Int, before: String, after: String, first: Int, last: Int): ReportNodeConnection!
  logs(offset: Int, before: String, after: String, first: Int, last: Int): PaymentVerificationLogEntryNodeConnection!
  messages(offset: Int, before: String, after: String, first: Int, last: Int): CommunicationMessageNodeConnection!
  feedbacks(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackNodeConnection!
  feedbackMessages(offset: Int, before: String, after: String, first: Int, last: Int): FeedbackMessageNodeConnection!
  surveys(offset: Int, before: String, after: String, first: Int, last: Int): SurveyNodeConnection!
  businessAreas(offset: Int, before: String, after: String, first: Int, last: Int, id: UUID): UserBusinessAreaNodeConnection
}

type UserNodeConnection {
  pageInfo: PageInfo!
  edges: [UserNodeEdge]!
  totalCount: Int
  edgeCount: Int
}

type UserNodeEdge {
  node: UserNode
  cursor: String!
}

type UserRoleNode {
  createdAt: DateTime!
  updatedAt: DateTime!
  businessArea: UserBusinessAreaNode!
  role: RoleNode!
}

enum UserStatus {
  ACTIVE
  INACTIVE
  INVITED
}

type XlsxErrorNode {
  sheet: String
  coordinates: String
  message: String
}

type XlsxRowErrorNode {
  rowNumber: Int
  header: String
  message: String
}

type _DatasetsNode {
  data: [Float]
}

type _DetailedDatasetsNode {
  label: String
  data: [Float]
}

type _TableTotalCashTransferredDataNode {
  id: String
  admin2: String
  totalCashTransferred: Float
  totalHouseholds: Int
}
